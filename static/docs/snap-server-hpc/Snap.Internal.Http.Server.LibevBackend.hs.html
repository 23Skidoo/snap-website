<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    2 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveDataTypeable #-}
<span class="lineno">    4 </span>{-# LANGUAGE ForeignFunctionInterface #-}
<span class="lineno">    5 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    6 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    7 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    8 </span>{-# LANGUAGE PackageImports #-}
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>module Snap.Internal.Http.Server.LibevBackend
<span class="lineno">   11 </span>  ( libEvEventLoop
<span class="lineno">   12 </span>  ) where
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>#ifndef LIBEV
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>import Control.Exception
<span class="lineno">   17 </span>import Data.Typeable
<span class="lineno">   18 </span>import Snap.Internal.Http.Server.Backend
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>data LibevException = LibevException String
<span class="lineno">   21 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, <span class="decl"><span class="nottickedoff">Typeable</span></span>)
<span class="lineno">   22 </span>instance Exception LibevException
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>libEvEventLoop :: EventLoop
<span class="lineno">   25 </span><span class="decl"><span class="nottickedoff">libEvEventLoop _ _ _ _ _ = throwIO $</span>
<span class="lineno">   26 </span><span class="spaces">    </span><span class="nottickedoff">LibevException &quot;libev event loop is not supported&quot;</span></span>
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>#else
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>---------------------------
<span class="lineno">   31 </span>-- TODO: document module --
<span class="lineno">   32 </span>---------------------------
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>------------------------------------------------------------------------------
<span class="lineno">   35 </span>import             Control.Concurrent hiding (yield)
<span class="lineno">   36 </span>import             Control.Exception
<span class="lineno">   37 </span>import             Control.Monad
<span class="lineno">   38 </span>import             Control.Monad.Trans
<span class="lineno">   39 </span>import             Data.ByteString (ByteString)
<span class="lineno">   40 </span>import             Data.ByteString.Internal (c2w)
<span class="lineno">   41 </span>import qualified   Data.ByteString as S
<span class="lineno">   42 </span>import             Data.Maybe
<span class="lineno">   43 </span>import             Data.IORef
<span class="lineno">   44 </span>import             Data.Typeable
<span class="lineno">   45 </span>import             Foreign hiding (new)
<span class="lineno">   46 </span>import             Foreign.C.Types
<span class="lineno">   47 </span>import             GHC.Conc (forkOnIO)
<span class="lineno">   48 </span>import             Network.Libev
<span class="lineno">   49 </span>import             Network.Socket
<span class="lineno">   50 </span>import             Prelude hiding (catch)
<span class="lineno">   51 </span>------------------------------------------------------------------------------
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>-- FIXME: should be HashSet, make that later.
<span class="lineno">   54 </span>import qualified   Data.Concurrent.HashMap as H
<span class="lineno">   55 </span>import             Data.Concurrent.HashMap (HashMap)
<span class="lineno">   56 </span>import             Snap.Iteratee hiding (map)
<span class="lineno">   57 </span>import             Snap.Internal.Debug
<span class="lineno">   58 </span>import             Snap.Internal.Http.Server.Date
<span class="lineno">   59 </span>import             Snap.Internal.Http.Server.Backend
<span class="lineno">   60 </span>import qualified   Snap.Internal.Http.Server.ListenHelpers as Listen
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>#if defined(HAS_SENDFILE)
<span class="lineno">   63 </span>import qualified   System.SendFile as SF
<span class="lineno">   64 </span>import             System.Posix.IO
<span class="lineno">   65 </span>import             System.Posix.Types (Fd(..))
<span class="lineno">   66 </span>#endif
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>------------------------------------------------------------------------------
<span class="lineno">   70 </span>data Backend = Backend
<span class="lineno">   71 </span>    { _acceptSockets     :: [ListenSocket]
<span class="lineno">   72 </span>    , _evLoop            :: !EvLoopPtr
<span class="lineno">   73 </span>    , _acceptIOCallbacks :: ![MVar (FunPtr IoCallback)]
<span class="lineno">   74 </span>    , _acceptIOObjs      :: ![EvIoPtr]
<span class="lineno">   75 </span>    , _mutexCallbacks    :: !(FunPtr MutexCallback, FunPtr MutexCallback)
<span class="lineno">   76 </span>    , _loopLock          :: !(MVar ())
<span class="lineno">   77 </span>    , _asyncCb           :: !(FunPtr AsyncCallback)
<span class="lineno">   78 </span>    , _asyncObj          :: !EvAsyncPtr
<span class="lineno">   79 </span>    , _killCb            :: !(FunPtr AsyncCallback)
<span class="lineno">   80 </span>    , _killObj           :: !EvAsyncPtr
<span class="lineno">   81 </span>    , _connectionThreads :: !(HashMap ThreadId Connection)
<span class="lineno">   82 </span>    , _backendCPU        :: !Int
<span class="lineno">   83 </span>    , _loopExit          :: !(MVar ())
<span class="lineno">   84 </span>    }
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>------------------------------------------------------------------------------
<span class="lineno">   88 </span>data Connection = Connection
<span class="lineno">   89 </span>    { _backend             :: !Backend
<span class="lineno">   90 </span>    , _listenSocket        :: !ListenSocket
<span class="lineno">   91 </span>    , _rawSocket           :: !CInt
<span class="lineno">   92 </span>    , _sessionInfo         :: !SessionInfo
<span class="lineno">   93 </span>    , _readAvailable       :: !(MVar ())
<span class="lineno">   94 </span>    , _writeAvailable      :: !(MVar ())
<span class="lineno">   95 </span>    , _timerObj            :: !EvTimerPtr
<span class="lineno">   96 </span>    , _timerCallback       :: !(FunPtr TimerCallback)
<span class="lineno">   97 </span>    , _timerTimeoutTime    :: !(IORef CTime)
<span class="lineno">   98 </span>    , _readActive          :: !(IORef Bool)
<span class="lineno">   99 </span>    , _writeActive         :: !(IORef Bool)
<span class="lineno">  100 </span>    , _connReadIOObj       :: !EvIoPtr
<span class="lineno">  101 </span>    , _connReadIOCallback  :: !(FunPtr IoCallback)
<span class="lineno">  102 </span>    , _connWriteIOObj      :: !EvIoPtr
<span class="lineno">  103 </span>    , _connWriteIOCallback :: !(FunPtr IoCallback)
<span class="lineno">  104 </span>    , _connThread          :: !(ThreadId)
<span class="lineno">  105 </span>    }
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>------------------------------------------------------------------------------
<span class="lineno">  109 </span>libEvEventLoop :: EventLoop
<span class="lineno">  110 </span>libEvEventLoop defaultTimeout sockets cap elog handler = do
<span class="lineno">  111 </span>    backends &lt;- Prelude.mapM (newLoop defaultTimeout sockets handler elog)
<span class="lineno">  112 </span>                             [0..(cap-1)]
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>    debug &quot;libevEventLoop: waiting for loop exit&quot;
<span class="lineno">  115 </span>    ignoreException (Prelude.mapM_ (takeMVar . _loopExit) backends)
<span class="lineno">  116 </span>    debug &quot;libevEventLoop: stopping all backends&quot;
<span class="lineno">  117 </span>    ignoreException $ mapM stop backends
<span class="lineno">  118 </span>    ignoreException $ mapM Listen.closeSocket sockets
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>------------------------------------------------------------------------------
<span class="lineno">  122 </span>newLoop :: Int                   -- ^ default timeout
<span class="lineno">  123 </span>        -&gt; [ListenSocket]        -- ^ value you got from bindIt
<span class="lineno">  124 </span>        -&gt; SessionHandler        -- ^ handler
<span class="lineno">  125 </span>        -&gt; (ByteString -&gt; IO ()) -- ^ error logger
<span class="lineno">  126 </span>        -&gt; Int                   -- ^ cpu
<span class="lineno">  127 </span>        -&gt; IO Backend
<span class="lineno">  128 </span>newLoop defaultTimeout sockets handler elog cpu = do
<span class="lineno">  129 </span>    -- We'll try kqueue on OSX even though the libev docs complain that it's
<span class="lineno">  130 </span>    -- &quot;broken&quot;, in the hope that it works as expected for sockets
<span class="lineno">  131 </span>    f  &lt;- evRecommendedBackends
<span class="lineno">  132 </span>    lp &lt;- evLoopNew $ toEnum . fromEnum $ f .|. evbackend_kqueue
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>    -- we'll be working multithreaded so we need to set up locking for the C
<span class="lineno">  136 </span>    -- event loop struct
<span class="lineno">  137 </span>    (mc1,mc2,looplock) &lt;- setupLockingForLoop lp
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>    -- setup async callbacks -- these allow us to wake up the main loop
<span class="lineno">  140 </span>    -- (normally blocked in c-land) from other threads
<span class="lineno">  141 </span>    asyncObj &lt;- mkEvAsync
<span class="lineno">  142 </span>    asyncCB  &lt;- mkAsyncCallback $ \_ _ _ -&gt; do
<span class="lineno">  143 </span>                            debug &quot;async wakeup&quot;
<span class="lineno">  144 </span>                            return ()
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>    killObj &lt;- mkEvAsync
<span class="lineno">  147 </span>    killCB  &lt;- mkAsyncCallback $ \_ _ _ -&gt; do
<span class="lineno">  148 </span>                            debug &quot;async kill wakeup&quot;
<span class="lineno">  149 </span>                            evUnloop lp evunloop_all
<span class="lineno">  150 </span>                            return ()
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>    evAsyncInit asyncObj asyncCB
<span class="lineno">  153 </span>    evAsyncStart lp asyncObj
<span class="lineno">  154 </span>    evAsyncInit killObj killCB
<span class="lineno">  155 </span>    evAsyncStart lp killObj
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>    -- create the ios for the accept callbacks
<span class="lineno">  158 </span>    accMVars &lt;- forM sockets $ \_ -&gt; newEmptyMVar
<span class="lineno">  159 </span>    accIOs &lt;- forM sockets $ \_ -&gt; mkEvIo
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>    -- thread set stuff
<span class="lineno">  162 </span>    connSet &lt;- H.new (H.hashString . show)
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>    -- freed gets stuffed with () when all resources are released.
<span class="lineno">  165 </span>    freed &lt;- newEmptyMVar
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>    let b = Backend sockets
<span class="lineno">  168 </span>                    lp
<span class="lineno">  169 </span>                    accMVars
<span class="lineno">  170 </span>                    accIOs
<span class="lineno">  171 </span>                    (mc1,mc2)
<span class="lineno">  172 </span>                    looplock
<span class="lineno">  173 </span>                    asyncCB
<span class="lineno">  174 </span>                    asyncObj
<span class="lineno">  175 </span>                    killCB
<span class="lineno">  176 </span>                    killObj
<span class="lineno">  177 </span>                    connSet
<span class="lineno">  178 </span>                    cpu
<span class="lineno">  179 </span>                    freed
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>    -- setup the accept callback; this watches for read readiness on the
<span class="lineno">  182 </span>    -- listen port
<span class="lineno">  183 </span>    forM_ (zip3 sockets accIOs accMVars) $ \(sock, accIO, x) -&gt; do
<span class="lineno">  184 </span>        accCB &lt;- mkIoCallback $ acceptCallback defaultTimeout b handler elog
<span class="lineno">  185 </span>                                               cpu sock
<span class="lineno">  186 </span>        evIoInit accIO accCB (fdSocket $ Listen.listenSocket sock) ev_read
<span class="lineno">  187 </span>        evIoStart lp accIO
<span class="lineno">  188 </span>        putMVar x accCB
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>    forkOnIO cpu $ loopThread b
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>    debug $ &quot;LibEv.newLoop: loop spawned&quot;
<span class="lineno">  193 </span>    return b
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>------------------------------------------------------------------------------
<span class="lineno">  197 </span>-- | Run evLoop in a thread
<span class="lineno">  198 </span>loopThread :: Backend -&gt; IO ()
<span class="lineno">  199 </span>loopThread backend = do
<span class="lineno">  200 </span>    debug $ &quot;starting loop&quot;
<span class="lineno">  201 </span>    (ignoreException go) `finally` cleanup
<span class="lineno">  202 </span>    debug $ &quot;loop finished&quot;
<span class="lineno">  203 </span>  where
<span class="lineno">  204 </span>    cleanup = block $ do
<span class="lineno">  205 </span>        debug $ &quot;loopThread: cleaning up&quot;
<span class="lineno">  206 </span>        ignoreException $ freeBackend backend
<span class="lineno">  207 </span>        putMVar (_loopExit backend) ()
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>    lock    = _loopLock backend
<span class="lineno">  210 </span>    loop    = _evLoop backend
<span class="lineno">  211 </span>    go      = takeMVar lock &gt;&gt; block (evLoop loop 0)
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>------------------------------------------------------------------------------
<span class="lineno">  215 </span>acceptCallback :: Int
<span class="lineno">  216 </span>               -&gt; Backend
<span class="lineno">  217 </span>               -&gt; SessionHandler
<span class="lineno">  218 </span>               -&gt; (ByteString -&gt; IO ())
<span class="lineno">  219 </span>               -&gt; Int
<span class="lineno">  220 </span>               -&gt; ListenSocket
<span class="lineno">  221 </span>               -&gt; IoCallback
<span class="lineno">  222 </span>acceptCallback defaultTimeout back handler
<span class="lineno">  223 </span>               elog cpu sock _loopPtr _ioPtr _ = do
<span class="lineno">  224 </span>    debug &quot;inside acceptCallback&quot;
<span class="lineno">  225 </span>    r &lt;- c_accept $ fdSocket $ Listen.listenSocket sock
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>    case r of
<span class="lineno">  228 </span>      -- this (EWOULDBLOCK) shouldn't happen (we just got told it was ready!),
<span class="lineno">  229 </span>      -- if it does (maybe the request got picked up by another thread) we'll
<span class="lineno">  230 </span>      -- just bail out
<span class="lineno">  231 </span>      -2 -&gt; return ()
<span class="lineno">  232 </span>      -1 -&gt; debugErrno &quot;Libev.acceptCallback:c_accept()&quot;
<span class="lineno">  233 </span>      fd -&gt; do
<span class="lineno">  234 </span>          debug $ &quot;acceptCallback: accept()ed fd, writing to chan &quot; ++ show fd
<span class="lineno">  235 </span>          forkOnIO cpu $ (go r `catches` cleanup)
<span class="lineno">  236 </span>          return ()
<span class="lineno">  237 </span>  where
<span class="lineno">  238 </span>    go = runSession defaultTimeout back handler sock
<span class="lineno">  239 </span>    cleanup = [ Handler $ \(_ :: TimeoutException) -&gt; return ()
<span class="lineno">  240 </span>              , Handler $ \(e :: SomeException) -&gt;
<span class="lineno">  241 </span>                  elog $ S.concat [ &quot;libev.acceptCallback: &quot;
<span class="lineno">  242 </span>                                  , S.pack . map c2w $ show e ]
<span class="lineno">  243 </span>              ]
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>------------------------------------------------------------------------------
<span class="lineno">  247 </span>ioReadCallback :: CInt -&gt; IORef Bool -&gt; MVar () -&gt; IoCallback
<span class="lineno">  248 </span>ioReadCallback fd active ra _loopPtr _ioPtr _ = do
<span class="lineno">  249 </span>    -- send notifications to the worker thread
<span class="lineno">  250 </span>    debug $ &quot;ioReadCallback: notification (&quot; ++ show fd ++ &quot;)&quot;
<span class="lineno">  251 </span>    tryPutMVar ra ()
<span class="lineno">  252 </span>    debug $ &quot;stopping ioReadCallback (&quot; ++ show fd ++ &quot;)&quot;
<span class="lineno">  253 </span>    evIoStop _loopPtr _ioPtr
<span class="lineno">  254 </span>    writeIORef active False
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>------------------------------------------------------------------------------
<span class="lineno">  258 </span>ioWriteCallback :: CInt -&gt; IORef Bool -&gt; MVar () -&gt; IoCallback
<span class="lineno">  259 </span>ioWriteCallback fd active wa _loopPtr _ioPtr _ = do
<span class="lineno">  260 </span>    -- send notifications to the worker thread
<span class="lineno">  261 </span>    debug $ &quot;ioWriteCallback: notification (&quot; ++ show fd ++ &quot;)&quot;
<span class="lineno">  262 </span>    tryPutMVar wa ()
<span class="lineno">  263 </span>    debug $ &quot;stopping ioWriteCallback (&quot; ++ show fd ++ &quot;)&quot;
<span class="lineno">  264 </span>    evIoStop _loopPtr _ioPtr
<span class="lineno">  265 </span>    writeIORef active False
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>------------------------------------------------------------------------------
<span class="lineno">  269 </span>stop :: Backend -&gt; IO ()
<span class="lineno">  270 </span>stop b = ignoreException $ do
<span class="lineno">  271 </span>    debug $ &quot;Libev.stop&quot;
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>    -- 1. take the loop lock
<span class="lineno">  274 </span>    -- 2. shut down the accept() callback
<span class="lineno">  275 </span>    -- 3. call evUnloop and wake up the loop using evAsyncSend
<span class="lineno">  276 </span>    -- 4. release the loop lock, the main loop thread should then free/clean
<span class="lineno">  277 </span>    --    everything up (threads, connections, io objects, callbacks, etc)
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>    withMVar lock $ \_ -&gt; do
<span class="lineno">  280 </span>        forM acceptObjs $ evIoStop loop
<span class="lineno">  281 </span>        evUnloop loop evunloop_all
<span class="lineno">  282 </span>        evAsyncSend loop killObj
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>  where
<span class="lineno">  285 </span>    loop           = _evLoop b
<span class="lineno">  286 </span>    acceptObjs     = _acceptIOObjs b
<span class="lineno">  287 </span>    killObj        = _killObj b
<span class="lineno">  288 </span>    lock           = _loopLock b
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>------------------------------------------------------------------------------
<span class="lineno">  292 </span>getAddr :: SockAddr -&gt; IO (ByteString, Int)
<span class="lineno">  293 </span>getAddr addr =
<span class="lineno">  294 </span>    case addr of
<span class="lineno">  295 </span>      SockAddrInet p ha -&gt; do
<span class="lineno">  296 </span>          s &lt;- liftM (S.pack . map c2w) (inet_ntoa ha)
<span class="lineno">  297 </span>          return (s, fromIntegral p)
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>      a -&gt; throwIO $ AddressNotSupportedException (show a)
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>------------------------------------------------------------------------------
<span class="lineno">  303 </span>-- | Throws a timeout exception to the handling thread.  The thread will clean
<span class="lineno">  304 </span>-- up everything.
<span class="lineno">  305 </span>timerCallback :: EvLoopPtr         -- ^ loop obj
<span class="lineno">  306 </span>              -&gt; EvTimerPtr        -- ^ timer obj
<span class="lineno">  307 </span>              -&gt; IORef CTime       -- ^ when to timeout?
<span class="lineno">  308 </span>              -&gt; ThreadId          -- ^ thread to kill
<span class="lineno">  309 </span>              -&gt; TimerCallback
<span class="lineno">  310 </span>timerCallback loop tmr ioref tid _ _ _ = do
<span class="lineno">  311 </span>    debug &quot;Libev.timerCallback: entered&quot;
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>    now       &lt;- getCurrentDateTime
<span class="lineno">  314 </span>    whenToDie &lt;- readIORef ioref
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>    if whenToDie &lt;= now
<span class="lineno">  317 </span>      then do
<span class="lineno">  318 </span>          debug &quot;Libev.timerCallback: killing thread&quot;
<span class="lineno">  319 </span>          throwTo tid TimeoutException
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>      else do
<span class="lineno">  322 </span>          debug $ &quot;Libev.timerCallback: now=&quot; ++ show now
<span class="lineno">  323 </span>                  ++ &quot;, whenToDie=&quot; ++ show whenToDie
<span class="lineno">  324 </span>          evTimerSetRepeat tmr $ fromRational . toRational $ (whenToDie - now)
<span class="lineno">  325 </span>          evTimerAgain loop tmr
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>
<span class="lineno">  328 </span>------------------------------------------------------------------------------
<span class="lineno">  329 </span>-- | If you already hold the loop lock, you are entitled to destroy a
<span class="lineno">  330 </span>-- connection
<span class="lineno">  331 </span>destroyConnection :: Connection -&gt; IO ()
<span class="lineno">  332 </span>destroyConnection conn = do
<span class="lineno">  333 </span>    debug &quot;Libev.destroyConnection: closing socket and killing connection&quot;
<span class="lineno">  334 </span>    c_close fd
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>    -- stop and free timer object
<span class="lineno">  337 </span>    evTimerStop loop timerObj
<span class="lineno">  338 </span>    freeEvTimer timerObj
<span class="lineno">  339 </span>    freeTimerCallback timerCb
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>    -- stop and free i/o objects
<span class="lineno">  342 </span>    evIoStop loop ioWrObj
<span class="lineno">  343 </span>    freeEvIo ioWrObj
<span class="lineno">  344 </span>    freeIoCallback ioWrCb
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>    evIoStop loop ioRdObj
<span class="lineno">  347 </span>    freeEvIo ioRdObj
<span class="lineno">  348 </span>    freeIoCallback ioRdCb
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>  where
<span class="lineno">  351 </span>    backend    = _backend conn
<span class="lineno">  352 </span>    loop       = _evLoop backend
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>    fd         = _rawSocket conn
<span class="lineno">  355 </span>    ioWrObj    = _connWriteIOObj conn
<span class="lineno">  356 </span>    ioWrCb     = _connWriteIOCallback conn
<span class="lineno">  357 </span>    ioRdObj    = _connReadIOObj conn
<span class="lineno">  358 </span>    ioRdCb     = _connReadIOCallback conn
<span class="lineno">  359 </span>    timerObj   = _timerObj conn
<span class="lineno">  360 </span>    timerCb    = _timerCallback conn
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>------------------------------------------------------------------------------
<span class="lineno">  364 </span>freeConnection :: Connection -&gt; IO ()
<span class="lineno">  365 </span>freeConnection conn = ignoreException $ do
<span class="lineno">  366 </span>    withMVar loopLock $ \_ -&gt; block $ do
<span class="lineno">  367 </span>        debug $ &quot;freeConnection (&quot; ++ show (_rawSocket conn) ++ &quot;)&quot;
<span class="lineno">  368 </span>        destroyConnection conn
<span class="lineno">  369 </span>        let tid = _connThread conn
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>        -- remove the thread id from the backend set
<span class="lineno">  372 </span>        H.delete tid $ _connectionThreads backend
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>        -- wake up the event loop so it can be apprised of the changes
<span class="lineno">  375 </span>        evAsyncSend loop asyncObj
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>  where
<span class="lineno">  378 </span>    backend    = _backend conn
<span class="lineno">  379 </span>    loop       = _evLoop backend
<span class="lineno">  380 </span>    loopLock   = _loopLock backend
<span class="lineno">  381 </span>    asyncObj   = _asyncObj backend
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>------------------------------------------------------------------------------
<span class="lineno">  385 </span>freeBackend :: Backend -&gt; IO ()
<span class="lineno">  386 </span>freeBackend backend = ignoreException $ block $ do
<span class="lineno">  387 </span>    -- note: we only get here after an unloop, so we have the loop lock
<span class="lineno">  388 </span>    -- here. (?)
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>    -- kill everything in thread table
<span class="lineno">  391 </span>    tset &lt;- H.toList $ _connectionThreads backend
<span class="lineno">  392 </span>
<span class="lineno">  393 </span>    let nthreads = Prelude.length tset
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>    debug $ &quot;Libev.freeBackend: killing active connection threads&quot;
<span class="lineno">  396 </span>
<span class="lineno">  397 </span>    Prelude.mapM_ (destroyConnection . snd) tset
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>    -- kill the threads twice, they're probably getting stuck in the
<span class="lineno">  400 </span>    -- freeConnection 'finally' handler
<span class="lineno">  401 </span>    Prelude.mapM_ (killThread . fst) tset
<span class="lineno">  402 </span>    Prelude.mapM_ (killThread . fst) tset
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>    debug $ &quot;Libev.freeBackend: &quot; ++ show nthreads ++ &quot; thread(s) killed&quot;
<span class="lineno">  405 </span>    debug $ &quot;Libev.freeBackend: destroying libev resources&quot;
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>    mapM freeEvIo acceptObjs
<span class="lineno">  408 </span>    forM acceptCbs $ \x -&gt; do
<span class="lineno">  409 </span>        acceptCb &lt;- readMVar x
<span class="lineno">  410 </span>        freeIoCallback acceptCb
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>    evAsyncStop loop asyncObj
<span class="lineno">  413 </span>    freeEvAsync asyncObj
<span class="lineno">  414 </span>    freeAsyncCallback asyncCb
<span class="lineno">  415 </span>
<span class="lineno">  416 </span>    evAsyncStop loop killObj
<span class="lineno">  417 </span>    freeEvAsync killObj
<span class="lineno">  418 </span>    freeAsyncCallback killCb
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>    freeMutexCallback mcb1
<span class="lineno">  421 </span>    freeMutexCallback mcb2
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>    evLoopDestroy loop
<span class="lineno">  424 </span>    debug $ &quot;Libev.freeBackend: resources destroyed&quot;
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>  where
<span class="lineno">  427 </span>    acceptObjs  = _acceptIOObjs backend
<span class="lineno">  428 </span>    acceptCbs   = _acceptIOCallbacks backend
<span class="lineno">  429 </span>    asyncObj    = _asyncObj backend
<span class="lineno">  430 </span>    asyncCb     = _asyncCb backend
<span class="lineno">  431 </span>    killObj     = _killObj backend
<span class="lineno">  432 </span>    killCb      = _killCb backend
<span class="lineno">  433 </span>    (mcb1,mcb2) = _mutexCallbacks backend
<span class="lineno">  434 </span>    loop        = _evLoop backend
<span class="lineno">  435 </span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>------------------------------------------------------------------------------
<span class="lineno">  438 </span>-- | Note: proc gets run in the background
<span class="lineno">  439 </span>runSession :: Int
<span class="lineno">  440 </span>           -&gt; Backend
<span class="lineno">  441 </span>           -&gt; SessionHandler
<span class="lineno">  442 </span>           -&gt; ListenSocket
<span class="lineno">  443 </span>           -&gt; CInt
<span class="lineno">  444 </span>           -&gt; IO ()
<span class="lineno">  445 </span>runSession defaultTimeout backend handler lsock fd = do
<span class="lineno">  446 </span>    sock &lt;- mkSocket fd AF_INET Stream 0 Connected
<span class="lineno">  447 </span>    peerName &lt;- getPeerName sock
<span class="lineno">  448 </span>    sockName &lt;- getSocketName sock
<span class="lineno">  449 </span>    tid &lt;- myThreadId
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>    -- set_linger fd
<span class="lineno">  452 </span>    c_setnonblocking fd
<span class="lineno">  453 </span>
<span class="lineno">  454 </span>    (raddr, rport) &lt;- getAddr peerName
<span class="lineno">  455 </span>    (laddr, lport) &lt;- getAddr sockName
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>    let lp = _evLoop backend
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>    -- makes sense to assume the socket is read/write available when
<span class="lineno">  460 </span>    -- opened; worst-case is we get EWOULDBLOCK
<span class="lineno">  461 </span>    ra    &lt;- newMVar ()
<span class="lineno">  462 </span>    wa    &lt;- newMVar ()
<span class="lineno">  463 </span>
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>    -----------------
<span class="lineno">  466 </span>    -- setup timer --
<span class="lineno">  467 </span>    -----------------
<span class="lineno">  468 </span>    tmr         &lt;- mkEvTimer
<span class="lineno">  469 </span>    now         &lt;- getCurrentDateTime
<span class="lineno">  470 </span>    timeoutTime &lt;- newIORef $ now + 20
<span class="lineno">  471 </span>    tcb         &lt;- mkTimerCallback $ timerCallback lp
<span class="lineno">  472 </span>                                                  tmr
<span class="lineno">  473 </span>                                                  timeoutTime
<span class="lineno">  474 </span>                                                  tid
<span class="lineno">  475 </span>    -- 20 second timeout
<span class="lineno">  476 </span>    evTimerInit tmr tcb 0 20.0
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>    readActive  &lt;- newIORef True
<span class="lineno">  480 </span>    writeActive &lt;- newIORef True
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>    evioRead &lt;- mkEvIo
<span class="lineno">  483 </span>    ioReadCb &lt;- mkIoCallback $ ioReadCallback fd readActive ra
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>    evioWrite &lt;- mkEvIo
<span class="lineno">  486 </span>    ioWriteCb &lt;- mkIoCallback $ ioWriteCallback fd writeActive wa
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>    evIoInit evioRead ioReadCb fd ev_read
<span class="lineno">  489 </span>    evIoInit evioWrite ioWriteCb fd ev_write
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>    -- take ev_loop lock, start timer and io watchers
<span class="lineno">  492 </span>    withMVar (_loopLock backend) $ \_ -&gt; do
<span class="lineno">  493 </span>         evTimerAgain lp tmr
<span class="lineno">  494 </span>         evIoStart lp evioRead
<span class="lineno">  495 </span>         evIoStart lp evioWrite
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>         -- wakeup the loop thread so that these new watchers get
<span class="lineno">  498 </span>         -- registered next time through the loop
<span class="lineno">  499 </span>         evAsyncSend lp $ _asyncObj backend
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>    let sinfo = SessionInfo laddr lport raddr rport $
<span class="lineno">  502 </span>                    Listen.isSecure lsock
<span class="lineno">  503 </span>    let conn = Connection backend
<span class="lineno">  504 </span>                          lsock
<span class="lineno">  505 </span>                          fd
<span class="lineno">  506 </span>                          sinfo
<span class="lineno">  507 </span>                          ra
<span class="lineno">  508 </span>                          wa
<span class="lineno">  509 </span>                          tmr
<span class="lineno">  510 </span>                          tcb
<span class="lineno">  511 </span>                          timeoutTime
<span class="lineno">  512 </span>                          readActive
<span class="lineno">  513 </span>                          writeActive
<span class="lineno">  514 </span>                          evioRead
<span class="lineno">  515 </span>                          ioReadCb
<span class="lineno">  516 </span>                          evioWrite
<span class="lineno">  517 </span>                          ioWriteCb
<span class="lineno">  518 </span>                          tid
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>    bracket (Listen.createSession lsock bLOCKSIZE fd $
<span class="lineno">  521 </span>                   waitForLock True conn)
<span class="lineno">  522 </span>            (\session -&gt; block $ do
<span class="lineno">  523 </span>                debug &quot;runSession: thread killed, closing socket&quot;
<span class="lineno">  524 </span>
<span class="lineno">  525 </span>                ignoreException $ Listen.endSession lsock session
<span class="lineno">  526 </span>                ignoreException $ freeConnection conn
<span class="lineno">  527 </span>            )
<span class="lineno">  528 </span>            (\session -&gt; do H.update tid conn (_connectionThreads backend)
<span class="lineno">  529 </span>                            handler sinfo
<span class="lineno">  530 </span>                                    (enumerate conn session)
<span class="lineno">  531 </span>                                    (writeOut defaultTimeout conn session)
<span class="lineno">  532 </span>                                    (sendFile defaultTimeout conn session)
<span class="lineno">  533 </span>                                    (tickleTimeout conn)
<span class="lineno">  534 </span>            )
<span class="lineno">  535 </span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>------------------------------------------------------------------------------
<span class="lineno">  538 </span>ignoreException :: IO a -&gt; IO ()
<span class="lineno">  539 </span>ignoreException act =
<span class="lineno">  540 </span>    (act &gt;&gt; return ()) `catch` \(_::SomeException) -&gt; return ()
<span class="lineno">  541 </span>
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>------------------------------------------------------------------------------
<span class="lineno">  544 </span>data AddressNotSupportedException = AddressNotSupportedException String
<span class="lineno">  545 </span>   deriving (Typeable)
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>instance Show AddressNotSupportedException where
<span class="lineno">  548 </span>    show (AddressNotSupportedException x) = &quot;Address not supported: &quot; ++ x
<span class="lineno">  549 </span>
<span class="lineno">  550 </span>instance Exception AddressNotSupportedException
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>
<span class="lineno">  553 </span>------------------------------------------------------------------------------
<span class="lineno">  554 </span>
<span class="lineno">  555 </span>bLOCKSIZE :: Int
<span class="lineno">  556 </span>bLOCKSIZE = 8192
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>--
<span class="lineno">  559 </span>-- About timeouts
<span class="lineno">  560 </span>--
<span class="lineno">  561 </span>-- It's not good enough to restart the timer from io(Read|Write)Callback,
<span class="lineno">  562 </span>-- because those seem to be edge-triggered. I've definitely had where after 20
<span class="lineno">  563 </span>-- seconds they still weren't being re-awakened.
<span class="lineno">  564 </span>--
<span class="lineno">  565 </span>
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>------------------------------------------------------------------------------
<span class="lineno">  568 </span>data TimeoutException = TimeoutException
<span class="lineno">  569 </span>   deriving (Typeable)
<span class="lineno">  570 </span>
<span class="lineno">  571 </span>instance Show TimeoutException where
<span class="lineno">  572 </span>    show _ = &quot;timeout&quot;
<span class="lineno">  573 </span>
<span class="lineno">  574 </span>instance Exception TimeoutException
<span class="lineno">  575 </span>
<span class="lineno">  576 </span>
<span class="lineno">  577 </span>------------------------------------------------------------------------------
<span class="lineno">  578 </span>tickleTimeout :: Connection -&gt; Int -&gt; IO ()
<span class="lineno">  579 </span>tickleTimeout conn tm = do
<span class="lineno">  580 </span>    debug &quot;Libev.tickleTimeout&quot;
<span class="lineno">  581 </span>    now       &lt;- getCurrentDateTime
<span class="lineno">  582 </span>    writeIORef (_timerTimeoutTime conn) (now + toEnum tm)
<span class="lineno">  583 </span>
<span class="lineno">  584 </span>
<span class="lineno">  585 </span>------------------------------------------------------------------------------
<span class="lineno">  586 </span>waitForLock :: Bool        -- ^ True = wait for read, False = wait for write
<span class="lineno">  587 </span>            -&gt; Connection
<span class="lineno">  588 </span>            -&gt; IO ()
<span class="lineno">  589 </span>waitForLock readLock conn = do
<span class="lineno">  590 </span>    dbg &quot;start waitForLock&quot;
<span class="lineno">  591 </span>
<span class="lineno">  592 </span>    withMVar looplock $ \_ -&gt; do
<span class="lineno">  593 </span>        act &lt;- readIORef active
<span class="lineno">  594 </span>        if act
<span class="lineno">  595 </span>          then dbg &quot;read watcher already active, skipping&quot;
<span class="lineno">  596 </span>          else do
<span class="lineno">  597 </span>            dbg &quot;starting watcher, sending async&quot;
<span class="lineno">  598 </span>            tryTakeMVar lock
<span class="lineno">  599 </span>            evIoStart lp io
<span class="lineno">  600 </span>            writeIORef active True
<span class="lineno">  601 </span>            evAsyncSend lp async
<span class="lineno">  602 </span>
<span class="lineno">  603 </span>    dbg &quot;waitForLock: waiting for mvar&quot;
<span class="lineno">  604 </span>    takeMVar lock
<span class="lineno">  605 </span>    dbg &quot;waitForLock: took mvar&quot;
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>  where
<span class="lineno">  608 </span>    dbg s    = debug $ &quot;Libev.recvData(&quot; ++ show (_rawSocket conn) ++ &quot;): &quot;
<span class="lineno">  609 </span>                       ++ s
<span class="lineno">  610 </span>    io       = if readLock
<span class="lineno">  611 </span>                 then (_connReadIOObj conn)
<span class="lineno">  612 </span>                 else (_connWriteIOObj conn)
<span class="lineno">  613 </span>    bk       = _backend conn
<span class="lineno">  614 </span>    active   = if readLock
<span class="lineno">  615 </span>                 then (_readActive conn)
<span class="lineno">  616 </span>                 else (_writeActive conn)
<span class="lineno">  617 </span>    lp       = _evLoop bk
<span class="lineno">  618 </span>    looplock = _loopLock bk
<span class="lineno">  619 </span>    async    = _asyncObj bk
<span class="lineno">  620 </span>    lock     = if readLock
<span class="lineno">  621 </span>                 then (_readAvailable conn)
<span class="lineno">  622 </span>                 else (_writeAvailable conn)
<span class="lineno">  623 </span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>------------------------------------------------------------------------------
<span class="lineno">  626 </span>sendFile :: Int
<span class="lineno">  627 </span>         -&gt; Connection
<span class="lineno">  628 </span>         -&gt; NetworkSession
<span class="lineno">  629 </span>         -&gt; FilePath
<span class="lineno">  630 </span>         -&gt; Int64
<span class="lineno">  631 </span>         -&gt; Int64
<span class="lineno">  632 </span>         -&gt; IO ()
<span class="lineno">  633 </span>sendFile defaultTimeout c s fp start sz = do
<span class="lineno">  634 </span>    withMVar lock $ \_ -&gt; do
<span class="lineno">  635 </span>      act &lt;- readIORef $ _writeActive c
<span class="lineno">  636 </span>      when act $ evIoStop loop io
<span class="lineno">  637 </span>      writeIORef (_writeActive c) False
<span class="lineno">  638 </span>      evAsyncSend loop asy
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>#if defined(HAS_SENDFILE)
<span class="lineno">  641 </span>    case (_listenSocket c) of
<span class="lineno">  642 </span>        ListenHttp _ -&gt; bracket (openFd fp ReadOnly Nothing defaultFileFlags)
<span class="lineno">  643 </span>                                (closeFd)
<span class="lineno">  644 </span>                                (go start sz)
<span class="lineno">  645 </span>        _            -&gt; do
<span class="lineno">  646 </span>            step &lt;- runIteratee $ writeOut defaultTimeout c s
<span class="lineno">  647 </span>            run_ $ enumFilePartial fp (start,start+sz) step
<span class="lineno">  648 </span>#else
<span class="lineno">  649 </span>    step &lt;- runIteratee $ writeOut defaultTimeout c s
<span class="lineno">  650 </span>
<span class="lineno">  651 </span>    run_ $ enumFilePartial fp (start,start+sz) step
<span class="lineno">  652 </span>    return ()
<span class="lineno">  653 </span>#endif
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>    withMVar lock $ \_ -&gt; do
<span class="lineno">  656 </span>      tryTakeMVar $ _readAvailable c
<span class="lineno">  657 </span>      tryTakeMVar $ _writeAvailable c
<span class="lineno">  658 </span>      evAsyncSend loop asy
<span class="lineno">  659 </span>
<span class="lineno">  660 </span>  where
<span class="lineno">  661 </span>#if defined(HAS_SENDFILE)
<span class="lineno">  662 </span>    go off bytes fd
<span class="lineno">  663 </span>      | bytes == 0 = return ()
<span class="lineno">  664 </span>      | otherwise  = do
<span class="lineno">  665 </span>            sent &lt;- SF.sendFile (waitForLock False c) sfd fd off bytes
<span class="lineno">  666 </span>            if sent &lt; bytes
<span class="lineno">  667 </span>              then tickleTimeout c defaultTimeout &gt;&gt;
<span class="lineno">  668 </span>                   go (off+sent) (bytes-sent) fd
<span class="lineno">  669 </span>              else return ()
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>    sfd  = Fd $ _rawSocket c
<span class="lineno">  672 </span>#endif
<span class="lineno">  673 </span>    io   = _connWriteIOObj c
<span class="lineno">  674 </span>    b    = _backend c
<span class="lineno">  675 </span>    loop = _evLoop b
<span class="lineno">  676 </span>    lock = _loopLock b
<span class="lineno">  677 </span>    asy  = _asyncObj b
<span class="lineno">  678 </span>
<span class="lineno">  679 </span>
<span class="lineno">  680 </span>------------------------------------------------------------------------------
<span class="lineno">  681 </span>enumerate :: (MonadIO m)
<span class="lineno">  682 </span>          =&gt; Connection
<span class="lineno">  683 </span>          -&gt; NetworkSession
<span class="lineno">  684 </span>          -&gt; Enumerator ByteString m a
<span class="lineno">  685 </span>enumerate conn session = loop
<span class="lineno">  686 </span>  where
<span class="lineno">  687 </span>    dbg s = debug $ &quot;Libev.enumerate(&quot; ++ show (_socket session)
<span class="lineno">  688 </span>                    ++ &quot;): &quot; ++ s
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>    loop (Continue k) = do
<span class="lineno">  691 </span>        m &lt;- liftIO $ recvData
<span class="lineno">  692 </span>        let s = fromMaybe &quot;&quot; m
<span class="lineno">  693 </span>        sendOne k s
<span class="lineno">  694 </span>    loop x = returnI x
<span class="lineno">  695 </span>
<span class="lineno">  696 </span>    sendOne k s | S.null s  = do
<span class="lineno">  697 </span>        dbg &quot;sending EOF to continuation&quot;
<span class="lineno">  698 </span>        enumEOF $ Continue k
<span class="lineno">  699 </span>
<span class="lineno">  700 </span>                | otherwise = do
<span class="lineno">  701 </span>        dbg $ &quot;sending &quot; ++ show s ++ &quot; to continuation&quot;
<span class="lineno">  702 </span>        step &lt;- lift $ runIteratee $ k $ Chunks [s]
<span class="lineno">  703 </span>        case step of
<span class="lineno">  704 </span>          (Yield x st)   -&gt; do
<span class="lineno">  705 </span>                      dbg $ &quot;got yield, remainder is &quot; ++ show st
<span class="lineno">  706 </span>                      yield x st
<span class="lineno">  707 </span>          r@(Continue _) -&gt; do
<span class="lineno">  708 </span>                      dbg $ &quot;got continue&quot;
<span class="lineno">  709 </span>                      loop r
<span class="lineno">  710 </span>          (Error e)      -&gt; throwError e
<span class="lineno">  711 </span>
<span class="lineno">  712 </span>    recvData = Listen.recv (_listenSocket conn)
<span class="lineno">  713 </span>                           (waitForLock True conn) session
<span class="lineno">  714 </span>
<span class="lineno">  715 </span>
<span class="lineno">  716 </span>------------------------------------------------------------------------------
<span class="lineno">  717 </span>writeOut :: (MonadIO m)
<span class="lineno">  718 </span>         =&gt; Int
<span class="lineno">  719 </span>         -&gt; Connection
<span class="lineno">  720 </span>         -&gt; NetworkSession
<span class="lineno">  721 </span>         -&gt; Iteratee ByteString m ()
<span class="lineno">  722 </span>writeOut defaultTimeout conn session = loop
<span class="lineno">  723 </span>  where
<span class="lineno">  724 </span>    loop = continue k
<span class="lineno">  725 </span>
<span class="lineno">  726 </span>    k EOF = yield () EOF
<span class="lineno">  727 </span>    k (Chunks xs) = do
<span class="lineno">  728 </span>        liftIO $ sendData $ S.concat xs
<span class="lineno">  729 </span>        loop
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>    sendData = Listen.send (_listenSocket conn)
<span class="lineno">  732 </span>                           (tickleTimeout conn defaultTimeout)
<span class="lineno">  733 </span>                           (waitForLock False conn)
<span class="lineno">  734 </span>                           session
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>#endif

</pre>
</html>
