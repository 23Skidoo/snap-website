<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"
><TITLE
>Snap.Types</TITLE
><LINK HREF="haddock.css" REL="stylesheet" TYPE="text/css"
><SCRIPT SRC="haddock-util.js" TYPE="text/javascript"
></SCRIPT
><SCRIPT TYPE="text/javascript"
>window.onload = function () {setSynopsis("mini_Snap-Types.html")};</SCRIPT
></HEAD
><BODY
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topbar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><IMG SRC="haskell_icon.gif" WIDTH="16" HEIGHT="16" ALT=" "
></TD
><TD CLASS="title"
>snap-core-0.3.0: Snap: A Haskell Web Framework (Core)</TD
><TD CLASS="topbut"
><A HREF="src/Snap-Types.html"
>Source code</A
></TD
><TD CLASS="topbut"
><A HREF="index.html"
>Contents</A
></TD
><TD CLASS="topbut"
><A HREF="doc-index.html"
>Index</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="modulebar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><FONT SIZE="6"
>Snap.Types</FONT
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="section4"
><B
>Contents</B
></TD
></TR
><TR
><TD
><DL
><DT
><A HREF="#1"
>The Snap Monad
</A
></DT
><DD
><DL
><DT
><A HREF="#2"
>Functions for control flow and early termination
</A
></DT
><DT
><A HREF="#3"
>Routing
</A
></DT
><DT
><A HREF="#4"
>Access to state
</A
></DT
><DT
><A HREF="#5"
>Logging
</A
></DT
><DT
><A HREF="#6"
>Grabbing/transforming request bodies
</A
></DT
></DL
></DD
><DT
><A HREF="#7"
>HTTP Datatypes and Functions
</A
></DT
><DD
><DL
><DT
><A HREF="#8"
>Headers
</A
></DT
><DT
><A HREF="#9"
>Requests
</A
></DT
><DT
><A HREF="#10"
>Responses
</A
></DT
><DD
><DL
><DT
><A HREF="#11"
>Response I/O
</A
></DT
></DL
></DD
></DL
></DD
><DT
><A HREF="#12"
>Iteratee
</A
></DT
><DT
><A HREF="#13"
>HTTP utilities
</A
></DT
></DL
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Description</TD
></TR
><TR
><TD CLASS="doc"
>This module contains the core type definitions, class instances, and functions
for HTTP as well as the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad, which is used for web handlers.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Synopsis</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ASnap"
>Snap</A
> a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArunSnap"
>runSnap</A
> ::  <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> a -&gt; (<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
>) -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
>, <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
>)</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonad"
>Monad</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html#t%3AMonadIO"
>MonadIO</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AMonadCatchIO"
>MonadCatchIO</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonadPlus"
>MonadPlus</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AFunctor"
>Functor</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AApplicative"
>Applicative</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AAlternative"
>Alternative</A
> m) =&gt; <A HREF="#t%3AMonadSnap"
>MonadSnap</A
> m  <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3AliftSnap"
>liftSnap</A
> ::  <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> a -&gt; m a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ANoHandlerException"
>NoHandlerException</A
>  = <A HREF="#v%3ANoHandlerException"
>NoHandlerException</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AbracketSnap"
>bracketSnap</A
> ::  <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a -&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> b) -&gt; (a -&gt; <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> c) -&gt; <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> c</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfinishWith"
>finishWith</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Apass"
>pass</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Amethod"
>method</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
> -&gt; m a -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Apath"
>path</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m a -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Adir"
>dir</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m a -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AifTop"
>ifTop</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m a -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aroute"
>route</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; [(<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>, m a)] -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArouteLocal"
>routeLocal</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; [(<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>, m a)] -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetRequest"
>getRequest</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetResponse"
>getResponse</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AputRequest"
>putRequest</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AputResponse"
>putResponse</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AmodifyRequest"
>modifyRequest</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
>) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AmodifyResponse"
>modifyResponse</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
>) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AlocalRequest"
>localRequest</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
>) -&gt; m a -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwithRequest"
>withRequest</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; m a) -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwithResponse"
>withResponse</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; m a) -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AlogError"
>logError</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArunRequestBody"
>runRequestBody</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetRequestBody"
>getRequestBody</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AtransformRequestBody"
>transformRequestBody</A
> :: (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a) -&gt; <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ARequest"
>Request</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3AResponse"
>Response</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>type</SPAN
> <A HREF="#t%3AHeaders"
>Headers</A
> = <A HREF="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t%3AMap"
>Map</A
> <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
>  <A HREF="#t%3AHasHeaders"
>HasHeaders</A
> a  <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3AupdateHeaders"
>updateHeaders</A
> :: (<A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
> -&gt; <A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
>) -&gt; a -&gt; a</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aheaders"
>headers</A
> :: a -&gt; <A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>type</SPAN
> <A HREF="#t%3AParams"
>Params</A
> = <A HREF="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t%3AMap"
>Map</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3AMethod"
>Method</A
>  </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
>= <A HREF="#v%3AGET"
>GET</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3AHEAD"
>HEAD</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3APOST"
>POST</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3APUT"
>PUT</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ADELETE"
>DELETE</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ATRACE"
>TRACE</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3AOPTIONS"
>OPTIONS</A
></TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ACONNECT"
>CONNECT</A
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ACookie"
>Cookie</A
>  = <A HREF="#v%3ACookie"
>Cookie</A
> {<TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="recfield"
><A HREF="#v%3AcookieName"
>cookieName</A
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3AcookieValue"
>cookieValue</A
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3AcookieExpires"
>cookieExpires</A
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t%3AUTCTime"
>UTCTime</A
>)</TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3AcookieDomain"
>cookieDomain</A
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3AcookiePath"
>cookiePath</A
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
></TR
></TABLE
>}</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>type</SPAN
> <A HREF="#t%3AHttpVersion"
>HttpVersion</A
> = (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
>, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
>)</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AaddHeader"
>addHeader</A
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; a -&gt; a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetHeader"
>setHeader</A
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; a -&gt; a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetHeader"
>getHeader</A
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdeleteHeader"
>deleteHeader</A
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; a -&gt; a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AipHeaderFilter"
>ipHeaderFilter</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AipHeaderFilter%27"
>ipHeaderFilter'</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqServerName"
>rqServerName</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqServerPort"
>rqServerPort</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqRemoteAddr"
>rqRemoteAddr</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqRemotePort"
>rqRemotePort</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqLocalAddr"
>rqLocalAddr</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqLocalHostname"
>rqLocalHostname</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqIsSecure"
>rqIsSecure</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqContentLength"
>rqContentLength</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqMethod"
>rqMethod</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqVersion"
>rqVersion</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3AHttpVersion"
>HttpVersion</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqCookies"
>rqCookies</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; [<A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
>]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqPathInfo"
>rqPathInfo</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqContextPath"
>rqContextPath</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqURI"
>rqURI</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqQueryString"
>rqQueryString</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqParams"
>rqParams</A
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3AParams"
>Params</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqParam"
>rqParam</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetParam"
>getParam</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqModifyParams"
>rqModifyParams</A
> :: (<A HREF="Snap-Types.html#t%3AParams"
>Params</A
> -&gt; <A HREF="Snap-Types.html#t%3AParams"
>Params</A
>) -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArqSetParam"
>rqSetParam</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>] -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AemptyResponse"
>emptyResponse</A
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetResponseCode"
>setResponseCode</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetResponseStatus"
>setResponseStatus</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArspStatus"
>rspStatus</A
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArspStatusReason"
>rspStatusReason</A
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetContentType"
>setContentType</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AaddCookie"
>addCookie</A
> :: <A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetCookie"
>getCookie</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
>)</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetContentLength"
>setContentLength</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AclearContentLength"
>clearContentLength</A
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aredirect"
>redirect</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aredirect%27"
>redirect'</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetResponseBody"
>setResponseBody</A
> :: (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a) -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AmodifyResponseBody"
>modifyResponseBody</A
> :: (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a -&gt; <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a) -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AaddToOutput"
>addToOutput</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwriteBS"
>writeBS</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwriteLazyText"
>writeLazyText</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Lazy.html#t%3AText"
>Text</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwriteText"
>writeText</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwriteLBS"
>writeLBS</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsendFile"
>sendFile</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsendFilePartial"
>sendFilePartial</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
> -&gt; (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
>, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
>) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>type</SPAN
> <A HREF="#t%3AEnumerator"
>Enumerator</A
> a m b = <A HREF="Snap-Iteratee.html#t%3AStep"
>Step</A
> a m b -&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> a m b</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ASomeEnumerator"
>SomeEnumerator</A
>  = <A HREF="#v%3ASomeEnumerator"
>SomeEnumerator</A
> (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a)</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AformatHttpTime"
>formatHttpTime</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t%3ACTime"
>CTime</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AparseHttpTime"
>parseHttpTime</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t%3ACTime"
>CTime</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AurlEncode"
>urlEncode</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AurlDecode"
>urlDecode</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="1"
><A NAME="1"
>The Snap Monad
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:Snap"
><A NAME="t%3ASnap"
></A
></A
><B
>Snap</B
> a </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#Snap"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Snap')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Snap" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonad"
>Monad</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AFunctor"
>Functor</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t%3ATypeable1"
>Typeable1</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonadPlus"
>MonadPlus</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AApplicative"
>Applicative</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AMonadCatchIO"
>MonadCatchIO</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AAlternative"
>Alternative</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html#t%3AMonadIO"
>MonadIO</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:runSnap"
><A NAME="v%3ArunSnap"
></A
></A
><B
>runSnap</B
> ::  <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> a -&gt; (<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
>) -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
>, <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
>)</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#runSnap"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Runs a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action in the 'Iteratee IO' monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>class</SPAN
> (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonad"
>Monad</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html#t%3AMonadIO"
>MonadIO</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AMonadCatchIO"
>MonadCatchIO</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonadPlus"
>MonadPlus</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AFunctor"
>Functor</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AApplicative"
>Applicative</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AAlternative"
>Alternative</A
> m) =&gt; <A NAME="t:MonadSnap"
><A NAME="t%3AMonadSnap"
></A
></A
><B
>MonadSnap</B
> m  <SPAN CLASS="keyword"
>where</SPAN
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#MonadSnap"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
><TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> is the <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonad"
>Monad</A
></TT
> that user web handlers run in. <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> gives you:
</P
><P
>1. stateful access to fetch or modify an HTTP <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
>
</P
><P
>2. stateful access to fetch or modify an HTTP <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>
</P
><P
>3. failure / <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t%3AAlternative"
>Alternative</A
></TT
> / <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t%3AMonadPlus"
>MonadPlus</A
></TT
> semantics: a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> handler can
   choose not to handle a given request, using <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v%3Aempty"
>empty</A
></TT
> or its synonym <TT
><A HREF="Snap-Types.html#v%3Apass"
>pass</A
></TT
>,
   and you can try alternative handlers with the <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v%3A%3C%7C%3E"
>&lt;|&gt;</A
></TT
> operator:
</P
><PRE
> a :: Snap String
 a = pass

 b :: Snap String
 b = return &quot;foo&quot;

 c :: Snap String
 c = a &lt;|&gt; b             -- try running a, if it fails then try b
</PRE
><P
>4. convenience functions (<TT
><A HREF="Snap-Types.html#v%3AwriteBS"
>writeBS</A
></TT
>, <TT
><A HREF="Snap-Types.html#v%3AwriteLBS"
>writeLBS</A
></TT
>, <TT
><A HREF="Snap-Types.html#v%3AwriteText"
>writeText</A
></TT
>, <TT
><A HREF="Snap-Types.html#v%3AwriteLazyText"
>writeLazyText</A
></TT
>,
   <TT
><A HREF="Snap-Types.html#v%3AaddToOutput"
>addToOutput</A
></TT
>) for writing output to the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>:
</P
><PRE
> a :: (forall a . Enumerator a) -&gt; Snap ()
 a someEnumerator = do
     writeBS &quot;I'm a strict bytestring&quot;
     writeLBS &quot;I'm a lazy bytestring&quot;
     addToOutput someEnumerator
</PRE
><P
>5. early termination: if you call <TT
><A HREF="Snap-Types.html#v%3AfinishWith"
>finishWith</A
></TT
>:
</P
><PRE
> a :: Snap ()
 a = do
   modifyResponse $ setResponseStatus 500 &quot;Internal Server Error&quot;
   writeBS &quot;500 error&quot;
   r &lt;- getResponse
   finishWith r
</PRE
><P
>then any subsequent processing will be skipped and supplied <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> value
   will be returned from <TT
><A HREF="Snap-Types.html#v%3ArunSnap"
>runSnap</A
></TT
> as-is.
</P
><P
>6. access to the <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
></TT
> monad through a <TT
><A HREF="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html#t%3AMonadIO"
>MonadIO</A
></TT
> instance:
</P
><PRE
> a :: Snap ()
 a = liftIO fireTheMissiles
</PRE
><P
>You may notice that most of the type signatures in this module contain a
<TT
>(MonadSnap m) =&gt; ...</TT
> typeclass constraint. <TT
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
></TT
> is a typeclass which,
in essence, says &quot;you can get back to the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad from here&quot;. Using
<TT
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
></TT
> you can extend the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad with additional functionality and
still have access to most of the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> functions without writing <TT
><A HREF="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#v%3Alift"
>lift</A
></TT
>
everywhere. Instances are already provided for most of the common monad
transformers (ReaderT, WriterT, <TT
><A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html#t%3AStateT"
>StateT</A
></TT
>, etc.).
</P
><P
><TT
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
></TT
> is a type class, analogous to <TT
><A HREF="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html#t%3AMonadIO"
>MonadIO</A
></TT
> for <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
></TT
>, that makes
 it easy to wrap <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> inside monad transformers.
</P
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
>Methods</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:liftSnap"
><A NAME="v%3AliftSnap"
></A
></A
><B
>liftSnap</B
> ::  <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> a -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#liftSnap"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:MonadSnap')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:MonadSnap" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-List.html#t%3AListT"
>ListT</A
> m)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Cont.html#t%3AContT"
>ContT</A
> c m)</TD
></TR
><TR
><TD CLASS="decl"
>(<A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error-Class.html#t%3AError"
>Error</A
> e) =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error.html#t%3AErrorT"
>ErrorT</A
> e m)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Reader.html#t%3AReaderT"
>ReaderT</A
> r m)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html#t%3AStateT"
>StateT</A
> s m)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Strict.html#t%3AStateT"
>StateT</A
> s m)</TD
></TR
><TR
><TD CLASS="decl"
>(<A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t%3AMonoid"
>Monoid</A
> w) =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Writer-Lazy.html#t%3AWriterT"
>WriterT</A
> w m)</TD
></TR
><TR
><TD CLASS="decl"
>(<A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t%3AMonoid"
>Monoid</A
> w) =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Writer-Strict.html#t%3AWriterT"
>WriterT</A
> w m)</TD
></TR
><TR
><TD CLASS="decl"
>(<A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t%3AMonoid"
>Monoid</A
> w) =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-RWS-Lazy.html#t%3ARWST"
>RWST</A
> r w s m)</TD
></TR
><TR
><TD CLASS="decl"
>(<A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t%3AMonoid"
>Monoid</A
> w) =&gt; <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> (<A HREF="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-RWS-Strict.html#t%3ARWST"
>RWST</A
> r w s m)</TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:NoHandlerException"
><A NAME="t%3ANoHandlerException"
></A
></A
><B
>NoHandlerException</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#NoHandlerException"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>This exception is thrown if the handler you supply to <TT
><A HREF="Snap-Types.html#v%3ArunSnap"
>runSnap</A
></TT
> fails.
</TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:NoHandlerException"
><A NAME="v%3ANoHandlerException"
></A
></A
><B
>NoHandlerException</B
></TD
><TD CLASS="rdoc"
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:NoHandlerException')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:NoHandlerException" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t%3AEq"
>Eq</A
> <A HREF="Snap-Types.html#t%3ANoHandlerException"
>NoHandlerException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Types.html#t%3ANoHandlerException"
>NoHandlerException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t%3ATypeable"
>Typeable</A
> <A HREF="Snap-Types.html#t%3ANoHandlerException"
>NoHandlerException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AException"
>Exception</A
> <A HREF="Snap-Types.html#t%3ANoHandlerException"
>NoHandlerException</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="2"
><A NAME="2"
>Functions for control flow and early termination
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:bracketSnap"
><A NAME="v%3AbracketSnap"
></A
></A
><B
>bracketSnap</B
> ::  <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a -&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> b) -&gt; (a -&gt; <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> c) -&gt; <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> c</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#bracketSnap"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>This function brackets a Snap action in resource acquisition and
 release. This is provided because MonadCatchIO's <TT
><A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#v%3Abracket"
>bracket</A
></TT
> function
 doesn't work properly in the case of a short-circuit return from
 the action being bracketed.
</P
><P
>In order to prevent confusion regarding the effects of the
 aquisition and release actions on the Snap state, this function
 doesn't accept Snap actions for the acquire or release actions.
</P
><P
>This function will run the release action in all cases where the
 acquire action succeeded.  This includes the following behaviors
 from the bracketed Snap action.
</P
><P
>1. Normal completion
</P
><P
>2. Short-circuit completion, either from calling <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v%3Afail"
>fail</A
></TT
> or <TT
><A HREF="Snap-Types.html#v%3AfinishWith"
>finishWith</A
></TT
>
</P
><P
>3. An exception being thrown.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:finishWith"
><A NAME="v%3AfinishWith"
></A
></A
><B
>finishWith</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#finishWith"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Short-circuits a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action early, storing the given
 <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> value in its state.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:pass"
><A NAME="v%3Apass"
></A
></A
><B
>pass</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#pass"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Fails out of a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action.  This is used to indicate
 that you choose not to handle the given request within the given
 handler.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="3"
><A NAME="3"
>Routing
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:method"
><A NAME="v%3Amethod"
></A
></A
><B
>method</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
> -&gt; m a -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#method"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Runs a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action only if the request's HTTP method matches
 the given method.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:path"
><A NAME="v%3Apath"
></A
></A
><B
>path</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#path"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
>=&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>path to match against
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m a</TD
><TD CLASS="rdoc"
>handler to run
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m a</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Runs a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action only for requests where <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> is exactly
 equal to the given string. If the path matches, locally sets <TT
><A HREF="Snap-Types.html#v%3ArqContextPath"
>rqContextPath</A
></TT
>
 to the old value of <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
>, sets <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
>=&quot;&quot;, and runs the given
 handler.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:dir"
><A NAME="v%3Adir"
></A
></A
><B
>dir</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#dir"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
>=&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>path component to match
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m a</TD
><TD CLASS="rdoc"
>handler to run
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m a</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
><P
>Runs a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action only when the <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> of the request
 starts with the given path. For example,
</P
><PRE
> dir &quot;foo&quot; handler
</PRE
><P
>Will fail if <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> is not &quot;<TT
>/foo</TT
>&quot; or &quot;<TT
>/foo/...</TT
>&quot;, and will
 add <TT
>&quot;foo/&quot;</TT
> to the handler's local <TT
><A HREF="Snap-Types.html#v%3ArqContextPath"
>rqContextPath</A
></TT
>.
</P
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:ifTop"
><A NAME="v%3AifTop"
></A
></A
><B
>ifTop</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m a -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#ifTop"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Runs a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad action only when <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> is empty.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:route"
><A NAME="v%3Aroute"
></A
></A
><B
>route</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; [(<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>, m a)] -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Routing.html#route"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>A web handler which, given a mapping from URL entry points to web
 handlers, efficiently routes requests to the correct handler.
</P
><P
>The URL entry points are given as relative paths, for example:
</P
><PRE
> route [ (&quot;foo/bar/quux&quot;, fooBarQuux) ]
</PRE
><P
>If the URI of the incoming request is
</P
><PRE
> /foo/bar/quux
</PRE
><P
>or
</P
><PRE
> /foo/bar/quux/...anything...
</PRE
><P
>then the request will be routed to &quot;<TT
>fooBarQuux</TT
>&quot;, with <TT
><A HREF="Snap-Types.html#v%3ArqContextPath"
>rqContextPath</A
></TT
>
 set to &quot;<TT
>/foo/bar/quux/</TT
>&quot; and <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> set to
 &quot;<TT
>...anything...</TT
>&quot;.
</P
><P
>A path component within an URL entry point beginning with a colon (&quot;<TT
>:</TT
>&quot;)
 is treated as a <EM
>variable capture</EM
>; the corresponding path component within
 the request URI will be entered into the <TT
><A HREF="Snap-Types.html#v%3ArqParams"
>rqParams</A
></TT
> parameters mapping with
 the given name. For instance, if the routes were:
</P
><PRE
> route [ (&quot;foo/:bar/baz&quot;, fooBazHandler) ]
</PRE
><P
>Then a request for &quot;<TT
>/foo/saskatchewan/baz</TT
>&quot; would be routed to
 <TT
>fooBazHandler</TT
> with a mapping for:
</P
><PRE
> &quot;bar&quot; =&gt; &quot;saskatchewan&quot;
</PRE
><P
>in its parameters table.
</P
><P
>Longer paths are matched first, and specific routes are matched before
 captures. That is, if given routes:
</P
><PRE
> [ (&quot;a&quot;, h1), (&quot;a/b&quot;, h2), (&quot;a/:x&quot;, h3) ]
</PRE
><P
>a request for &quot;<TT
>/a/b</TT
>&quot; will go to <TT
>h2</TT
>, &quot;<TT
>/a/s</TT
>&quot; for any <EM
>s</EM
> will go
 to <TT
>h3</TT
>, and &quot;<TT
>/a</TT
>&quot; will go to <TT
>h1</TT
>.
</P
><P
>The following example matches &quot;<TT
>/article</TT
>&quot; to an article index,
 &quot;<TT
>/login</TT
>&quot; to a login, and &quot;<TT
>/article/...</TT
>&quot; to an article renderer.
</P
><PRE
> route [ (&quot;article&quot;,     renderIndex)
       , (&quot;article/:id&quot;, renderArticle)
       , (&quot;login&quot;,       method POST doLogin) ]
</PRE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:routeLocal"
><A NAME="v%3ArouteLocal"
></A
></A
><B
>routeLocal</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; [(<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>, m a)] -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Routing.html#routeLocal"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>The <TT
><A HREF="Snap-Types.html#v%3ArouteLocal"
>routeLocal</A
></TT
> function is the same as <TT
>route'</TT
>, except it doesn't change
 the request's context path. This is useful if you want to route to a
 particular handler but you want that handler to receive the <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> as
 it is.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="4"
><A NAME="4"
>Access to state
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getRequest"
><A NAME="v%3AgetRequest"
></A
></A
><B
>getRequest</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#getRequest"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Grabs the <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> object out of the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getResponse"
><A NAME="v%3AgetResponse"
></A
></A
><B
>getResponse</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#getResponse"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Grabs the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> object out of the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:putRequest"
><A NAME="v%3AputRequest"
></A
></A
><B
>putRequest</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#putRequest"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Puts a new <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> object into the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:putResponse"
><A NAME="v%3AputResponse"
></A
></A
><B
>putResponse</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#putResponse"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Puts a new <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> object into the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:modifyRequest"
><A NAME="v%3AmodifyRequest"
></A
></A
><B
>modifyRequest</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
>) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#modifyRequest"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Modifies the <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> object stored in a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:modifyResponse"
><A NAME="v%3AmodifyResponse"
></A
></A
><B
>modifyResponse</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
>) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#modifyResponse"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Modifes the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> object stored in a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:localRequest"
><A NAME="v%3AlocalRequest"
></A
></A
><B
>localRequest</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
>) -&gt; m a -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#localRequest"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Runs a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> action with a locally-modified <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> state
 object. The <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> object in the Snap monad state after the call
 to localRequest will be unchanged.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:withRequest"
><A NAME="v%3AwithRequest"
></A
></A
><B
>withRequest</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; m a) -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#withRequest"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Fetches the <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> from state and hands it to the given action.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:withResponse"
><A NAME="v%3AwithResponse"
></A
></A
><B
>withResponse</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; (<A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; m a) -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#withResponse"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Fetches the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> from state and hands it to the given action.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="5"
><A NAME="5"
>Logging
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:logError"
><A NAME="v%3AlogError"
></A
></A
><B
>logError</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#logError"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Log an error message in the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="6"
><A NAME="6"
>Grabbing/transforming request bodies
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:runRequestBody"
><A NAME="v%3ArunRequestBody"
></A
></A
><B
>runRequestBody</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a -&gt; m a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#runRequestBody"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Sends the request body through an iteratee (data consumer) and
 returns the result.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getRequestBody"
><A NAME="v%3AgetRequestBody"
></A
></A
><B
>getRequestBody</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#getRequestBody"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the request body as a bytestring.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:transformRequestBody"
><A NAME="v%3AtransformRequestBody"
></A
></A
><B
>transformRequestBody</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#transformRequestBody"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a</TD
><TD CLASS="rdoc"
>the output <TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
> is passed to this
 <TT
><A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
></TT
>, and then the resulting <TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
> is
 fed the request body stream. Your <TT
><A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
></TT
> is
 responsible for transforming the input.
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
> <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
><P
>Normally Snap is careful to ensure that the request body is fully consumed
 after your web handler runs, but before the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> enumerator is
 streamed out the socket. If you want to transform the request body into some
 output in O(1) space, you should use this function.
</P
><P
>Note that upon calling this function, response processing finishes early as
 if you called <TT
><A HREF="Snap-Types.html#v%3AfinishWith"
>finishWith</A
></TT
>. Make sure you set any content types, headers,
 cookies, etc. before you call this function.
</P
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="7"
><A NAME="7"
>HTTP Datatypes and Functions
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
>HTTP-related datatypes: <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
>, <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>, <TT
><A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
></TT
>, etc.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:Request"
><A NAME="t%3ARequest"
></A
></A
><B
>Request</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#Request"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>Contains all of the information about an incoming HTTP request.
</TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Request')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Request" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:Response"
><A NAME="t%3AResponse"
></A
></A
><B
>Response</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#Response"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>Represents an HTTP response.
</TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Response')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Response" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>type</SPAN
> <A NAME="t:Headers"
><A NAME="t%3AHeaders"
></A
></A
><B
>Headers</B
> = <A HREF="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t%3AMap"
>Map</A
> <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#Headers"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>A type alias for a case-insensitive key-value mapping.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>class</SPAN
>  <A NAME="t:HasHeaders"
><A NAME="t%3AHasHeaders"
></A
></A
><B
>HasHeaders</B
> a  <SPAN CLASS="keyword"
>where</SPAN
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#HasHeaders"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>A typeclass for datatypes which contain HTTP headers.
</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
>Methods</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:updateHeaders"
><A NAME="v%3AupdateHeaders"
></A
></A
><B
>updateHeaders</B
> :: (<A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
> -&gt; <A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
>) -&gt; a -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#updateHeaders"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Modify the datatype's headers.
</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:headers"
><A NAME="v%3Aheaders"
></A
></A
><B
>headers</B
> :: a -&gt; <A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#headers"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Retrieve the headers from a datatype that has headers.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:HasHeaders')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:HasHeaders" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> <A HREF="Snap-Types.html#t%3AHeaders"
>Headers</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>type</SPAN
> <A NAME="t:Params"
><A NAME="t%3AParams"
></A
></A
><B
>Params</B
> = <A HREF="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t%3AMap"
>Map</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#Params"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>A type alias for the HTTP parameters mapping. Each parameter
 key maps to a list of ByteString values; if a parameter is specified
 multiple times (e.g.: &quot;<TT
>GET /foo?param=bar1&amp;param=bar2</TT
>&quot;), looking up
 &quot;<TT
>param</TT
>&quot; in the mapping will give you <TT
>[&quot;bar1&quot;, &quot;bar2&quot;]</TT
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:Method"
><A NAME="t%3AMethod"
></A
></A
><B
>Method</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#Method"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>Enumerates the HTTP method values (see
 <A HREF="http://tools.ietf.org/html/rfc2068.html#section-5.1.1"
>http://tools.ietf.org/html/rfc2068.html#section-5.1.1</A
>).
</TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:GET"
><A NAME="v%3AGET"
></A
></A
><B
>GET</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:HEAD"
><A NAME="v%3AHEAD"
></A
></A
><B
>HEAD</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:POST"
><A NAME="v%3APOST"
></A
></A
><B
>POST</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:PUT"
><A NAME="v%3APUT"
></A
></A
><B
>PUT</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:DELETE"
><A NAME="v%3ADELETE"
></A
></A
><B
>DELETE</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:TRACE"
><A NAME="v%3ATRACE"
></A
></A
><B
>TRACE</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:OPTIONS"
><A NAME="v%3AOPTIONS"
></A
></A
><B
>OPTIONS</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:CONNECT"
><A NAME="v%3ACONNECT"
></A
></A
><B
>CONNECT</B
></TD
><TD CLASS="rdoc"
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Method')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Method" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t%3AEq"
>Eq</A
> <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t%3ARead"
>Read</A
> <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:Cookie"
><A NAME="t%3ACookie"
></A
></A
><B
>Cookie</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#Cookie"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>A datatype representing an HTTP cookie.
</TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="5" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:Cookie"
><A NAME="v%3ACookie"
></A
></A
><B
>Cookie</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="body" COLSPAN="2"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:cookieName"
><A NAME="v%3AcookieName"
></A
></A
><B
>cookieName</B
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>The name of the cookie.
</TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:cookieValue"
><A NAME="v%3AcookieValue"
></A
></A
><B
>cookieValue</B
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>The cookie's string value.
</TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:cookieExpires"
><A NAME="v%3AcookieExpires"
></A
></A
><B
>cookieExpires</B
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t%3AUTCTime"
>UTCTime</A
>)</TD
><TD CLASS="rdoc"
>The cookie's expiration value, if it has one.
</TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:cookieDomain"
><A NAME="v%3AcookieDomain"
></A
></A
><B
>cookieDomain</B
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
><TD CLASS="rdoc"
>The cookie's &quot;domain&quot; value, if it has one.
</TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:cookiePath"
><A NAME="v%3AcookiePath"
></A
></A
><B
>cookiePath</B
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
><TD CLASS="rdoc"
>The cookie path.
</TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Cookie')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Cookie" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t%3AEq"
>Eq</A
> <A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>type</SPAN
> <A NAME="t:HttpVersion"
><A NAME="t%3AHttpVersion"
></A
></A
><B
>HttpVersion</B
> = (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
>, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
>)</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#HttpVersion"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="8"
><A NAME="8"
>Headers
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:addHeader"
><A NAME="v%3AaddHeader"
></A
></A
><B
>addHeader</B
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; a -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#addHeader"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Adds a header key-value-pair to the <TT
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
></TT
> datatype. If a header with
 the same name already exists, the new value is appended to the headers list.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setHeader"
><A NAME="v%3AsetHeader"
></A
></A
><B
>setHeader</B
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; a -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#setHeader"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Sets a header key-value-pair in a <TT
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
></TT
> datatype. If a header with
 the same name already exists, it is overwritten with the new value.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getHeader"
><A NAME="v%3AgetHeader"
></A
></A
><B
>getHeader</B
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#getHeader"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Gets a header value out of a <TT
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
></TT
> datatype. If many headers came
 in with the same name, they will be catenated together.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:deleteHeader"
><A NAME="v%3AdeleteHeader"
></A
></A
><B
>deleteHeader</B
> :: <A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
> a =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; a -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#deleteHeader"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Clears a header value from a <TT
><A HREF="Snap-Types.html#t%3AHasHeaders"
>HasHeaders</A
></TT
> datatype.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:ipHeaderFilter"
><A NAME="v%3AipHeaderFilter"
></A
></A
><B
>ipHeaderFilter</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#ipHeaderFilter"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Modifies the <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> in the state to set the <TT
><A HREF="Snap-Types.html#v%3ArqRemoteAddr"
>rqRemoteAddr</A
></TT
>
 field to the value in the X-Forwarded-For header. If the header is
 not present, this action has no effect.
</P
><P
>This action should be used only when working behind a reverse http
 proxy that sets the X-Forwarded-For header. This is the only way to
 ensure the value in the X-Forwarded-For header can be trusted.
</P
><P
>This is provided as a filter so actions that require the remote
 address can get it in a uniform manner. It has specifically limited
 functionality to ensure that its transformation can be trusted,
 when used correctly.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:ipHeaderFilter'"
><A NAME="v%3AipHeaderFilter%27"
></A
></A
><B
>ipHeaderFilter'</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Data-CIByteString.html#t%3ACIByteString"
>CIByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#ipHeaderFilter%27"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Modifies the <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> in the state to set the <TT
><A HREF="Snap-Types.html#v%3ArqRemoteAddr"
>rqRemoteAddr</A
></TT
>
 field to the value from the header specified.  If the header
 specified is not present, this action has no effect.
</P
><P
>This action should be used only when working behind a reverse http
 proxy that sets the header being looked at. This is the only way to
 ensure the value in the header can be trusted.
</P
><P
>This is provided as a filter so actions that require the remote
 address can get it in a uniform manner. It has specifically limited
 functionality to ensure that its transformation can be trusted,
 when used correctly.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="9"
><A NAME="9"
>Requests
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqServerName"
><A NAME="v%3ArqServerName"
></A
></A
><B
>rqServerName</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqServerName"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>The server name of the request, as it came in from the request's
 <TT
>Host:</TT
> header.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqServerPort"
><A NAME="v%3ArqServerPort"
></A
></A
><B
>rqServerPort</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqServerPort"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the port number the HTTP server is listening on.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqRemoteAddr"
><A NAME="v%3ArqRemoteAddr"
></A
></A
><B
>rqRemoteAddr</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqRemoteAddr"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>The remote IP address.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqRemotePort"
><A NAME="v%3ArqRemotePort"
></A
></A
><B
>rqRemotePort</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqRemotePort"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>The remote TCP port number.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqLocalAddr"
><A NAME="v%3ArqLocalAddr"
></A
></A
><B
>rqLocalAddr</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqLocalAddr"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>The local IP address for this request.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqLocalHostname"
><A NAME="v%3ArqLocalHostname"
></A
></A
><B
>rqLocalHostname</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqLocalHostname"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the HTTP server's idea of its local hostname.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqIsSecure"
><A NAME="v%3ArqIsSecure"
></A
></A
><B
>rqIsSecure</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqIsSecure"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns <TT
>True</TT
> if this is an <TT
>HTTPS</TT
> session (currently always
 <TT
>False</TT
>).
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqContentLength"
><A NAME="v%3ArqContentLength"
></A
></A
><B
>rqContentLength</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqContentLength"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the <TT
>Content-Length</TT
> of the HTTP request body.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqMethod"
><A NAME="v%3ArqMethod"
></A
></A
><B
>rqMethod</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3AMethod"
>Method</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqMethod"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the HTTP request method.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqVersion"
><A NAME="v%3ArqVersion"
></A
></A
><B
>rqVersion</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3AHttpVersion"
>HttpVersion</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqVersion"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the HTTP version used by the client.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqCookies"
><A NAME="v%3ArqCookies"
></A
></A
><B
>rqCookies</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; [<A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
>]</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqCookies"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns a list of the cookies that came in from the HTTP request
 headers.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqPathInfo"
><A NAME="v%3ArqPathInfo"
></A
></A
><B
>rqPathInfo</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqPathInfo"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Handlers can (<EM
>will be; --ed</EM
>) be hung on a <TT
>URI</TT
> &quot;entry point&quot;;
 this is called the &quot;context path&quot;. If a handler is hung on the
 context path <TT
>&quot;/foo/&quot;</TT
>, and you request <TT
>&quot;/foo/bar&quot;</TT
>, the value
 of <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> will be <TT
>&quot;bar&quot;</TT
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqContextPath"
><A NAME="v%3ArqContextPath"
></A
></A
><B
>rqContextPath</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqContextPath"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>The &quot;context path&quot; of the request; catenating <TT
><A HREF="Snap-Types.html#v%3ArqContextPath"
>rqContextPath</A
></TT
>, and
 <TT
><A HREF="Snap-Types.html#v%3ArqPathInfo"
>rqPathInfo</A
></TT
> should get you back to the original <TT
><A HREF="Snap-Types.html#v%3ArqURI"
>rqURI</A
></TT
>. The
 <TT
><A HREF="Snap-Types.html#v%3ArqContextPath"
>rqContextPath</A
></TT
> always begins and ends with a slash (<TT
>&quot;/&quot;</TT
>)
 character, and represents the path (relative to your
 component/snaplet) you took to get to your handler.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqURI"
><A NAME="v%3ArqURI"
></A
></A
><B
>rqURI</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqURI"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the <TT
>URI</TT
> requested by the client.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqQueryString"
><A NAME="v%3ArqQueryString"
></A
></A
><B
>rqQueryString</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqQueryString"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the HTTP query string for this <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqParams"
><A NAME="v%3ArqParams"
></A
></A
><B
>rqParams</B
> :: <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3AParams"
>Params</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqParams"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the <TT
><A HREF="Snap-Types.html#t%3AParams"
>Params</A
></TT
> mapping for this <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
>. &quot;Parameters&quot; are
 automatically decoded from the query string and <TT
>POST</TT
> body and
 entered into this mapping.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqParam"
><A NAME="v%3ArqParam"
></A
></A
><B
>rqParam</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqParam"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>parameter name to look up
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
><TD CLASS="rdoc"
>HTTP request
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Looks up the value(s) for the given named parameter. Parameters initially
 come from the request's query string and any decoded POST body (if the
 request's <TT
>Content-Type</TT
> is <TT
>application/x-www-form-urlencoded</TT
>). Parameter
 values can be modified within handlers using <A HREF="rqModifyParams.html"
>rqModifyParams</A
>.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getParam"
><A NAME="v%3AgetParam"
></A
></A
><B
>getParam</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#getParam"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
>=&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>parameter name to look up
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
><P
>See <TT
><A HREF="Snap-Types.html#v%3ArqParam"
>rqParam</A
></TT
>. Looks up a value for the given named parameter in the
 <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
>. If more than one value was entered for the given parameter name,
 <TT
><A HREF="Snap-Types.html#v%3AgetParam"
>getParam</A
></TT
> gloms the values together with:
</P
><PRE
>    <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v%3Aintercalate"
>intercalate</A
></TT
> &quot; &quot;</PRE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqModifyParams"
><A NAME="v%3ArqModifyParams"
></A
></A
><B
>rqModifyParams</B
> :: (<A HREF="Snap-Types.html#t%3AParams"
>Params</A
> -&gt; <A HREF="Snap-Types.html#t%3AParams"
>Params</A
>) -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
> -&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqModifyParams"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Modifies the parameters mapping (which is a <TT
>Map ByteString ByteString</TT
>) in
 a <TT
><A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TT
> using the given function.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rqSetParam"
><A NAME="v%3ArqSetParam"
></A
></A
><B
>rqSetParam</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rqSetParam"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>parameter name
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; [<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>]</TD
><TD CLASS="rdoc"
>parameter values
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
><TD CLASS="rdoc"
>request
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3ARequest"
>Request</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Writes a key-value pair to the parameters mapping within the given request.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="10"
><A NAME="10"
>Responses
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:emptyResponse"
><A NAME="v%3AemptyResponse"
></A
></A
><B
>emptyResponse</B
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#emptyResponse"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>An empty <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setResponseCode"
><A NAME="v%3AsetResponseCode"
></A
></A
><B
>setResponseCode</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#setResponseCode"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="rdoc"
>HTTP response integer code
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
>Response to be modified
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Sets the HTTP response code.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setResponseStatus"
><A NAME="v%3AsetResponseStatus"
></A
></A
><B
>setResponseStatus</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#setResponseStatus"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="rdoc"
>HTTP response integer code
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
>HTTP response explanation
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
>Response to be modified
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Sets the HTTP response status. Note: normally you would use
 <TT
><A HREF="Snap-Types.html#v%3AsetResponseCode"
>setResponseCode</A
></TT
> unless you needed a custom response explanation.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rspStatus"
><A NAME="v%3ArspStatus"
></A
></A
><B
>rspStatus</B
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rspStatus"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the HTTP status code.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:rspStatusReason"
><A NAME="v%3ArspStatusReason"
></A
></A
><B
>rspStatusReason</B
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#rspStatusReason"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Returns the HTTP status explanation string.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setContentType"
><A NAME="v%3AsetContentType"
></A
></A
><B
>setContentType</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#setContentType"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Sets the <TT
>Content-Type</TT
> in the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> headers.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:addCookie"
><A NAME="v%3AaddCookie"
></A
></A
><B
>addCookie</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#addCookie"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
></TD
><TD CLASS="rdoc"
>cookie value
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
>response to modify
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Adds an HTTP <TT
><A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
></TT
> to the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> headers.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getCookie"
><A NAME="v%3AgetCookie"
></A
></A
><B
>getCookie</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
>)</TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#getCookie"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Gets the HTTP <TT
><A HREF="Snap-Types.html#t%3ACookie"
>Cookie</A
></TT
> with the specified name.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setContentLength"
><A NAME="v%3AsetContentLength"
></A
></A
><B
>setContentLength</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#setContentLength"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>A note here: if you want to set the <TT
>Content-Length</TT
> for the response,
 Snap forces you to do it with this function rather than by setting it in the
 headers; the <TT
>Content-Length</TT
> in the headers will be ignored.
</P
><P
>The reason for this is that Snap needs to look up the value of
 <TT
>Content-Length</TT
> for each request, and looking the string value up in the
 headers and parsing the number out of the text will be too expensive.
</P
><P
>If you don't set a content length in your response, HTTP keep-alive will be
 disabled for HTTP/1.0 clients, forcing a <TT
>Connection: close</TT
>. For HTTP/1.1
 clients, Snap will switch to the chunked transfer encoding if
 <TT
>Content-Length</TT
> is not specified.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:clearContentLength"
><A NAME="v%3AclearContentLength"
></A
></A
><B
>clearContentLength</B
> :: <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#clearContentLength"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Removes any <TT
>Content-Length</TT
> set in the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:redirect"
><A NAME="v%3Aredirect"
></A
></A
><B
>redirect</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#redirect"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Performs a redirect by setting the <TT
>Location</TT
> header to the given target
 URL/path and the status code to 302 in the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> object stored in a
 <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad. Note that the target URL is not validated in any way. Consider
 using 'redirect\'' instead, which allows you to choose the correct status
 code.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:redirect'"
><A NAME="v%3Aredirect%27"
></A
></A
><B
>redirect'</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#redirect%27"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Performs a redirect by setting the <TT
>Location</TT
> header to the given target
 URL/path and the status code (should be one of 301, 302, 303 or 307) in the
 <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> object stored in a <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad. Note that the target URL is not
 validated in any way.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section3"
><A NAME="11"
><A NAME="11"
>Response I/O
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setResponseBody"
><A NAME="v%3AsetResponseBody"
></A
></A
><B
>setResponseBody</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#setResponseBody"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a</TD
><TD CLASS="rdoc"
>new response body enumerator
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
>response to modify
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Sets an HTTP response body to the given <TT
><A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
></TT
> value.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:modifyResponseBody"
><A NAME="v%3AmodifyResponseBody"
></A
></A
><B
>modifyResponseBody</B
> :: (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a -&gt; <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a) -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
> -&gt; <A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#modifyResponseBody"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Modifies a response body.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:addToOutput"
><A NAME="v%3AaddToOutput"
></A
></A
><B
>addToOutput</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#addToOutput"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
>=&gt; <SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a</TD
><TD CLASS="rdoc"
>output to add
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
>Adds the output from the given enumerator to the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>
 stored in the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad state.
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:writeBS"
><A NAME="v%3AwriteBS"
></A
></A
><B
>writeBS</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#writeBS"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Adds the given strict <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TT
> to the body of the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> stored in
 the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad state.
</P
><P
>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TT
>,
 the exception won't actually be raised within the Snap handler.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:writeLazyText"
><A NAME="v%3AwriteLazyText"
></A
></A
><B
>writeLazyText</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Lazy.html#t%3AText"
>Text</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#writeLazyText"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Adds the given lazy <TT
><A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Lazy.html#t%3AText"
>Text</A
></TT
> to the body of the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> stored in the
 <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad state.
</P
><P
>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TT
>,
 the exception won't actually be raised within the Snap handler.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:writeText"
><A NAME="v%3AwriteText"
></A
></A
><B
>writeText</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#writeText"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Adds the given strict <TT
><A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TT
> to the body of the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> stored in the
 <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad state.
</P
><P
>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TT
>,
 the exception won't actually be raised within the Snap handler.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:writeLBS"
><A NAME="v%3AwriteLBS"
></A
></A
><B
>writeLBS</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t%3AByteString"
>ByteString</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#writeLBS"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Adds the given lazy <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t%3AByteString"
>ByteString</A
></TT
> to the body of the <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
> stored in
 the <TT
><A HREF="Snap-Types.html#t%3ASnap"
>Snap</A
></TT
> monad state.
</P
><P
>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <TT
><A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TT
>,
 the exception won't actually be raised within the Snap handler.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:sendFile"
><A NAME="v%3AsendFile"
></A
></A
><B
>sendFile</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
> -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#sendFile"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Sets the output to be the contents of the specified file.
</P
><P
>Calling <TT
><A HREF="Snap-Types.html#v%3AsendFile"
>sendFile</A
></TT
> will overwrite any output queued to be sent in the
 <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>. If the response body is not modified after the call to
 <TT
><A HREF="Snap-Types.html#v%3AsendFile"
>sendFile</A
></TT
>, Snap will use the efficient <TT
>sendfile()</TT
> system call on
 platforms that support it.
</P
><P
>If the response body is modified (using <TT
><A HREF="Snap-Types.html#v%3AmodifyResponseBody"
>modifyResponseBody</A
></TT
>), the file will
 be read using <TT
>mmap()</TT
>.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:sendFilePartial"
><A NAME="v%3AsendFilePartial"
></A
></A
><B
>sendFilePartial</B
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
> -&gt; (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
>, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
>) -&gt; m <A HREF="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t%3A%28%29"
>()</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Types.html#sendFilePartial"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Sets the output to be the contents of the specified file, within the given
 (start,end) range.
</P
><P
>Calling <TT
><A HREF="Snap-Types.html#v%3AsendFilePartial"
>sendFilePartial</A
></TT
> will overwrite any output queued to be sent in the
 <TT
><A HREF="Snap-Types.html#t%3AResponse"
>Response</A
></TT
>. If the response body is not modified after the call to
 <TT
><A HREF="Snap-Types.html#v%3AsendFilePartial"
>sendFilePartial</A
></TT
>, Snap will use the efficient <TT
>sendfile()</TT
> system call on
 platforms that support it.
</P
><P
>If the response body is modified (using <TT
><A HREF="Snap-Types.html#v%3AmodifyResponseBody"
>modifyResponseBody</A
></TT
>), the file will
 be read using <TT
>mmap()</TT
>.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="12"
><A NAME="12"
>Iteratee
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>type</SPAN
> <A NAME="t:Enumerator"
><A NAME="t%3AEnumerator"
></A
></A
><B
>Enumerator</B
> a m b = <A HREF="Snap-Iteratee.html#t%3AStep"
>Step</A
> a m b -&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> a m b</TD
><TD CLASS="declbut"
><A HREF="src/Data-Enumerator.html#Enumerator"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>While <TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
>s consume data, enumerators generate it. Since
 <TT
><TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
></TT
> is an alias for <TT
>m (<TT
><A HREF="Snap-Iteratee.html#t%3AStep"
>Step</A
></TT
> a m b)</TT
>, <TT
><A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
></TT
>s can
 be considered step transformers of type
 <TT
><TT
><A HREF="Snap-Iteratee.html#t%3AStep"
>Step</A
></TT
> a m b -&gt; m (<TT
><A HREF="Snap-Iteratee.html#t%3AStep"
>Step</A
></TT
> a m b)</TT
>.
</P
><P
><TT
><A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
></TT
>s typically read from an external source (parser, handle,
 random generator, etc). They feed chunks into an <TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
> until the
 source runs out of data (triggering <TT
><A HREF="Snap-Iteratee.html#v%3AEOF"
>EOF</A
></TT
>) or the iteratee finishes
 processing (<TT
><A HREF="Snap-Iteratee.html#v%3AYield"
>Yield</A
></TT
>s a value).
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:SomeEnumerator"
><A NAME="t%3ASomeEnumerator"
></A
></A
><B
>SomeEnumerator</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#SomeEnumerator"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>An existential wrapper for the <TT
><A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
></TT
> type
</TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:SomeEnumerator"
><A NAME="v%3ASomeEnumerator"
></A
></A
><B
>SomeEnumerator</B
> (<SPAN CLASS="keyword"
>forall</SPAN
> a.  <A HREF="Snap-Types.html#t%3AEnumerator"
>Enumerator</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a)</TD
><TD CLASS="rdoc"
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="13"
><A NAME="13"
>HTTP utilities
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:formatHttpTime"
><A NAME="v%3AformatHttpTime"
></A
></A
><B
>formatHttpTime</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t%3ACTime"
>CTime</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#formatHttpTime"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Converts a <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t%3ACTime"
>CTime</A
></TT
> into an HTTP timestamp.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:parseHttpTime"
><A NAME="v%3AparseHttpTime"
></A
></A
><B
>parseHttpTime</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t%3ACTime"
>CTime</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#parseHttpTime"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Converts an HTTP timestamp into a <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t%3ACTime"
>CTime</A
></TT
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:urlEncode"
><A NAME="v%3AurlEncode"
></A
></A
><B
>urlEncode</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#urlEncode"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>URL-escapes a string (see
 <A HREF="http://tools.ietf.org/html/rfc2396.html#section-2.4"
>http://tools.ietf.org/html/rfc2396.html#section-2.4</A
>)
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:urlDecode"
><A NAME="v%3AurlDecode"
></A
></A
><B
>urlDecode</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Internal-Http-Types.html#urlDecode"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Decodes an URL-escaped string (see
 <A HREF="http://tools.ietf.org/html/rfc2396.html#section-2.4"
>http://tools.ietf.org/html/rfc2396.html#section-2.4</A
>)
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="botbar"
>Produced by <A HREF="http://www.haskell.org/haddock/"
>Haddock</A
> version 2.6.1</TD
></TR
></TABLE
></BODY
></HTML
>
