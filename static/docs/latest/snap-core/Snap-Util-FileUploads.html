<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"
><TITLE
>Snap.Util.FileUploads</TITLE
><LINK HREF="haddock.css" REL="stylesheet" TYPE="text/css"
><SCRIPT SRC="haddock-util.js" TYPE="text/javascript"
></SCRIPT
><SCRIPT TYPE="text/javascript"
>window.onload = function () {setSynopsis("mini_Snap-Util-FileUploads.html")};</SCRIPT
></HEAD
><BODY
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topbar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><IMG SRC="haskell_icon.gif" WIDTH="16" HEIGHT="16" ALT=" "
></TD
><TD CLASS="title"
>snap-core-0.4.0: Snap: A Haskell Web Framework (Core)</TD
><TD CLASS="topbut"
><A HREF="src/Snap-Util-FileUploads.html"
>Source code</A
></TD
><TD CLASS="topbut"
><A HREF="index.html"
>Contents</A
></TD
><TD CLASS="topbut"
><A HREF="doc-index.html"
>Index</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="modulebar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><FONT SIZE="6"
>Snap.Util.FileUploads</FONT
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="section4"
><B
>Contents</B
></TD
></TR
><TR
><TD
><DL
><DT
><A HREF="#1"
>Functions
</A
></DT
><DT
><A HREF="#2"
>Uploaded parts
</A
></DT
><DD
><DL
><DT
><A HREF="#3"
>Policy
</A
></DT
><DD
><DL
><DT
><A HREF="#4"
>General upload policy
</A
></DT
><DT
><A HREF="#5"
>Per-file upload policy
</A
></DT
></DL
></DD
></DL
></DD
><DT
><A HREF="#6"
>Exceptions
</A
></DT
></DL
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Description</TD
></TR
><TR
><TD CLASS="doc"
><P
>This module contains primitives and helper functions for handling
 requests with <TT
>Content-type: multipart/form-data</TT
>, i.e. HTML forms and file
 uploads.
</P
><P
>Typically most users will want to use <TT
><A HREF="Snap-Util-FileUploads.html#v%3AhandleFileUploads"
>handleFileUploads</A
></TT
>, which writes
 uploaded files to a temporary directory before sending them on to a handler
 specified by the user.
</P
><P
>Users who wish to handle their file uploads differently can use the
 lower-level streaming <TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
> interface called <TT
><A HREF="Snap-Util-FileUploads.html#v%3AhandleMultipart"
>handleMultipart</A
></TT
>. That
 function takes uploaded files and streams them to an <TT
><A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
></TT
> consumer of
 the user's choosing.
</P
><P
>Using these functions requires making &quot;policy&quot; decisions which Snap can't
 really make for users, such as &quot;what's the largest PDF file a user is
 allowed to upload?&quot; and &quot;should we read form inputs into the parameters
 mapping?&quot;. Policy is specified on a &quot;global&quot; basis (using
 <TT
><A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TT
>), and on a per-file basis (using <TT
><A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TT
>, which
 allows you to reject or limit the size of certain uploaded
 <TT
>Content-type</TT
>s).
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Synopsis</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3AhandleFileUploads"
>handleFileUploads</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; (<A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
>) -&gt; ([(<A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
>, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t%3AEither"
>Either</A
> <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
>)] -&gt; m a) -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AhandleMultipart"
>handleMultipart</A
> :: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m =&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; (<A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
> -&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a) -&gt; m [a]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3APartInfo"
>PartInfo</A
>  = <A HREF="#v%3APartInfo"
>PartInfo</A
> {<TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="recfield"
><A HREF="#v%3ApartFieldName"
>partFieldName</A
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3ApartFileName"
>partFileName</A
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3ApartContentType"
>partContentType</A
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
></TR
></TABLE
>}</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3AUploadPolicy"
>UploadPolicy</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdefaultUploadPolicy"
>defaultUploadPolicy</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdoProcessFormInputs"
>doProcessFormInputs</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetProcessFormInputs"
>setProcessFormInputs</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetMaximumFormInputSize"
>getMaximumFormInputSize</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetMaximumFormInputSize"
>setMaximumFormInputSize</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetMinimumUploadRate"
>getMinimumUploadRate</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3ADouble"
>Double</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetMinimumUploadRate"
>setMinimumUploadRate</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3ADouble"
>Double</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetMinimumUploadSeconds"
>getMinimumUploadSeconds</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetMinimumUploadSeconds"
>setMinimumUploadSeconds</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetUploadTimeout"
>getUploadTimeout</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsetUploadTimeout"
>setUploadTimeout</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3APartUploadPolicy"
>PartUploadPolicy</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Adisallow"
>disallow</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AallowWithMaximumSize"
>allowWithMaximumSize</A
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3AFileUploadException"
>FileUploadException</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfileUploadExceptionReason"
>fileUploadExceptionReason</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3AFileUploadException"
>FileUploadException</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ABadPartException"
>BadPartException</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AbadPartExceptionReason"
>badPartExceptionReason</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3APolicyViolationException"
>PolicyViolationException</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ApolicyViolationExceptionReason"
>policyViolationExceptionReason</A
> :: <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="1"
><A NAME="1"
>Functions
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:handleFileUploads"
><A NAME="v%3AhandleFileUploads"
></A
></A
><B
>handleFileUploads</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#handleFileUploads"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
>=&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
></TD
><TD CLASS="rdoc"
>temporary directory
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="rdoc"
>general upload policy
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
><TD CLASS="rdoc"
>per-part upload policy
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; [(<A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
>, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t%3AEither"
>Either</A
> <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AFilePath"
>FilePath</A
>)] -&gt; m a</TD
><TD CLASS="rdoc"
>user handler (see function
 description)
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m a</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
><P
>Reads uploaded files into a temporary directory and calls a user handler
 to process them.
</P
><P
>Given a temporary directory, global and file-specific upload policies, and
 a user handler, this function consumes a request body uploaded with
 <TT
>Content-type: multipart/form-data</TT
>. Each file is read into the temporary
 directory, and then a list of the uploaded files is passed to the user
 handler. After the user handler runs (but before the <TT
><A HREF="Snap-Internal-Http-Types.html#t%3AResponse"
>Response</A
></TT
> body
 <TT
><A HREF="Snap-Iteratee.html#t%3AEnumerator"
>Enumerator</A
></TT
> is streamed to the client), the files are deleted from disk;
 so if you want to retain or use the uploaded files in the generated
 response, you would need to move or otherwise process them.
</P
><P
>The argument passed to the user handler is a list of:
</P
><PRE
> (PartInfo, Either PolicyViolationException FilePath)
</PRE
><P
>The first half of this tuple is a <TT
><A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
></TT
>, which contains the
 information the client browser sent about the given upload part (like
 filename, content-type, etc). The second half of this tuple is an <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t%3AEither"
>Either</A
></TT
>
 stipulating that either:
</P
><P
>1. the file was rejected on a policy basis because of the provided
    <TT
><A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TT
> handler
</P
><P
>2. the file was accepted and exists at the given path.
</P
><P
>If the request's <TT
>Content-type</TT
> was not &quot;<TT
>multipart/formdata</TT
>&quot;, this
 function skips processing using <TT
><A HREF="Snap-Types.html#v%3Apass"
>pass</A
></TT
>.
</P
><P
>If the client's upload rate passes below the configured minimum (see
 <TT
><A HREF="Snap-Util-FileUploads.html#v%3AsetMinimumUploadRate"
>setMinimumUploadRate</A
></TT
> and <TT
><A HREF="Snap-Util-FileUploads.html#v%3AsetMinimumUploadSeconds"
>setMinimumUploadSeconds</A
></TT
>), this function throws
 a <TT
><A HREF="Snap-Iteratee.html#t%3ARateTooSlowException"
>RateTooSlowException</A
></TT
>. This setting is there to protect the server
 against slowloris-style denial of service attacks.
</P
><P
>If the given <TT
><A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TT
> stipulates that you wish form inputs to be
 placed in the <TT
><A HREF="Snap-Internal-Http-Types.html#v%3ArqParams"
>rqParams</A
></TT
> parameter map (using <TT
><A HREF="Snap-Util-FileUploads.html#v%3AsetProcessFormInputs"
>setProcessFormInputs</A
></TT
>), and
 a form input exceeds the maximum allowable size, this function will throw a
 <TT
><A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
></TT
>.
</P
><P
>If an uploaded part contains MIME headers longer than a fixed internal
 threshold (currently 32KB), this function will throw a <TT
><A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
></TT
>.
</P
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:handleMultipart"
><A NAME="v%3AhandleMultipart"
></A
></A
><B
>handleMultipart</B
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#handleMultipart"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="arg"
>:: <A HREF="Snap-Types.html#t%3AMonadSnap"
>MonadSnap</A
> m</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
>=&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="rdoc"
>global upload policy
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; <A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
> -&gt; <A HREF="Snap-Iteratee.html#t%3AIteratee"
>Iteratee</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
> <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t%3AIO"
>IO</A
> a</TD
><TD CLASS="rdoc"
>part processor
</TD
></TR
><TR
><TD CLASS="arg"
>-&gt; m [a]</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="ndoc" COLSPAN="2"
><P
>Given an upload policy and a function to consume uploaded &quot;parts&quot;,
 consume a request body uploaded with <TT
>Content-type: multipart/form-data</TT
>.
 Normally most users will want to use <TT
><A HREF="Snap-Util-FileUploads.html#v%3AhandleFileUploads"
>handleFileUploads</A
></TT
> (which writes
 uploaded files to a temporary directory and passes their names to a given
 handler) rather than this function; the lower-level <TT
><A HREF="Snap-Util-FileUploads.html#v%3AhandleMultipart"
>handleMultipart</A
></TT
>
 function should be used if you want to stream uploaded files to your own
 iteratee function.
</P
><P
>If the request's <TT
>Content-type</TT
> was not &quot;<TT
>multipart/formdata</TT
>&quot;, this
 function skips processing using <TT
><A HREF="Snap-Types.html#v%3Apass"
>pass</A
></TT
>.
</P
><P
>If the client's upload rate passes below the configured minimum (see
 <TT
><A HREF="Snap-Util-FileUploads.html#v%3AsetMinimumUploadRate"
>setMinimumUploadRate</A
></TT
> and <TT
><A HREF="Snap-Util-FileUploads.html#v%3AsetMinimumUploadSeconds"
>setMinimumUploadSeconds</A
></TT
>), this function throws
 a <TT
><A HREF="Snap-Iteratee.html#t%3ARateTooSlowException"
>RateTooSlowException</A
></TT
>. This setting is there to protect the server
 against slowloris-style denial of service attacks.
</P
><P
>If the given <TT
><A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TT
> stipulates that you wish form inputs to be
 placed in the <TT
><A HREF="Snap-Internal-Http-Types.html#v%3ArqParams"
>rqParams</A
></TT
> parameter map (using <TT
><A HREF="Snap-Util-FileUploads.html#v%3AsetProcessFormInputs"
>setProcessFormInputs</A
></TT
>), and
 a form input exceeds the maximum allowable size, this function will throw a
 <TT
><A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
></TT
>.
</P
><P
>If an uploaded part contains MIME headers longer than a fixed internal
 threshold (currently 32KB), this function will throw a <TT
><A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
></TT
>.
</P
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="2"
><A NAME="2"
>Uploaded parts
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:PartInfo"
><A NAME="t%3APartInfo"
></A
></A
><B
>PartInfo</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#PartInfo"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><TT
><A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
></TT
> contains information about a &quot;part&quot; in a request uploaded
 with <TT
>Content-type: multipart/form-data</TT
>.
</TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="5" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:PartInfo"
><A NAME="v%3APartInfo"
></A
></A
><B
>PartInfo</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="body" COLSPAN="2"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v:partFieldName"
><A NAME="v%3ApartFieldName"
></A
></A
><B
>partFieldName</B
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:partFileName"
><A NAME="v%3ApartFileName"
></A
></A
><B
>partFileName</B
> :: !(<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t%3AMaybe"
>Maybe</A
> <A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
>)</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v:partContentType"
><A NAME="v%3ApartContentType"
></A
></A
><B
>partContentType</B
> :: !<A HREF="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t%3AByteString"
>ByteString</A
></TD
><TD CLASS="rdoc"
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:PartInfo')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:PartInfo" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Util-FileUploads.html#t%3APartInfo"
>PartInfo</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="3"
><A NAME="3"
>Policy
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section3"
><A NAME="4"
><A NAME="4"
>General upload policy
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:UploadPolicy"
><A NAME="t%3AUploadPolicy"
></A
></A
><B
>UploadPolicy</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#UploadPolicy"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
><TT
><A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TT
> controls overall policy decisions relating to
 <TT
>multipart/form-data</TT
> uploads, specifically:
</P
><UL
><LI
> whether to treat parts without filenames as form input (reading them into
   the <TT
><A HREF="Snap-Internal-Http-Types.html#v%3ArqParams"
>rqParams</A
></TT
> map)
</LI
><LI
> because form input is read into memory, the maximum size of a form input
   read in this manner, and the maximum number of form inputs
</LI
><LI
> the minimum upload rate a client must maintain before we kill the
   connection; if very low-bitrate uploads were allowed then a Snap server
   would be vulnerable to a trivial denial-of-service using a
   &quot;slowloris&quot;-type attack
</LI
><LI
> the minimum number of seconds which must elapse before we start killing
   uploads for having too low an upload rate.
</LI
><LI
> the amount of time we should wait before timing out the connection
   whenever we receive input from the client.
</LI
></UL
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:UploadPolicy')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:UploadPolicy" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t%3AEq"
>Eq</A
> <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:defaultUploadPolicy"
><A NAME="v%3AdefaultUploadPolicy"
></A
></A
><B
>defaultUploadPolicy</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#defaultUploadPolicy"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
><P
>A reasonable set of defaults for upload policy. The default policy is:
</P
><DL
><DT
><TT
>maximum form input size</TT
></DT
><DD
>                128kB
</DD
><DT
><TT
>maximum number of form inputs</TT
></DT
><DD
>          10
</DD
><DT
><TT
>minimum upload rate</TT
></DT
><DD
>                    1kB/s
</DD
><DT
><TT
>seconds before rate limiting kicks in</TT
></DT
><DD
>  10
</DD
><DT
><TT
>inactivity timeout</TT
></DT
><DD
>                     20 seconds
</DD
></DL
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:doProcessFormInputs"
><A NAME="v%3AdoProcessFormInputs"
></A
></A
><B
>doProcessFormInputs</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#doProcessFormInputs"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Does this upload policy stipulate that we want to treat parts without
 filenames as form input?
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setProcessFormInputs"
><A NAME="v%3AsetProcessFormInputs"
></A
></A
><B
>setProcessFormInputs</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#setProcessFormInputs"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Set the upload policy for treating parts without filenames as form input.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getMaximumFormInputSize"
><A NAME="v%3AgetMaximumFormInputSize"
></A
></A
><B
>getMaximumFormInputSize</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#getMaximumFormInputSize"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Get the maximum size of a form input which will be read into our
   <TT
><A HREF="Snap-Internal-Http-Types.html#v%3ArqParams"
>rqParams</A
></TT
> map.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setMaximumFormInputSize"
><A NAME="v%3AsetMaximumFormInputSize"
></A
></A
><B
>setMaximumFormInputSize</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#setMaximumFormInputSize"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Set the maximum size of a form input which will be read into our
   <TT
><A HREF="Snap-Internal-Http-Types.html#v%3ArqParams"
>rqParams</A
></TT
> map.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getMinimumUploadRate"
><A NAME="v%3AgetMinimumUploadRate"
></A
></A
><B
>getMinimumUploadRate</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3ADouble"
>Double</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#getMinimumUploadRate"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Get the minimum rate (in <EM
>bytes\</EM
>second/) a client must maintain before
   we kill the connection.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setMinimumUploadRate"
><A NAME="v%3AsetMinimumUploadRate"
></A
></A
><B
>setMinimumUploadRate</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3ADouble"
>Double</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#setMinimumUploadRate"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Set the minimum rate (in <EM
>bytes\</EM
>second/) a client must maintain before
   we kill the connection.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getMinimumUploadSeconds"
><A NAME="v%3AgetMinimumUploadSeconds"
></A
></A
><B
>getMinimumUploadSeconds</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#getMinimumUploadSeconds"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Get the amount of time which must elapse before we begin enforcing the
   upload rate minimum
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setMinimumUploadSeconds"
><A NAME="v%3AsetMinimumUploadSeconds"
></A
></A
><B
>setMinimumUploadSeconds</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#setMinimumUploadSeconds"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Set the amount of time which must elapse before we begin enforcing the
   upload rate minimum
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:getUploadTimeout"
><A NAME="v%3AgetUploadTimeout"
></A
></A
><B
>getUploadTimeout</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#getUploadTimeout"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Get the &quot;upload timeout&quot;. Whenever input is received from the client,
   the connection timeout is set this many seconds in the future.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:setUploadTimeout"
><A NAME="v%3AsetUploadTimeout"
></A
></A
><B
>setUploadTimeout</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt"
>Int</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#setUploadTimeout"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Set the upload timeout.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section3"
><A NAME="5"
><A NAME="5"
>Per-file upload policy
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:PartUploadPolicy"
><A NAME="t%3APartUploadPolicy"
></A
></A
><B
>PartUploadPolicy</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#PartUploadPolicy"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>Upload policy can be set on an &quot;general&quot; basis (using <TT
><A HREF="Snap-Util-FileUploads.html#t%3AUploadPolicy"
>UploadPolicy</A
></TT
>),
   but handlers can also make policy decisions on individual files/parts
   uploaded. For each part uploaded, handlers can decide:
</P
><UL
><LI
> whether to allow the file upload at all
</LI
><LI
> the maximum size of uploaded files, if allowed
</LI
></UL
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:PartUploadPolicy')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:PartUploadPolicy" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t%3AEq"
>Eq</A
> <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:disallow"
><A NAME="v%3Adisallow"
></A
></A
><B
>disallow</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#disallow"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Disallows the file to be uploaded.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:allowWithMaximumSize"
><A NAME="v%3AallowWithMaximumSize"
></A
></A
><B
>allowWithMaximumSize</B
> :: <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t%3AInt64"
>Int64</A
> -&gt; <A HREF="Snap-Util-FileUploads.html#t%3APartUploadPolicy"
>PartUploadPolicy</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#allowWithMaximumSize"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Allows the file to be uploaded, with maximum size <EM
>n</EM
>.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="6"
><A NAME="6"
>Exceptions
</A
></A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:FileUploadException"
><A NAME="t%3AFileUploadException"
></A
></A
><B
>FileUploadException</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#FileUploadException"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>All of the exceptions defined in this package inherit from
 <TT
><A HREF="Snap-Util-FileUploads.html#t%3AFileUploadException"
>FileUploadException</A
></TT
>, so if you write
</P
><PRE
> foo `catch` \(e :: FileUploadException) -&gt; ...
</PRE
><P
>you can catch a <TT
><A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
></TT
>, a <TT
><A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
></TT
>, etc.
</P
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:FileUploadException')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:FileUploadException" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Util-FileUploads.html#t%3AFileUploadException"
>FileUploadException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t%3ATypeable"
>Typeable</A
> <A HREF="Snap-Util-FileUploads.html#t%3AFileUploadException"
>FileUploadException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AException"
>Exception</A
> <A HREF="Snap-Util-FileUploads.html#t%3AFileUploadException"
>FileUploadException</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:fileUploadExceptionReason"
><A NAME="v%3AfileUploadExceptionReason"
></A
></A
><B
>fileUploadExceptionReason</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3AFileUploadException"
>FileUploadException</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#fileUploadExceptionReason"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:BadPartException"
><A NAME="t%3ABadPartException"
></A
></A
><B
>BadPartException</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#BadPartException"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:BadPartException')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:BadPartException" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t%3ATypeable"
>Typeable</A
> <A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AException"
>Exception</A
> <A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:badPartExceptionReason"
><A NAME="v%3AbadPartExceptionReason"
></A
></A
><B
>badPartExceptionReason</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3ABadPartException"
>BadPartException</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#badPartExceptionReason"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:PolicyViolationException"
><A NAME="t%3APolicyViolationException"
></A
></A
><B
>PolicyViolationException</B
>  </TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#PolicyViolationException"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:PolicyViolationException')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:PolicyViolationException" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t%3AShow"
>Show</A
> <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t%3ATypeable"
>Typeable</A
> <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t%3AException"
>Exception</A
> <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:policyViolationExceptionReason"
><A NAME="v%3ApolicyViolationExceptionReason"
></A
></A
><B
>policyViolationExceptionReason</B
> :: <A HREF="Snap-Util-FileUploads.html#t%3APolicyViolationException"
>PolicyViolationException</A
> -&gt; <A HREF="http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#t%3AText"
>Text</A
></TD
><TD CLASS="declbut"
><A HREF="src/Snap-Util-FileUploads.html#policyViolationExceptionReason"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="botbar"
>Produced by <A HREF="http://www.haskell.org/haddock/"
>Haddock</A
> version 2.6.1</TD
></TR
></TABLE
></BODY
></HTML
>
