<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns              #-}
<span class="lineno">    2 </span>{-# LANGUAGE DeriveDataTypeable        #-}
<span class="lineno">    3 </span>{-# LANGUAGE ExistentialQuantification #-}
<span class="lineno">    4 </span>{-# LANGUAGE OverloadedStrings         #-}
<span class="lineno">    5 </span>{-# LANGUAGE ScopedTypeVariables       #-}
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>------------------------------------------------------------------------------
<span class="lineno">    8 </span>-- | This module contains primitives and helper functions for handling
<span class="lineno">    9 </span>-- requests with @Content-type: multipart/form-data@, i.e. HTML forms and file
<span class="lineno">   10 </span>-- uploads.
<span class="lineno">   11 </span>--
<span class="lineno">   12 </span>-- Typically most users will want to use 'handleFileUploads', which writes
<span class="lineno">   13 </span>-- uploaded files to a temporary directory before sending them on to a handler
<span class="lineno">   14 </span>-- specified by the user.
<span class="lineno">   15 </span>--
<span class="lineno">   16 </span>-- Users who wish to handle their file uploads differently can use the
<span class="lineno">   17 </span>-- lower-level streaming 'Iteratee' interface called 'handleMultipart'. That
<span class="lineno">   18 </span>-- function takes uploaded files and streams them to an 'Iteratee' consumer of
<span class="lineno">   19 </span>-- the user's choosing.
<span class="lineno">   20 </span>--
<span class="lineno">   21 </span>-- Using these functions requires making \&quot;policy\&quot; decisions which Snap can't
<span class="lineno">   22 </span>-- really make for users, such as \&quot;what's the largest PDF file a user is
<span class="lineno">   23 </span>-- allowed to upload?\&quot; and \&quot;should we read form inputs into the parameters
<span class="lineno">   24 </span>-- mapping?\&quot;. Policy is specified on a \&quot;global\&quot; basis (using
<span class="lineno">   25 </span>-- 'UploadPolicy'), and on a per-file basis (using 'PartUploadPolicy', which
<span class="lineno">   26 </span>-- allows you to reject or limit the size of certain uploaded
<span class="lineno">   27 </span>-- @Content-type@s).
<span class="lineno">   28 </span>module Snap.Util.FileUploads
<span class="lineno">   29 </span>  ( -- * Functions
<span class="lineno">   30 </span>    handleFileUploads
<span class="lineno">   31 </span>  , handleMultipart
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>    -- * Uploaded parts
<span class="lineno">   34 </span>  , PartInfo(..)
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>    -- ** Policy
<span class="lineno">   37 </span>    -- *** General upload policy
<span class="lineno">   38 </span>  , UploadPolicy
<span class="lineno">   39 </span>  , defaultUploadPolicy
<span class="lineno">   40 </span>  , doProcessFormInputs
<span class="lineno">   41 </span>  , setProcessFormInputs
<span class="lineno">   42 </span>  , getMaximumFormInputSize
<span class="lineno">   43 </span>  , setMaximumFormInputSize
<span class="lineno">   44 </span>  , getMinimumUploadRate
<span class="lineno">   45 </span>  , setMinimumUploadRate
<span class="lineno">   46 </span>  , getMinimumUploadSeconds
<span class="lineno">   47 </span>  , setMinimumUploadSeconds
<span class="lineno">   48 </span>  , getUploadTimeout
<span class="lineno">   49 </span>  , setUploadTimeout
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>    -- *** Per-file upload policy
<span class="lineno">   52 </span>  , PartUploadPolicy
<span class="lineno">   53 </span>  , disallow
<span class="lineno">   54 </span>  , allowWithMaximumSize
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>    -- * Exceptions
<span class="lineno">   57 </span>  , FileUploadException
<span class="lineno">   58 </span>  , fileUploadExceptionReason
<span class="lineno">   59 </span>  , BadPartException
<span class="lineno">   60 </span>  , badPartExceptionReason
<span class="lineno">   61 </span>  , PolicyViolationException
<span class="lineno">   62 </span>  , policyViolationExceptionReason
<span class="lineno">   63 </span>  ) where
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>------------------------------------------------------------------------------
<span class="lineno">   66 </span>import           Control.Arrow
<span class="lineno">   67 </span>import           Control.Applicative
<span class="lineno">   68 </span>import           Control.Exception (SomeException(..))
<span class="lineno">   69 </span>import           Control.Monad
<span class="lineno">   70 </span>import           Control.Monad.CatchIO
<span class="lineno">   71 </span>import           Control.Monad.Trans
<span class="lineno">   72 </span>import qualified Data.Attoparsec.Char8 as Atto
<span class="lineno">   73 </span>import           Data.Attoparsec.Char8 hiding (many, Result(..))
<span class="lineno">   74 </span>import           Data.Attoparsec.Enumerator
<span class="lineno">   75 </span>import           Data.CIByteString
<span class="lineno">   76 </span>import qualified Data.ByteString.Char8 as S
<span class="lineno">   77 </span>import           Data.ByteString.Char8 (ByteString)
<span class="lineno">   78 </span>import           Data.ByteString.Internal (c2w)
<span class="lineno">   79 </span>import qualified Data.DList as D
<span class="lineno">   80 </span>import           Data.Enumerator.Binary (iterHandle)
<span class="lineno">   81 </span>import           Data.IORef
<span class="lineno">   82 </span>import           Data.Int
<span class="lineno">   83 </span>import           Data.List hiding (takeWhile)
<span class="lineno">   84 </span>import qualified Data.Map as Map
<span class="lineno">   85 </span>import           Data.Maybe
<span class="lineno">   86 </span>import qualified Data.Text as T
<span class="lineno">   87 </span>import           Data.Text (Text)
<span class="lineno">   88 </span>import qualified Data.Text.Encoding as TE
<span class="lineno">   89 </span>import           Data.Typeable
<span class="lineno">   90 </span>import           Prelude hiding (catch, getLine, takeWhile)
<span class="lineno">   91 </span>import           System.Directory
<span class="lineno">   92 </span>import           System.IO hiding (isEOF)
<span class="lineno">   93 </span>------------------------------------------------------------------------------
<span class="lineno">   94 </span>import           Snap.Iteratee hiding (map)
<span class="lineno">   95 </span>import qualified Snap.Iteratee as I
<span class="lineno">   96 </span>import           Snap.Internal.Debug
<span class="lineno">   97 </span>import           Snap.Internal.Iteratee.Debug
<span class="lineno">   98 </span>import           Snap.Internal.Iteratee.KnuthMorrisPratt
<span class="lineno">   99 </span>import           Snap.Internal.Parsing
<span class="lineno">  100 </span>import           Snap.Types
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>------------------------------------------------------------------------------
<span class="lineno">  104 </span>-- | Reads uploaded files into a temporary directory and calls a user handler
<span class="lineno">  105 </span>-- to process them.
<span class="lineno">  106 </span>--
<span class="lineno">  107 </span>-- Given a temporary directory, global and file-specific upload policies, and
<span class="lineno">  108 </span>-- a user handler, this function consumes a request body uploaded with
<span class="lineno">  109 </span>-- @Content-type: multipart/form-data@. Each file is read into the temporary
<span class="lineno">  110 </span>-- directory, and then a list of the uploaded files is passed to the user
<span class="lineno">  111 </span>-- handler. After the user handler runs (but before the 'Response' body
<span class="lineno">  112 </span>-- 'Enumerator' is streamed to the client), the files are deleted from disk;
<span class="lineno">  113 </span>-- so if you want to retain or use the uploaded files in the generated
<span class="lineno">  114 </span>-- response, you would need to move or otherwise process them.
<span class="lineno">  115 </span>--
<span class="lineno">  116 </span>-- The argument passed to the user handler is a list of:
<span class="lineno">  117 </span>--
<span class="lineno">  118 </span>-- &gt; (PartInfo, Either PolicyViolationException FilePath)
<span class="lineno">  119 </span>--
<span class="lineno">  120 </span>-- The first half of this tuple is a 'PartInfo', which contains the
<span class="lineno">  121 </span>-- information the client browser sent about the given upload part (like
<span class="lineno">  122 </span>-- filename, content-type, etc). The second half of this tuple is an 'Either'
<span class="lineno">  123 </span>-- stipulating that either:
<span class="lineno">  124 </span>--
<span class="lineno">  125 </span>-- 1. the file was rejected on a policy basis because of the provided
<span class="lineno">  126 </span>--    'PartUploadPolicy' handler
<span class="lineno">  127 </span>--
<span class="lineno">  128 </span>-- 2. the file was accepted and exists at the given path.
<span class="lineno">  129 </span>--
<span class="lineno">  130 </span>-- If the request's @Content-type@ was not \&quot;@multipart/formdata@\&quot;, this
<span class="lineno">  131 </span>-- function skips processing using 'pass'.
<span class="lineno">  132 </span>--
<span class="lineno">  133 </span>-- If the client's upload rate passes below the configured minimum (see
<span class="lineno">  134 </span>-- 'setMinimumUploadRate' and 'setMinimumUploadSeconds'), this function throws
<span class="lineno">  135 </span>-- a 'RateTooSlowException'. This setting is there to protect the server
<span class="lineno">  136 </span>-- against slowloris-style denial of service attacks.
<span class="lineno">  137 </span>--
<span class="lineno">  138 </span>-- If the given 'UploadPolicy' stipulates that you wish form inputs to be
<span class="lineno">  139 </span>-- placed in the 'rqParams' parameter map (using 'setProcessFormInputs'), and
<span class="lineno">  140 </span>-- a form input exceeds the maximum allowable size, this function will throw a
<span class="lineno">  141 </span>-- 'PolicyViolationException'.
<span class="lineno">  142 </span>--
<span class="lineno">  143 </span>-- If an uploaded part contains MIME headers longer than a fixed internal
<span class="lineno">  144 </span>-- threshold (currently 32KB), this function will throw a 'BadPartException'.
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>handleFileUploads ::
<span class="lineno">  147 </span>       (MonadSnap m) =&gt;
<span class="lineno">  148 </span>       FilePath                       -- ^ temporary directory
<span class="lineno">  149 </span>    -&gt; UploadPolicy                   -- ^ general upload policy
<span class="lineno">  150 </span>    -&gt; (PartInfo -&gt; PartUploadPolicy) -- ^ per-part upload policy
<span class="lineno">  151 </span>    -&gt; ([(PartInfo, Either PolicyViolationException FilePath)] -&gt; m a)
<span class="lineno">  152 </span>                                      -- ^ user handler (see function
<span class="lineno">  153 </span>                                      -- description)
<span class="lineno">  154 </span>    -&gt; m a
<span class="lineno">  155 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">handleFileUploads tmpdir uploadPolicy partPolicy handler = do</span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="istickedoff">uploadedFiles &lt;- newUploadedFiles</span>
<span class="lineno">  157 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">(do</span>
<span class="lineno">  159 </span><span class="spaces">        </span><span class="istickedoff">xs &lt;- handleMultipart uploadPolicy (iter uploadedFiles)</span>
<span class="lineno">  160 </span><span class="spaces">        </span><span class="istickedoff">handler xs</span>
<span class="lineno">  161 </span><span class="spaces">        </span><span class="istickedoff">) `finally` (cleanupUploadedFiles uploadedFiles)</span>
<span class="lineno">  162 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">iter uploadedFiles partInfo = maybe disallowed takeIt mbFs</span>
<span class="lineno">  165 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  166 </span><span class="spaces">        </span><span class="istickedoff">ctText = partContentType partInfo</span>
<span class="lineno">  167 </span><span class="spaces">        </span><span class="istickedoff">fnText = fromMaybe <span class="nottickedoff">&quot;&quot;</span> $ partFileName partInfo</span>
<span class="lineno">  168 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  169 </span><span class="spaces">        </span><span class="istickedoff">ct = TE.decodeUtf8 ctText</span>
<span class="lineno">  170 </span><span class="spaces">        </span><span class="istickedoff">fn = TE.decodeUtf8 fnText</span>
<span class="lineno">  171 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">(PartUploadPolicy mbFs) = partPolicy <span class="nottickedoff">partInfo</span></span>
<span class="lineno">  173 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  174 </span><span class="spaces">        </span><span class="istickedoff">retVal (_,x) = (partInfo, Right x)</span>
<span class="lineno">  175 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  176 </span><span class="spaces">        </span><span class="istickedoff">takeIt maxSize = do</span>
<span class="lineno">  177 </span><span class="spaces">            </span><span class="istickedoff">let it = fmap retVal $</span>
<span class="lineno">  178 </span><span class="spaces">                     </span><span class="istickedoff">joinI' $</span>
<span class="lineno">  179 </span><span class="spaces">                     </span><span class="istickedoff">takeNoMoreThan maxSize $$</span>
<span class="lineno">  180 </span><span class="spaces">                     </span><span class="istickedoff">fileReader uploadedFiles tmpdir <span class="nottickedoff">partInfo</span></span>
<span class="lineno">  181 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  182 </span><span class="spaces">            </span><span class="istickedoff">it `catches` [ Handler $ \(_ :: TooManyBytesReadException) -&gt;</span>
<span class="lineno">  183 </span><span class="spaces">                                     </span><span class="istickedoff">(skipToEof &gt;&gt; tooMany maxSize)</span>
<span class="lineno">  184 </span><span class="spaces">                         </span><span class="istickedoff">, <span class="nottickedoff">Handler $ \(e :: SomeException) -&gt; throw e</span></span>
<span class="lineno">  185 </span><span class="spaces">                         </span><span class="istickedoff">]</span>
<span class="lineno">  186 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  187 </span><span class="spaces">        </span><span class="istickedoff">tooMany maxSize =</span>
<span class="lineno">  188 </span><span class="spaces">            </span><span class="istickedoff">return ( partInfo</span>
<span class="lineno">  189 </span><span class="spaces">                   </span><span class="istickedoff">, Left $ PolicyViolationException</span>
<span class="lineno">  190 </span><span class="spaces">                          </span><span class="istickedoff">$ T.concat [ &quot;File \&quot;&quot;</span>
<span class="lineno">  191 </span><span class="spaces">                                     </span><span class="istickedoff">, fn</span>
<span class="lineno">  192 </span><span class="spaces">                                     </span><span class="istickedoff">, &quot;\&quot; exceeded maximum allowable size &quot;</span>
<span class="lineno">  193 </span><span class="spaces">                                     </span><span class="istickedoff">, T.pack $ show maxSize ] )</span>
<span class="lineno">  194 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  195 </span><span class="spaces">        </span><span class="istickedoff">disallowed =</span>
<span class="lineno">  196 </span><span class="spaces">            </span><span class="istickedoff">return ( partInfo</span>
<span class="lineno">  197 </span><span class="spaces">                   </span><span class="istickedoff">, Left $ PolicyViolationException</span>
<span class="lineno">  198 </span><span class="spaces">                          </span><span class="istickedoff">$ T.concat [ &quot;Policy disallowed upload of file \&quot;&quot;</span>
<span class="lineno">  199 </span><span class="spaces">                                     </span><span class="istickedoff">, fn</span>
<span class="lineno">  200 </span><span class="spaces">                                     </span><span class="istickedoff">, &quot;\&quot; with content-type \&quot;&quot;</span>
<span class="lineno">  201 </span><span class="spaces">                                     </span><span class="istickedoff">, ct</span>
<span class="lineno">  202 </span><span class="spaces">                                     </span><span class="istickedoff">, &quot;\&quot;&quot; ] )</span></span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>------------------------------------------------------------------------------
<span class="lineno">  206 </span>-- | Given an upload policy and a function to consume uploaded \&quot;parts\&quot;,
<span class="lineno">  207 </span>-- consume a request body uploaded with @Content-type: multipart/form-data@.
<span class="lineno">  208 </span>-- Normally most users will want to use 'handleFileUploads' (which writes
<span class="lineno">  209 </span>-- uploaded files to a temporary directory and passes their names to a given
<span class="lineno">  210 </span>-- handler) rather than this function; the lower-level 'handleMultipart'
<span class="lineno">  211 </span>-- function should be used if you want to stream uploaded files to your own
<span class="lineno">  212 </span>-- iteratee function.
<span class="lineno">  213 </span>--
<span class="lineno">  214 </span>-- If the request's @Content-type@ was not \&quot;@multipart/formdata@\&quot;, this
<span class="lineno">  215 </span>-- function skips processing using 'pass'.
<span class="lineno">  216 </span>--
<span class="lineno">  217 </span>-- If the client's upload rate passes below the configured minimum (see
<span class="lineno">  218 </span>-- 'setMinimumUploadRate' and 'setMinimumUploadSeconds'), this function throws
<span class="lineno">  219 </span>-- a 'RateTooSlowException'. This setting is there to protect the server
<span class="lineno">  220 </span>-- against slowloris-style denial of service attacks.
<span class="lineno">  221 </span>--
<span class="lineno">  222 </span>-- If the given 'UploadPolicy' stipulates that you wish form inputs to be
<span class="lineno">  223 </span>-- placed in the 'rqParams' parameter map (using 'setProcessFormInputs'), and
<span class="lineno">  224 </span>-- a form input exceeds the maximum allowable size, this function will throw a
<span class="lineno">  225 </span>-- 'PolicyViolationException'.
<span class="lineno">  226 </span>--
<span class="lineno">  227 </span>-- If an uploaded part contains MIME headers longer than a fixed internal
<span class="lineno">  228 </span>-- threshold (currently 32KB), this function will throw a 'BadPartException'.
<span class="lineno">  229 </span>--
<span class="lineno">  230 </span>handleMultipart ::
<span class="lineno">  231 </span>       (MonadSnap m) =&gt;
<span class="lineno">  232 </span>       UploadPolicy                            -- ^ global upload policy
<span class="lineno">  233 </span>    -&gt; (PartInfo -&gt; Iteratee ByteString IO a)  -- ^ part processor
<span class="lineno">  234 </span>    -&gt; m [a]
<span class="lineno">  235 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">handleMultipart uploadPolicy origPartHandler = do</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">hdrs &lt;- liftM headers getRequest</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">let (ct, mbBoundary) = getContentType hdrs</span>
<span class="lineno">  238 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">tickleTimeout &lt;- getTimeoutAction</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">let bumpTimeout = tickleTimeout $ uploadTimeout uploadPolicy</span>
<span class="lineno">  241 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">let partHandler = if doProcessFormInputs uploadPolicy</span>
<span class="lineno">  243 </span><span class="spaces">                        </span><span class="istickedoff">then captureVariableOrReadFile</span>
<span class="lineno">  244 </span><span class="spaces">                                 </span><span class="istickedoff">(getMaximumFormInputSize uploadPolicy)</span>
<span class="lineno">  245 </span><span class="spaces">                                 </span><span class="istickedoff">origPartHandler</span>
<span class="lineno">  246 </span><span class="spaces">                        </span><span class="istickedoff">else (\p -&gt; fmap File (origPartHandler p))</span>
<span class="lineno">  247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">-- not well-formed multipart? bomb out.</span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="istickedoff">when (ct /= &quot;multipart/form-data&quot;) $ do</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">debug $ &quot;handleMultipart called with content-type=&quot; ++ S.unpack ct</span>
<span class="lineno">  251 </span><span class="spaces">                  </span><span class="istickedoff">++ &quot;, passing&quot;</span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">pass</span>
<span class="lineno">  253 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">when (isNothing mbBoundary) $</span>
<span class="lineno">  255 </span><span class="spaces">         </span><span class="istickedoff">throw $ BadPartException $</span>
<span class="lineno">  256 </span><span class="spaces">         </span><span class="istickedoff">&quot;got multipart/form-data without boundary&quot;</span>
<span class="lineno">  257 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">let boundary = fromJust mbBoundary</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">captures &lt;- runRequestBody (iter bumpTimeout boundary partHandler `catch`</span>
<span class="lineno">  260 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">errHandler</span>)</span>
<span class="lineno">  261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">procCaptures [] captures</span>
<span class="lineno">  263 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  264 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">iter bump boundary ph = killIfTooSlow</span>
<span class="lineno">  266 </span><span class="spaces">                              </span><span class="istickedoff">bump</span>
<span class="lineno">  267 </span><span class="spaces">                              </span><span class="istickedoff">(minimumUploadRate uploadPolicy)</span>
<span class="lineno">  268 </span><span class="spaces">                              </span><span class="istickedoff">(minimumUploadSeconds uploadPolicy)</span>
<span class="lineno">  269 </span><span class="spaces">                              </span><span class="istickedoff">(internalHandleMultipart boundary ph)</span>
<span class="lineno">  270 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">errHandler (e :: SomeException) = skipToEof &gt;&gt; (lift $ throw e)</span></span>
<span class="lineno">  272 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">ins k v = Map.insertWith' <span class="nottickedoff">(\a b -&gt; Prelude.head a : b)</span> k [v]</span>
<span class="lineno">  274 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff">maxFormVars = maximumNumberOfFormInputs uploadPolicy</span>
<span class="lineno">  276 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">procCaptures l [] = return $ reverse l</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">procCaptures l ((File x):xs) = procCaptures (x:l) xs</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">procCaptures l ((Capture k v):xs) = do</span>
<span class="lineno">  280 </span><span class="spaces">        </span><span class="istickedoff">rq &lt;- getRequest</span>
<span class="lineno">  281 </span><span class="spaces">        </span><span class="istickedoff">let n = Map.size $ rqParams rq</span>
<span class="lineno">  282 </span><span class="spaces">        </span><span class="istickedoff">when (n &gt;= maxFormVars) $</span>
<span class="lineno">  283 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">throw $ PolicyViolationException $</span></span>
<span class="lineno">  284 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">T.concat [ &quot;number of form inputs exceeded maximum of &quot;</span></span>
<span class="lineno">  285 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, T.pack $ show maxFormVars ]</span></span>
<span class="lineno">  286 </span><span class="spaces">        </span><span class="istickedoff">modifyRequest $ rqModifyParams (ins k v)</span>
<span class="lineno">  287 </span><span class="spaces">        </span><span class="istickedoff">procCaptures l xs</span></span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>------------------------------------------------------------------------------
<span class="lineno">  291 </span>-- | 'PartInfo' contains information about a \&quot;part\&quot; in a request uploaded
<span class="lineno">  292 </span>-- with @Content-type: multipart/form-data@.
<span class="lineno">  293 </span>data <span class="istickedoff">PartInfo</span> =
<span class="lineno">  294 </span>    PartInfo { partFieldName   :: !ByteString
<span class="lineno">  295 </span>             , partFileName    :: !(Maybe ByteString)
<span class="lineno">  296 </span>             , partContentType :: !ByteString
<span class="lineno">  297 </span>             }
<span class="lineno">  298 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>)
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>------------------------------------------------------------------------------
<span class="lineno">  302 </span>-- | All of the exceptions defined in this package inherit from
<span class="lineno">  303 </span>-- 'FileUploadException', so if you write
<span class="lineno">  304 </span>--
<span class="lineno">  305 </span>-- &gt; foo `catch` \(e :: FileUploadException) -&gt; ...
<span class="lineno">  306 </span>--
<span class="lineno">  307 </span>-- you can catch a 'BadPartException', a 'PolicyViolationException', etc.
<span class="lineno">  308 </span>data <span class="nottickedoff">FileUploadException</span> =
<span class="lineno">  309 </span>    GenericFileUploadException {
<span class="lineno">  310 </span>      _genericFileUploadExceptionReason :: Text
<span class="lineno">  311 </span>    }
<span class="lineno">  312 </span>  | forall e . (Exception e, Show e) =&gt;
<span class="lineno">  313 </span>    WrappedFileUploadException {
<span class="lineno">  314 </span>      _wrappedFileUploadException :: e
<span class="lineno">  315 </span>    , _wrappedFileUploadExceptionReason :: Text
<span class="lineno">  316 </span>    }
<span class="lineno">  317 </span>  deriving (<span class="decl"><span class="istickedoff">Typeable</span></span>)
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>------------------------------------------------------------------------------
<span class="lineno">  321 </span>instance Show FileUploadException where
<span class="lineno">  322 </span>    <span class="decl"><span class="istickedoff">show (GenericFileUploadException r) = <span class="nottickedoff">&quot;File upload exception: &quot; ++</span></span>
<span class="lineno">  323 </span><span class="spaces">                                          </span><span class="istickedoff"><span class="nottickedoff">T.unpack r</span></span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">show (WrappedFileUploadException e _) = show e</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>------------------------------------------------------------------------------
<span class="lineno">  328 </span>instance Exception FileUploadException
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>------------------------------------------------------------------------------
<span class="lineno">  332 </span>fileUploadExceptionReason :: FileUploadException -&gt; Text
<span class="lineno">  333 </span><span class="decl"><span class="istickedoff">fileUploadExceptionReason (GenericFileUploadException r) = <span class="nottickedoff">r</span></span>
<span class="lineno">  334 </span><span class="spaces"></span><span class="istickedoff">fileUploadExceptionReason (WrappedFileUploadException _ r) = r</span></span>
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>------------------------------------------------------------------------------
<span class="lineno">  338 </span>uploadExceptionToException :: Exception e =&gt; e -&gt; Text -&gt; SomeException
<span class="lineno">  339 </span><span class="decl"><span class="istickedoff">uploadExceptionToException e r =</span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">SomeException $ WrappedFileUploadException e r</span></span>
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>
<span class="lineno">  343 </span>------------------------------------------------------------------------------
<span class="lineno">  344 </span>uploadExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
<span class="lineno">  345 </span><span class="decl"><span class="istickedoff">uploadExceptionFromException x = do</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">WrappedFileUploadException e _ &lt;- fromException x</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff">cast e</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>------------------------------------------------------------------------------
<span class="lineno">  351 </span>data <span class="nottickedoff">BadPartException</span> = BadPartException { badPartExceptionReason :: Text }
<span class="lineno">  352 </span>  deriving (<span class="decl"><span class="istickedoff">Typeable</span></span>)
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>instance Exception BadPartException where
<span class="lineno">  355 </span>    <span class="decl"><span class="istickedoff">toException e@(BadPartException r) = uploadExceptionToException e <span class="nottickedoff">r</span></span></span>
<span class="lineno">  356 </span>    <span class="decl"><span class="istickedoff">fromException = uploadExceptionFromException</span></span>
<span class="lineno">  357 </span>
<span class="lineno">  358 </span>instance Show BadPartException where
<span class="lineno">  359 </span>  <span class="decl"><span class="istickedoff">show (BadPartException s) = &quot;Bad part: &quot; ++ T.unpack s</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>------------------------------------------------------------------------------
<span class="lineno">  363 </span>data <span class="nottickedoff">PolicyViolationException</span> = PolicyViolationException {
<span class="lineno">  364 </span>      policyViolationExceptionReason :: Text
<span class="lineno">  365 </span>    } deriving (<span class="decl"><span class="nottickedoff">Typeable</span></span>)
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>instance Exception PolicyViolationException where
<span class="lineno">  368 </span>    <span class="decl"><span class="istickedoff">toException e@(PolicyViolationException r) =</span>
<span class="lineno">  369 </span><span class="spaces">        </span><span class="istickedoff">uploadExceptionToException <span class="nottickedoff">e</span> r</span></span>
<span class="lineno">  370 </span>    <span class="decl"><span class="nottickedoff">fromException = uploadExceptionFromException</span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>instance Show PolicyViolationException where
<span class="lineno">  373 </span>  <span class="decl"><span class="istickedoff">show (PolicyViolationException s) = &quot;File upload policy violation: &quot;</span>
<span class="lineno">  374 </span><span class="spaces">                                            </span><span class="istickedoff">++ T.unpack s</span></span>
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>------------------------------------------------------------------------------
<span class="lineno">  378 </span>-- | 'UploadPolicy' controls overall policy decisions relating to
<span class="lineno">  379 </span>-- @multipart/form-data@ uploads, specifically:
<span class="lineno">  380 </span>--
<span class="lineno">  381 </span>-- * whether to treat parts without filenames as form input (reading them into
<span class="lineno">  382 </span>--   the 'rqParams' map)
<span class="lineno">  383 </span>--
<span class="lineno">  384 </span>-- * because form input is read into memory, the maximum size of a form input
<span class="lineno">  385 </span>--   read in this manner, and the maximum number of form inputs
<span class="lineno">  386 </span>--
<span class="lineno">  387 </span>-- * the minimum upload rate a client must maintain before we kill the
<span class="lineno">  388 </span>--   connection; if very low-bitrate uploads were allowed then a Snap server
<span class="lineno">  389 </span>--   would be vulnerable to a trivial denial-of-service using a
<span class="lineno">  390 </span>--   \&quot;slowloris\&quot;-type attack
<span class="lineno">  391 </span>--
<span class="lineno">  392 </span>-- * the minimum number of seconds which must elapse before we start killing
<span class="lineno">  393 </span>--   uploads for having too low an upload rate.
<span class="lineno">  394 </span>--
<span class="lineno">  395 </span>-- * the amount of time we should wait before timing out the connection
<span class="lineno">  396 </span>--   whenever we receive input from the client.
<span class="lineno">  397 </span>data <span class="istickedoff">UploadPolicy</span> = UploadPolicy {
<span class="lineno">  398 </span>      processFormInputs         :: Bool
<span class="lineno">  399 </span>    , maximumFormInputSize      :: Int
<span class="lineno">  400 </span>    , maximumNumberOfFormInputs :: Int
<span class="lineno">  401 </span>    , minimumUploadRate         :: Double
<span class="lineno">  402 </span>    , minimumUploadSeconds      :: Int
<span class="lineno">  403 </span>    , uploadTimeout             :: Int
<span class="lineno">  404 </span>} deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>------------------------------------------------------------------------------
<span class="lineno">  408 </span>-- | A reasonable set of defaults for upload policy. The default policy is:
<span class="lineno">  409 </span>--
<span class="lineno">  410 </span>--   [@maximum form input size@]                128kB
<span class="lineno">  411 </span>--
<span class="lineno">  412 </span>--   [@maximum number of form inputs@]          10
<span class="lineno">  413 </span>--
<span class="lineno">  414 </span>--   [@minimum upload rate@]                    1kB/s
<span class="lineno">  415 </span>--
<span class="lineno">  416 </span>--   [@seconds before rate limiting kicks in@]  10
<span class="lineno">  417 </span>--
<span class="lineno">  418 </span>--   [@inactivity timeout@]                     20 seconds
<span class="lineno">  419 </span>--
<span class="lineno">  420 </span>defaultUploadPolicy :: UploadPolicy
<span class="lineno">  421 </span><span class="decl"><span class="istickedoff">defaultUploadPolicy = UploadPolicy True maxSize maxNum minRate minSeconds tout</span>
<span class="lineno">  422 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="istickedoff">maxSize    = 2^(17::Int)</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">maxNum     = 10</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">minRate    = 1000</span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="istickedoff">minSeconds = 10</span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="istickedoff">tout       = 20</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>------------------------------------------------------------------------------
<span class="lineno">  431 </span>-- | Does this upload policy stipulate that we want to treat parts without
<span class="lineno">  432 </span>-- filenames as form input?
<span class="lineno">  433 </span>doProcessFormInputs :: UploadPolicy -&gt; Bool
<span class="lineno">  434 </span><span class="decl"><span class="istickedoff">doProcessFormInputs = processFormInputs</span></span>
<span class="lineno">  435 </span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>------------------------------------------------------------------------------
<span class="lineno">  438 </span>-- | Set the upload policy for treating parts without filenames as form input.
<span class="lineno">  439 </span>setProcessFormInputs :: Bool -&gt; UploadPolicy -&gt; UploadPolicy
<span class="lineno">  440 </span><span class="decl"><span class="istickedoff">setProcessFormInputs b u = u { processFormInputs = b }</span></span>
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>------------------------------------------------------------------------------
<span class="lineno">  444 </span>-- | Get the maximum size of a form input which will be read into our
<span class="lineno">  445 </span>--   'rqParams' map.
<span class="lineno">  446 </span>getMaximumFormInputSize :: UploadPolicy -&gt; Int
<span class="lineno">  447 </span><span class="decl"><span class="istickedoff">getMaximumFormInputSize = maximumFormInputSize</span></span>
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>
<span class="lineno">  450 </span>------------------------------------------------------------------------------
<span class="lineno">  451 </span>-- | Set the maximum size of a form input which will be read into our
<span class="lineno">  452 </span>--   'rqParams' map.
<span class="lineno">  453 </span>setMaximumFormInputSize :: Int -&gt; UploadPolicy -&gt; UploadPolicy
<span class="lineno">  454 </span><span class="decl"><span class="istickedoff">setMaximumFormInputSize s u = u { maximumFormInputSize = s }</span></span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>------------------------------------------------------------------------------
<span class="lineno">  458 </span>-- | Get the minimum rate (in /bytes\/second/) a client must maintain before
<span class="lineno">  459 </span>--   we kill the connection.
<span class="lineno">  460 </span>getMinimumUploadRate :: UploadPolicy -&gt; Double
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">getMinimumUploadRate = minimumUploadRate</span></span>
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>
<span class="lineno">  464 </span>------------------------------------------------------------------------------
<span class="lineno">  465 </span>-- | Set the minimum rate (in /bytes\/second/) a client must maintain before
<span class="lineno">  466 </span>--   we kill the connection.
<span class="lineno">  467 </span>setMinimumUploadRate :: Double -&gt; UploadPolicy -&gt; UploadPolicy
<span class="lineno">  468 </span><span class="decl"><span class="istickedoff">setMinimumUploadRate s u = u { minimumUploadRate = s }</span></span>
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>------------------------------------------------------------------------------
<span class="lineno">  472 </span>-- | Get the amount of time which must elapse before we begin enforcing the
<span class="lineno">  473 </span>--   upload rate minimum
<span class="lineno">  474 </span>getMinimumUploadSeconds :: UploadPolicy -&gt; Int
<span class="lineno">  475 </span><span class="decl"><span class="istickedoff">getMinimumUploadSeconds = minimumUploadSeconds</span></span>
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>------------------------------------------------------------------------------
<span class="lineno">  479 </span>-- | Set the amount of time which must elapse before we begin enforcing the
<span class="lineno">  480 </span>--   upload rate minimum
<span class="lineno">  481 </span>setMinimumUploadSeconds :: Int -&gt; UploadPolicy -&gt; UploadPolicy
<span class="lineno">  482 </span><span class="decl"><span class="istickedoff">setMinimumUploadSeconds s u = u { minimumUploadSeconds = s }</span></span>
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>------------------------------------------------------------------------------
<span class="lineno">  486 </span>-- | Get the \&quot;upload timeout\&quot;. Whenever input is received from the client,
<span class="lineno">  487 </span>--   the connection timeout is set this many seconds in the future.
<span class="lineno">  488 </span>getUploadTimeout :: UploadPolicy -&gt; Int
<span class="lineno">  489 </span><span class="decl"><span class="istickedoff">getUploadTimeout = uploadTimeout</span></span>
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>------------------------------------------------------------------------------
<span class="lineno">  493 </span>-- | Set the upload timeout.
<span class="lineno">  494 </span>setUploadTimeout :: Int -&gt; UploadPolicy -&gt; UploadPolicy
<span class="lineno">  495 </span><span class="decl"><span class="istickedoff">setUploadTimeout s u = u { uploadTimeout = s }</span></span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>------------------------------------------------------------------------------
<span class="lineno">  499 </span>-- | Upload policy can be set on an \&quot;general\&quot; basis (using 'UploadPolicy'),
<span class="lineno">  500 </span>--   but handlers can also make policy decisions on individual files\/parts
<span class="lineno">  501 </span>--   uploaded. For each part uploaded, handlers can decide:
<span class="lineno">  502 </span>--
<span class="lineno">  503 </span>-- * whether to allow the file upload at all
<span class="lineno">  504 </span>--
<span class="lineno">  505 </span>-- * the maximum size of uploaded files, if allowed
<span class="lineno">  506 </span>data <span class="nottickedoff">PartUploadPolicy</span> = PartUploadPolicy {
<span class="lineno">  507 </span>      _maximumFileSize :: Maybe Int64
<span class="lineno">  508 </span>} deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>------------------------------------------------------------------------------
<span class="lineno">  512 </span>-- | Disallows the file to be uploaded.
<span class="lineno">  513 </span>disallow :: PartUploadPolicy
<span class="lineno">  514 </span><span class="decl"><span class="istickedoff">disallow = PartUploadPolicy Nothing</span></span>
<span class="lineno">  515 </span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>------------------------------------------------------------------------------
<span class="lineno">  518 </span>-- | Allows the file to be uploaded, with maximum size /n/.
<span class="lineno">  519 </span>allowWithMaximumSize :: Int64 -&gt; PartUploadPolicy
<span class="lineno">  520 </span><span class="decl"><span class="istickedoff">allowWithMaximumSize = PartUploadPolicy . Just</span></span>
<span class="lineno">  521 </span>
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>------------------------------------------------------------------------------
<span class="lineno">  524 </span>-- private exports follow. FIXME: organize
<span class="lineno">  525 </span>------------------------------------------------------------------------------
<span class="lineno">  526 </span>
<span class="lineno">  527 </span>------------------------------------------------------------------------------
<span class="lineno">  528 </span>captureVariableOrReadFile ::
<span class="lineno">  529 </span>       Int                                     -- ^ maximum size of form input
<span class="lineno">  530 </span>    -&gt; (PartInfo -&gt; Iteratee ByteString IO a)  -- ^ file reading code
<span class="lineno">  531 </span>    -&gt; (PartInfo -&gt; Iteratee ByteString IO (Capture a))
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">captureVariableOrReadFile maxSize fileHandler partInfo =</span>
<span class="lineno">  533 </span><span class="spaces">    </span><span class="istickedoff">case partFileName partInfo of</span>
<span class="lineno">  534 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; iter</span>
<span class="lineno">  535 </span><span class="spaces">      </span><span class="istickedoff">_       -&gt; liftM File $ fileHandler partInfo</span>
<span class="lineno">  536 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">iter = varIter `catchError` handler</span>
<span class="lineno">  538 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  539 </span><span class="spaces">    </span><span class="istickedoff">fieldName = partFieldName partInfo</span>
<span class="lineno">  540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  541 </span><span class="spaces">    </span><span class="istickedoff">varIter = do</span>
<span class="lineno">  542 </span><span class="spaces">        </span><span class="istickedoff">var &lt;- liftM S.concat $</span>
<span class="lineno">  543 </span><span class="spaces">               </span><span class="istickedoff">joinI' $</span>
<span class="lineno">  544 </span><span class="spaces">               </span><span class="istickedoff">takeNoMoreThan (fromIntegral maxSize) $$ consume</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="istickedoff">return $ Capture fieldName var</span>
<span class="lineno">  546 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  547 </span><span class="spaces">    </span><span class="istickedoff">handler e = do</span>
<span class="lineno">  548 </span><span class="spaces">        </span><span class="istickedoff">let m = fromException e :: Maybe TooManyBytesReadException</span>
<span class="lineno">  549 </span><span class="spaces">        </span><span class="istickedoff">case m of</span>
<span class="lineno">  550 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwError e</span></span>
<span class="lineno">  551 </span><span class="spaces">          </span><span class="istickedoff">Just _  -&gt; throwError $ PolicyViolationException $</span>
<span class="lineno">  552 </span><span class="spaces">                     </span><span class="istickedoff">T.concat [ &quot;form input '&quot;</span>
<span class="lineno">  553 </span><span class="spaces">                              </span><span class="istickedoff">, TE.decodeUtf8 fieldName</span>
<span class="lineno">  554 </span><span class="spaces">                              </span><span class="istickedoff">, &quot;' exceeded maximum permissible size (&quot;</span>
<span class="lineno">  555 </span><span class="spaces">                              </span><span class="istickedoff">, T.pack $ show maxSize</span>
<span class="lineno">  556 </span><span class="spaces">                              </span><span class="istickedoff">, &quot; bytes)&quot; ]</span></span>
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>
<span class="lineno">  559 </span>------------------------------------------------------------------------------
<span class="lineno">  560 </span>data Capture a = Capture ByteString ByteString
<span class="lineno">  561 </span>               | File a
<span class="lineno">  562 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>)
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>------------------------------------------------------------------------------
<span class="lineno">  566 </span>fileReader :: UploadedFiles
<span class="lineno">  567 </span>           -&gt; FilePath
<span class="lineno">  568 </span>           -&gt; PartInfo
<span class="lineno">  569 </span>           -&gt; Iteratee ByteString IO (PartInfo, FilePath)
<span class="lineno">  570 </span><span class="decl"><span class="istickedoff">fileReader uploadedFiles tmpdir partInfo = do</span>
<span class="lineno">  571 </span><span class="spaces">    </span><span class="istickedoff">(fn, h) &lt;- openFileForUpload uploadedFiles tmpdir</span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="istickedoff">let i = iterateeDebugWrapper &quot;fileReader&quot; $ iter fn h</span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff">i `catch` <span class="nottickedoff">\(e::SomeException) -&gt; throwError e</span></span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="istickedoff">iter fileName h = do</span>
<span class="lineno">  577 </span><span class="spaces">        </span><span class="istickedoff">iterHandle h</span>
<span class="lineno">  578 </span><span class="spaces">        </span><span class="istickedoff">debug &quot;fileReader: closing active file&quot;</span>
<span class="lineno">  579 </span><span class="spaces">        </span><span class="istickedoff">closeActiveFile uploadedFiles</span>
<span class="lineno">  580 </span><span class="spaces">        </span><span class="istickedoff">return (<span class="nottickedoff">partInfo</span>, fileName)</span></span>
<span class="lineno">  581 </span>
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>------------------------------------------------------------------------------
<span class="lineno">  584 </span>internalHandleMultipart ::
<span class="lineno">  585 </span>       ByteString                              -- ^ boundary value
<span class="lineno">  586 </span>    -&gt; (PartInfo -&gt; Iteratee ByteString IO a)  -- ^ part processor
<span class="lineno">  587 </span>    -&gt; Iteratee ByteString IO [a]
<span class="lineno">  588 </span><span class="decl"><span class="istickedoff">internalHandleMultipart boundary clientHandler = go `catch` <span class="nottickedoff">errorHandler</span></span>
<span class="lineno">  589 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  590 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="istickedoff">errorHandler :: SomeException -&gt; Iteratee ByteString IO a</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">errorHandler e = do</span></span>
<span class="lineno">  594 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">skipToEof</span></span>
<span class="lineno">  595 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">throwError e</span></span>
<span class="lineno">  596 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  597 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  598 </span><span class="spaces">    </span><span class="istickedoff">go = do</span>
<span class="lineno">  599 </span><span class="spaces">        </span><span class="istickedoff">-- swallow the first boundary</span>
<span class="lineno">  600 </span><span class="spaces">        </span><span class="istickedoff">_ &lt;- iterParser $ parseFirstBoundary boundary</span>
<span class="lineno">  601 </span><span class="spaces">        </span><span class="istickedoff">step &lt;- iterateeDebugWrapper &quot;kmp&quot; $</span>
<span class="lineno">  602 </span><span class="spaces">                </span><span class="istickedoff">(kmpEnumeratee (fullBoundary boundary) $$ processParts iter)</span>
<span class="lineno">  603 </span><span class="spaces">        </span><span class="istickedoff">liftM concat $ lift $ run_ $ returnI step</span>
<span class="lineno">  604 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="istickedoff">pBoundary b = Atto.try $ do</span>
<span class="lineno">  607 </span><span class="spaces">      </span><span class="istickedoff">_ &lt;- string &quot;--&quot;</span>
<span class="lineno">  608 </span><span class="spaces">      </span><span class="istickedoff">string b</span>
<span class="lineno">  609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">fullBoundary b       = S.concat [&quot;\r\n&quot;, &quot;--&quot;, b]</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pLine                = takeWhile (not . isEndOfLine . c2w) &lt;* eol</span></span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">takeLine             = pLine *&gt; pure ()</span></span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="istickedoff">parseFirstBoundary b = pBoundary b &lt;|&gt; <span class="nottickedoff">(takeLine *&gt; parseFirstBoundary b)</span></span>
<span class="lineno">  615 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  616 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  617 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  618 </span><span class="spaces">    </span><span class="istickedoff">takeHeaders = hdrs `catchError` handler</span>
<span class="lineno">  619 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  620 </span><span class="spaces">        </span><span class="istickedoff">hdrs = liftM toHeaders $</span>
<span class="lineno">  621 </span><span class="spaces">               </span><span class="istickedoff">iterateeDebugWrapper &quot;header parser&quot; $</span>
<span class="lineno">  622 </span><span class="spaces">               </span><span class="istickedoff">joinI' $</span>
<span class="lineno">  623 </span><span class="spaces">               </span><span class="istickedoff">takeNoMoreThan mAX_HDRS_SIZE $$</span>
<span class="lineno">  624 </span><span class="spaces">               </span><span class="istickedoff">iterParser pHeadersWithSeparator</span>
<span class="lineno">  625 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  626 </span><span class="spaces">        </span><span class="istickedoff">handler e = do</span>
<span class="lineno">  627 </span><span class="spaces">            </span><span class="istickedoff">let m = fromException e :: Maybe TooManyBytesReadException</span>
<span class="lineno">  628 </span><span class="spaces">            </span><span class="istickedoff">case m of</span>
<span class="lineno">  629 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwError e</span></span>
<span class="lineno">  630 </span><span class="spaces">              </span><span class="istickedoff">Just _  -&gt; throwError $ BadPartException $</span>
<span class="lineno">  631 </span><span class="spaces">                         </span><span class="istickedoff">&quot;headers exceeded maximum size&quot;</span>
<span class="lineno">  632 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="istickedoff">iter = do</span>
<span class="lineno">  635 </span><span class="spaces">        </span><span class="istickedoff">hdrs &lt;- takeHeaders</span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  637 </span><span class="spaces">        </span><span class="istickedoff">-- are we using mixed?</span>
<span class="lineno">  638 </span><span class="spaces">        </span><span class="istickedoff">let (contentType, mboundary) = getContentType hdrs</span>
<span class="lineno">  639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  640 </span><span class="spaces">        </span><span class="istickedoff">let (fieldName, fileName) = getFieldName hdrs</span>
<span class="lineno">  641 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  642 </span><span class="spaces">        </span><span class="istickedoff">if contentType == &quot;multipart/mixed&quot;</span>
<span class="lineno">  643 </span><span class="spaces">          </span><span class="istickedoff">then maybe (throwError $ BadPartException $</span>
<span class="lineno">  644 </span><span class="spaces">                      </span><span class="istickedoff">&quot;got multipart/mixed without boundary&quot;)</span>
<span class="lineno">  645 </span><span class="spaces">                     </span><span class="istickedoff">(processMixed fieldName)</span>
<span class="lineno">  646 </span><span class="spaces">                     </span><span class="istickedoff">mboundary</span>
<span class="lineno">  647 </span><span class="spaces">          </span><span class="istickedoff">else do</span>
<span class="lineno">  648 </span><span class="spaces">              </span><span class="istickedoff">let info = PartInfo fieldName fileName contentType</span>
<span class="lineno">  649 </span><span class="spaces">              </span><span class="istickedoff">liftM (:[]) $ clientHandler info</span>
<span class="lineno">  650 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  652 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="istickedoff">processMixed fieldName mixedBoundary = do</span>
<span class="lineno">  654 </span><span class="spaces">        </span><span class="istickedoff">-- swallow the first boundary</span>
<span class="lineno">  655 </span><span class="spaces">        </span><span class="istickedoff">_ &lt;- iterParser $ parseFirstBoundary mixedBoundary</span>
<span class="lineno">  656 </span><span class="spaces">        </span><span class="istickedoff">step &lt;- iterateeDebugWrapper &quot;kmp&quot; $</span>
<span class="lineno">  657 </span><span class="spaces">                </span><span class="istickedoff">(kmpEnumeratee (fullBoundary mixedBoundary) $$</span>
<span class="lineno">  658 </span><span class="spaces">                 </span><span class="istickedoff">processParts (mixedIter fieldName))</span>
<span class="lineno">  659 </span><span class="spaces">        </span><span class="istickedoff">lift $ run_ $ returnI step</span>
<span class="lineno">  660 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  661 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="istickedoff">--------------------------------------------------------------------------</span>
<span class="lineno">  663 </span><span class="spaces">    </span><span class="istickedoff">mixedIter fieldName = do</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="istickedoff">hdrs &lt;- takeHeaders</span>
<span class="lineno">  665 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  666 </span><span class="spaces">        </span><span class="istickedoff">let (contentType, _) = getContentType hdrs</span>
<span class="lineno">  667 </span><span class="spaces">        </span><span class="istickedoff">let (_, fileName)    = getFieldName hdrs</span>
<span class="lineno">  668 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  669 </span><span class="spaces">        </span><span class="istickedoff">let info = PartInfo fieldName fileName contentType</span>
<span class="lineno">  670 </span><span class="spaces">        </span><span class="istickedoff">clientHandler info</span></span>
<span class="lineno">  671 </span>
<span class="lineno">  672 </span>
<span class="lineno">  673 </span>------------------------------------------------------------------------------
<span class="lineno">  674 </span>getContentType :: Headers
<span class="lineno">  675 </span>               -&gt; (ByteString, Maybe ByteString)
<span class="lineno">  676 </span><span class="decl"><span class="istickedoff">getContentType hdrs = (contentType, boundary)</span>
<span class="lineno">  677 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="istickedoff">contentTypeValue = fromMaybe &quot;text/plain&quot; $</span>
<span class="lineno">  679 </span><span class="spaces">                       </span><span class="istickedoff">getHeader &quot;content-type&quot; hdrs</span>
<span class="lineno">  680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="istickedoff">eCT = fullyParse contentTypeValue pContentTypeWithParameters</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="istickedoff">(contentType, params) = either <span class="nottickedoff">(const (&quot;text/plain&quot;, []))</span> id eCT</span>
<span class="lineno">  683 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  684 </span><span class="spaces">    </span><span class="istickedoff">boundary = findParam &quot;boundary&quot; params</span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>
<span class="lineno">  687 </span>------------------------------------------------------------------------------
<span class="lineno">  688 </span>getFieldName :: Headers -&gt; (ByteString, Maybe ByteString)
<span class="lineno">  689 </span><span class="decl"><span class="istickedoff">getFieldName hdrs = (fieldName, fileName)</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">contentDispositionValue = fromMaybe <span class="nottickedoff">&quot;&quot;</span> $</span>
<span class="lineno">  692 </span><span class="spaces">                              </span><span class="istickedoff">getHeader &quot;content-disposition&quot; hdrs</span>
<span class="lineno">  693 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="istickedoff">eDisposition = fullyParse contentDispositionValue pValueWithParameters</span>
<span class="lineno">  695 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="istickedoff">(_, dispositionParameters) =</span>
<span class="lineno">  697 </span><span class="spaces">        </span><span class="istickedoff">either <span class="nottickedoff">(const (&quot;&quot;, []))</span> id eDisposition</span>
<span class="lineno">  698 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="istickedoff">fieldName = fromMaybe <span class="nottickedoff">&quot;&quot;</span> $ findParam &quot;name&quot; dispositionParameters</span>
<span class="lineno">  700 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  701 </span><span class="spaces">    </span><span class="istickedoff">fileName = findParam &quot;filename&quot; dispositionParameters</span></span>
<span class="lineno">  702 </span>
<span class="lineno">  703 </span>
<span class="lineno">  704 </span>------------------------------------------------------------------------------
<span class="lineno">  705 </span>findParam :: (Eq a) =&gt; a -&gt; [(a, b)] -&gt; Maybe b
<span class="lineno">  706 </span><span class="decl"><span class="istickedoff">findParam p = fmap snd . find ((== p) . fst)</span></span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>------------------------------------------------------------------------------
<span class="lineno">  710 </span>-- | Given a 'MatchInfo' stream which is partitioned by boundary values, read
<span class="lineno">  711 </span>-- up until the next boundary and send all of the chunks into the wrapped
<span class="lineno">  712 </span>-- iteratee
<span class="lineno">  713 </span>processPart :: (Monad m) =&gt; Enumeratee MatchInfo ByteString m a
<span class="lineno">  714 </span><span class="decl"><span class="istickedoff">processPart = checkDone go</span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">go :: (Monad m) =&gt; (Stream ByteString -&gt; Iteratee ByteString m a)</span>
<span class="lineno">  717 </span><span class="spaces">                    </span><span class="istickedoff">-&gt; Iteratee MatchInfo m (Step ByteString m a)</span>
<span class="lineno">  718 </span><span class="spaces">    </span><span class="istickedoff">go k = I.head &gt;&gt;= maybe <span class="nottickedoff">(finish k)</span> (process k)</span>
<span class="lineno">  719 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  720 </span><span class="spaces">    </span><span class="istickedoff">-- called when outer stream is EOF</span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff">finish :: (Monad m) =&gt; (Stream ByteString -&gt; Iteratee ByteString m a)</span>
<span class="lineno">  722 </span><span class="spaces">                        </span><span class="istickedoff">-&gt; Iteratee MatchInfo m (Step ByteString m a)</span>
<span class="lineno">  723 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">finish k = lift $ runIteratee $ k EOF</span></span>
<span class="lineno">  724 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="istickedoff">-- no match ==&gt; pass the stream chunk along</span>
<span class="lineno">  726 </span><span class="spaces">    </span><span class="istickedoff">process :: (Monad m) =&gt; (Stream ByteString -&gt; Iteratee ByteString m a)</span>
<span class="lineno">  727 </span><span class="spaces">                         </span><span class="istickedoff">-&gt; MatchInfo</span>
<span class="lineno">  728 </span><span class="spaces">                         </span><span class="istickedoff">-&gt; Iteratee MatchInfo m (Step ByteString m a)</span>
<span class="lineno">  729 </span><span class="spaces">    </span><span class="istickedoff">process k (NoMatch s) = do</span>
<span class="lineno">  730 </span><span class="spaces">      </span><span class="istickedoff">step &lt;- lift $ runIteratee $ k $ Chunks [s]</span>
<span class="lineno">  731 </span><span class="spaces">      </span><span class="istickedoff">checkDone go step</span>
<span class="lineno">  732 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  733 </span><span class="spaces">    </span><span class="istickedoff">process k (Match _) = lift $ runIteratee $ k EOF</span></span>
<span class="lineno">  734 </span>
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>------------------------------------------------------------------------------
<span class="lineno">  737 </span>-- | Assuming we've already identified the boundary value and run
<span class="lineno">  738 </span>-- 'kmpEnumeratee' to split the input up into parts which match and parts
<span class="lineno">  739 </span>-- which don't, run the given 'ByteString' iteratee over each part and grab a
<span class="lineno">  740 </span>-- list of the resulting values.
<span class="lineno">  741 </span>processParts :: Iteratee ByteString IO a
<span class="lineno">  742 </span>             -&gt; Iteratee MatchInfo IO [a]
<span class="lineno">  743 </span><span class="decl"><span class="istickedoff">processParts partIter = iterateeDebugWrapper &quot;processParts&quot; $ go D.empty</span>
<span class="lineno">  744 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  745 </span><span class="spaces">    </span><span class="istickedoff">iter = do</span>
<span class="lineno">  746 </span><span class="spaces">        </span><span class="istickedoff">isLast &lt;- bParser</span>
<span class="lineno">  747 </span><span class="spaces">        </span><span class="istickedoff">if isLast</span>
<span class="lineno">  748 </span><span class="spaces">          </span><span class="istickedoff">then return Nothing</span>
<span class="lineno">  749 </span><span class="spaces">          </span><span class="istickedoff">else do</span>
<span class="lineno">  750 </span><span class="spaces">            </span><span class="istickedoff">x &lt;- partIter</span>
<span class="lineno">  751 </span><span class="spaces">            </span><span class="istickedoff">skipToEof</span>
<span class="lineno">  752 </span><span class="spaces">            </span><span class="istickedoff">return $ Just x</span>
<span class="lineno">  753 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  754 </span><span class="spaces">    </span><span class="istickedoff">go soFar = do</span>
<span class="lineno">  755 </span><span class="spaces">      </span><span class="istickedoff">b &lt;- isEOF</span>
<span class="lineno">  756 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  757 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">b</span></span>
<span class="lineno">  758 </span><span class="spaces">        </span><span class="istickedoff">then <span class="nottickedoff">return $ D.toList soFar</span></span>
<span class="lineno">  759 </span><span class="spaces">        </span><span class="istickedoff">else do</span>
<span class="lineno">  760 </span><span class="spaces">           </span><span class="istickedoff">-- processPart $$ iter</span>
<span class="lineno">  761 </span><span class="spaces">           </span><span class="istickedoff">--   :: Iteratee MatchInfo m (Step ByteString m a)</span>
<span class="lineno">  762 </span><span class="spaces">           </span><span class="istickedoff">innerStep &lt;- processPart $$ iter</span>
<span class="lineno">  763 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  764 </span><span class="spaces">           </span><span class="istickedoff">-- output :: Maybe a</span>
<span class="lineno">  765 </span><span class="spaces">           </span><span class="istickedoff">output &lt;- lift $ run_ $ returnI innerStep</span>
<span class="lineno">  766 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  767 </span><span class="spaces">           </span><span class="istickedoff">case output of</span>
<span class="lineno">  768 </span><span class="spaces">             </span><span class="istickedoff">Just x  -&gt; go (D.append soFar $ D.singleton x)</span>
<span class="lineno">  769 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; return $ D.toList soFar</span>
<span class="lineno">  770 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  771 </span><span class="spaces">    </span><span class="istickedoff">bParser = iterateeDebugWrapper &quot;boundary debugger&quot; $</span>
<span class="lineno">  772 </span><span class="spaces">                  </span><span class="istickedoff">iterParser $ pBoundaryEnd</span>
<span class="lineno">  773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  774 </span><span class="spaces">    </span><span class="istickedoff">pBoundaryEnd = (eol *&gt; pure False) &lt;|&gt; (string &quot;--&quot; *&gt; pure True)</span></span>
<span class="lineno">  775 </span>
<span class="lineno">  776 </span>
<span class="lineno">  777 </span>------------------------------------------------------------------------------
<span class="lineno">  778 </span>eol :: Parser ByteString
<span class="lineno">  779 </span><span class="decl"><span class="istickedoff">eol = (string &quot;\n&quot;) &lt;|&gt; (string &quot;\r\n&quot;)</span></span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>
<span class="lineno">  782 </span>------------------------------------------------------------------------------
<span class="lineno">  783 </span>pHeadersWithSeparator :: Parser [(ByteString,ByteString)]
<span class="lineno">  784 </span><span class="decl"><span class="istickedoff">pHeadersWithSeparator = pHeaders &lt;* crlf</span></span>
<span class="lineno">  785 </span>
<span class="lineno">  786 </span>
<span class="lineno">  787 </span>------------------------------------------------------------------------------
<span class="lineno">  788 </span>toHeaders :: [(ByteString,ByteString)] -&gt; Headers
<span class="lineno">  789 </span><span class="decl"><span class="istickedoff">toHeaders kvps = foldl' f Map.empty kvps'</span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  791 </span><span class="spaces">    </span><span class="istickedoff">kvps'     = map (first toCI . second (:[])) kvps</span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="istickedoff">f m (k,v) = Map.insertWith' <span class="nottickedoff">(flip (++))</span> k v m</span></span>
<span class="lineno">  793 </span>
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>------------------------------------------------------------------------------
<span class="lineno">  796 </span>mAX_HDRS_SIZE :: Int64
<span class="lineno">  797 </span><span class="decl"><span class="istickedoff">mAX_HDRS_SIZE = 32768</span></span>
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>
<span class="lineno">  800 </span>------------------------------------------------------------------------------
<span class="lineno">  801 </span>-- We need some code to keep track of the files we have already successfully
<span class="lineno">  802 </span>-- created in case an exception is thrown by the request body enumerator or
<span class="lineno">  803 </span>-- one of the client iteratees.
<span class="lineno">  804 </span>data <span class="istickedoff">UploadedFilesState</span> = UploadedFilesState {
<span class="lineno">  805 </span>      -- | This is the file which is currently being written to. If the
<span class="lineno">  806 </span>      -- calling function gets an exception here, it is responsible for
<span class="lineno">  807 </span>      -- closing and deleting this file.
<span class="lineno">  808 </span>      _currentFile :: Maybe (FilePath, Handle)
<span class="lineno">  809 </span>
<span class="lineno">  810 </span>      -- | .. and these files have already been successfully read and closed.
<span class="lineno">  811 </span>    , _alreadyReadFiles :: [FilePath]
<span class="lineno">  812 </span>}
<span class="lineno">  813 </span>
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>------------------------------------------------------------------------------
<span class="lineno">  816 </span>emptyUploadedFilesState :: UploadedFilesState
<span class="lineno">  817 </span><span class="decl"><span class="istickedoff">emptyUploadedFilesState = UploadedFilesState Nothing []</span></span>
<span class="lineno">  818 </span>
<span class="lineno">  819 </span>
<span class="lineno">  820 </span>------------------------------------------------------------------------------
<span class="lineno">  821 </span>newtype UploadedFiles = UploadedFiles (IORef UploadedFilesState)
<span class="lineno">  822 </span>
<span class="lineno">  823 </span>
<span class="lineno">  824 </span>------------------------------------------------------------------------------
<span class="lineno">  825 </span>newUploadedFiles :: MonadIO m =&gt; m UploadedFiles
<span class="lineno">  826 </span><span class="decl"><span class="istickedoff">newUploadedFiles = liftM UploadedFiles $</span>
<span class="lineno">  827 </span><span class="spaces">                   </span><span class="istickedoff">liftIO $ newIORef emptyUploadedFilesState</span></span>
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>
<span class="lineno">  830 </span>------------------------------------------------------------------------------
<span class="lineno">  831 </span>cleanupUploadedFiles :: (MonadIO m) =&gt; UploadedFiles -&gt; m ()
<span class="lineno">  832 </span><span class="decl"><span class="istickedoff">cleanupUploadedFiles (UploadedFiles stateRef) = liftIO $ do</span>
<span class="lineno">  833 </span><span class="spaces">    </span><span class="istickedoff">state &lt;- readIORef stateRef</span>
<span class="lineno">  834 </span><span class="spaces">    </span><span class="istickedoff">killOpenFile state</span>
<span class="lineno">  835 </span><span class="spaces">    </span><span class="istickedoff">mapM_ killFile $ _alreadyReadFiles state</span>
<span class="lineno">  836 </span><span class="spaces">    </span><span class="istickedoff">writeIORef stateRef <span class="nottickedoff">emptyUploadedFilesState</span></span>
<span class="lineno">  837 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  839 </span><span class="spaces">    </span><span class="istickedoff">killFile = eatException . removeFile</span>
<span class="lineno">  840 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  841 </span><span class="spaces">    </span><span class="istickedoff">killOpenFile state = maybe (return <span class="nottickedoff">()</span>)</span>
<span class="lineno">  842 </span><span class="spaces">                               </span><span class="istickedoff">(\(fp,h) -&gt; do</span>
<span class="lineno">  843 </span><span class="spaces">                                    </span><span class="istickedoff">eatException $ hClose h</span>
<span class="lineno">  844 </span><span class="spaces">                                    </span><span class="istickedoff">eatException $ removeFile fp)</span>
<span class="lineno">  845 </span><span class="spaces">                               </span><span class="istickedoff">(_currentFile state)</span></span>
<span class="lineno">  846 </span>
<span class="lineno">  847 </span>
<span class="lineno">  848 </span>------------------------------------------------------------------------------
<span class="lineno">  849 </span>openFileForUpload :: (MonadIO m) =&gt;
<span class="lineno">  850 </span>                     UploadedFiles
<span class="lineno">  851 </span>                  -&gt; FilePath
<span class="lineno">  852 </span>                  -&gt; m (FilePath, Handle)
<span class="lineno">  853 </span><span class="decl"><span class="istickedoff">openFileForUpload ufs@(UploadedFiles stateRef) tmpdir = liftIO $ do</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="istickedoff">state &lt;- readIORef stateRef</span>
<span class="lineno">  855 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  856 </span><span class="spaces">    </span><span class="istickedoff">-- It should be an error to open a new file with this interface if there</span>
<span class="lineno">  857 </span><span class="spaces">    </span><span class="istickedoff">-- is already a file handle active.</span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="istickedoff">when (isJust $ _currentFile state) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  859 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">cleanupUploadedFiles ufs</span></span>
<span class="lineno">  860 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">throw $ GenericFileUploadException alreadyOpenMsg</span></span>
<span class="lineno">  861 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  862 </span><span class="spaces">    </span><span class="istickedoff">fph &lt;- openTempFile tmpdir &quot;snap-&quot;</span>
<span class="lineno">  863 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  864 </span><span class="spaces">    </span><span class="istickedoff">writeIORef stateRef $ state { _currentFile = Just fph }</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">return fph</span>
<span class="lineno">  866 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">alreadyOpenMsg =</span></span>
<span class="lineno">  869 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">T.concat [ &quot;Internal error! UploadedFiles: &quot;</span></span>
<span class="lineno">  870 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">, &quot;opened new file with pre-existing open handle&quot; ]</span></span></span>
<span class="lineno">  871 </span>
<span class="lineno">  872 </span>
<span class="lineno">  873 </span>------------------------------------------------------------------------------
<span class="lineno">  874 </span>closeActiveFile :: (MonadIO m) =&gt; UploadedFiles -&gt; m ()
<span class="lineno">  875 </span><span class="decl"><span class="istickedoff">closeActiveFile (UploadedFiles stateRef) = liftIO $ do</span>
<span class="lineno">  876 </span><span class="spaces">    </span><span class="istickedoff">state &lt;- readIORef stateRef</span>
<span class="lineno">  877 </span><span class="spaces">    </span><span class="istickedoff">let m = _currentFile state</span>
<span class="lineno">  878 </span><span class="spaces">    </span><span class="istickedoff">maybe <span class="nottickedoff">(return ())</span></span>
<span class="lineno">  879 </span><span class="spaces">          </span><span class="istickedoff">(\(fp,h) -&gt; do</span>
<span class="lineno">  880 </span><span class="spaces">               </span><span class="istickedoff">eatException $ hClose h</span>
<span class="lineno">  881 </span><span class="spaces">               </span><span class="istickedoff">writeIORef stateRef $</span>
<span class="lineno">  882 </span><span class="spaces">                 </span><span class="istickedoff">state { _currentFile = Nothing</span>
<span class="lineno">  883 </span><span class="spaces">                       </span><span class="istickedoff">, _alreadyReadFiles = fp:(_alreadyReadFiles state) })</span>
<span class="lineno">  884 </span><span class="spaces">          </span><span class="istickedoff">m</span></span>
<span class="lineno">  885 </span>
<span class="lineno">  886 </span>
<span class="lineno">  887 </span>------------------------------------------------------------------------------
<span class="lineno">  888 </span>eatException :: (MonadCatchIO m) =&gt; m a -&gt; m ()
<span class="lineno">  889 </span><span class="decl"><span class="istickedoff">eatException m =</span>
<span class="lineno">  890 </span><span class="spaces">    </span><span class="istickedoff">(m &gt;&gt; return <span class="nottickedoff">()</span>) `catch` <span class="nottickedoff">(\(_ :: SomeException) -&gt; return ())</span></span></span>

</pre>
</html>
