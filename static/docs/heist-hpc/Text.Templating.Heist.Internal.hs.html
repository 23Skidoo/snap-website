<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    2 </span>{-# LANGUAGE PackageImports #-}
<span class="lineno">    3 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>module Text.Templating.Heist.Internal where
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>------------------------------------------------------------------------------
<span class="lineno">    8 </span>import             Blaze.ByteString.Builder
<span class="lineno">    9 </span>import             Control.Applicative
<span class="lineno">   10 </span>import             Control.Arrow
<span class="lineno">   11 </span>import             Control.Exception (SomeException)
<span class="lineno">   12 </span>import             Control.Monad
<span class="lineno">   13 </span>import             Control.Monad.CatchIO
<span class="lineno">   14 </span>import             Control.Monad.Trans
<span class="lineno">   15 </span>import qualified   Data.Attoparsec.Text as AP
<span class="lineno">   16 </span>import             Data.ByteString (ByteString)
<span class="lineno">   17 </span>import qualified   Data.ByteString as B
<span class="lineno">   18 </span>import qualified   Data.ByteString.Char8 as BC
<span class="lineno">   19 </span>import             Data.Either
<span class="lineno">   20 </span>import qualified   Data.Foldable as F
<span class="lineno">   21 </span>import             Data.List
<span class="lineno">   22 </span>import qualified   Data.Map as Map
<span class="lineno">   23 </span>import             Data.Maybe
<span class="lineno">   24 </span>import             Data.Monoid
<span class="lineno">   25 </span>import qualified   Data.Text as T
<span class="lineno">   26 </span>import             Data.Text (Text)
<span class="lineno">   27 </span>import             Prelude hiding (catch)
<span class="lineno">   28 </span>import             System.Directory.Tree hiding (name)
<span class="lineno">   29 </span>import             System.FilePath
<span class="lineno">   30 </span>import qualified   Text.XmlHtml as X
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>------------------------------------------------------------------------------
<span class="lineno">   33 </span>import             Text.Templating.Heist.Types
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>------------------------------------------------------------------------------
<span class="lineno">   37 </span>-- | Mappends a doctype to the state.
<span class="lineno">   38 </span>addDoctype :: Monad m =&gt; [X.DocType] -&gt; HeistT m ()
<span class="lineno">   39 </span><span class="decl"><span class="istickedoff">addDoctype dt = do</span>
<span class="lineno">   40 </span><span class="spaces">    </span><span class="istickedoff">modifyTS (\s -&gt; s { _doctypes = _doctypes s `mappend` dt })</span></span>
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>------------------------------------------------------------------------------
<span class="lineno">   44 </span>-- TemplateState functions
<span class="lineno">   45 </span>------------------------------------------------------------------------------
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>------------------------------------------------------------------------------
<span class="lineno">   49 </span>-- | Adds an on-load hook to a `TemplateState`.
<span class="lineno">   50 </span>addOnLoadHook :: (Monad m) =&gt;
<span class="lineno">   51 </span>                 (Template -&gt; IO Template)
<span class="lineno">   52 </span>              -&gt; TemplateState m
<span class="lineno">   53 </span>              -&gt; TemplateState m
<span class="lineno">   54 </span><span class="decl"><span class="nottickedoff">addOnLoadHook hook ts = ts { _onLoadHook = _onLoadHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>------------------------------------------------------------------------------
<span class="lineno">   58 </span>-- | Adds a pre-run hook to a `TemplateState`.
<span class="lineno">   59 </span>addPreRunHook :: (Monad m) =&gt;
<span class="lineno">   60 </span>                 (Template -&gt; m Template)
<span class="lineno">   61 </span>              -&gt; TemplateState m
<span class="lineno">   62 </span>              -&gt; TemplateState m
<span class="lineno">   63 </span><span class="decl"><span class="nottickedoff">addPreRunHook hook ts = ts { _preRunHook = _preRunHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>------------------------------------------------------------------------------
<span class="lineno">   67 </span>-- | Adds a post-run hook to a `TemplateState`.
<span class="lineno">   68 </span>addPostRunHook :: (Monad m) =&gt;
<span class="lineno">   69 </span>                  (Template -&gt; m Template)
<span class="lineno">   70 </span>               -&gt; TemplateState m
<span class="lineno">   71 </span>               -&gt; TemplateState m
<span class="lineno">   72 </span><span class="decl"><span class="nottickedoff">addPostRunHook hook ts = ts { _postRunHook = _postRunHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>------------------------------------------------------------------------------
<span class="lineno">   76 </span>-- | Binds a new splice declaration to a tag name within a 'TemplateState'.
<span class="lineno">   77 </span>bindSplice :: Monad m =&gt;
<span class="lineno">   78 </span>              Text              -- ^ tag name
<span class="lineno">   79 </span>           -&gt; Splice m          -- ^ splice action
<span class="lineno">   80 </span>           -&gt; TemplateState m   -- ^ source state
<span class="lineno">   81 </span>           -&gt; TemplateState m
<span class="lineno">   82 </span><span class="decl"><span class="istickedoff">bindSplice n v ts = ts {_spliceMap = Map.insert n v (_spliceMap ts)}</span></span>
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>------------------------------------------------------------------------------
<span class="lineno">   86 </span>-- | Binds a set of new splice declarations within a 'TemplateState'.
<span class="lineno">   87 </span>bindSplices :: Monad m =&gt;
<span class="lineno">   88 </span>               [(Text, Splice m)] -- ^ splices to bind
<span class="lineno">   89 </span>            -&gt; TemplateState m    -- ^ start state
<span class="lineno">   90 </span>            -&gt; TemplateState m
<span class="lineno">   91 </span><span class="decl"><span class="nottickedoff">bindSplices ss ts = foldl' (flip id) ts acts</span>
<span class="lineno">   92 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="nottickedoff">acts = map (uncurry bindSplice) ss</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>------------------------------------------------------------------------------
<span class="lineno">   97 </span>-- | Sets the current template file.
<span class="lineno">   98 </span>setCurTemplateFile :: Monad m
<span class="lineno">   99 </span>                   =&gt; Maybe FilePath -&gt; TemplateState m -&gt; TemplateState m
<span class="lineno">  100 </span><span class="decl"><span class="istickedoff">setCurTemplateFile fp ts = ts { _curTemplateFile = fp }</span></span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>------------------------------------------------------------------------------
<span class="lineno">  104 </span>-- | Converts 'Text' to a splice returning a single 'TextNode'.
<span class="lineno">  105 </span>textSplice :: (Monad m) =&gt; Text -&gt; Splice m
<span class="lineno">  106 </span><span class="decl"><span class="nottickedoff">textSplice t = return [X.TextNode t]</span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>------------------------------------------------------------------------------
<span class="lineno">  110 </span>-- | Runs the parameter node's children and returns the resulting node list.
<span class="lineno">  111 </span>-- By itself this function is a simple passthrough splice that makes the
<span class="lineno">  112 </span>-- spliced node disappear.  In combination with locally bound splices, this
<span class="lineno">  113 </span>-- function makes it easier to pass the desired view into your splices.
<span class="lineno">  114 </span>runChildren :: Monad m =&gt; Splice m
<span class="lineno">  115 </span><span class="decl"><span class="nottickedoff">runChildren = runNodeList . X.childNodes =&lt;&lt; getParamNode</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>------------------------------------------------------------------------------
<span class="lineno">  119 </span>-- | Binds a list of splices before using the children of the spliced node as
<span class="lineno">  120 </span>-- a view.
<span class="lineno">  121 </span>runChildrenWith :: (Monad m)
<span class="lineno">  122 </span>                =&gt; [(Text, Splice m)]
<span class="lineno">  123 </span>                -- ^ List of splices to bind before running the param nodes.
<span class="lineno">  124 </span>                -&gt; Splice m
<span class="lineno">  125 </span>                -- ^ Returns the passed in view.
<span class="lineno">  126 </span><span class="decl"><span class="nottickedoff">runChildrenWith splices = localTS (bindSplices splices) runChildren</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>------------------------------------------------------------------------------
<span class="lineno">  130 </span>-- | Wrapper around runChildrenWith that applies a transformation function to the
<span class="lineno">  131 </span>-- second item in each of the tuples before calling runChildrenWith.
<span class="lineno">  132 </span>runChildrenWithTrans :: (Monad m)
<span class="lineno">  133 </span>          =&gt; (b -&gt; Splice m)
<span class="lineno">  134 </span>          -- ^ Splice generating function
<span class="lineno">  135 </span>          -&gt; [(Text, b)]
<span class="lineno">  136 </span>          -- ^ List of tuples to be bound
<span class="lineno">  137 </span>          -&gt; Splice m
<span class="lineno">  138 </span><span class="decl"><span class="nottickedoff">runChildrenWithTrans f = runChildrenWith . map (second f)</span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>------------------------------------------------------------------------------
<span class="lineno">  142 </span>-- | Like runChildrenWith but using constant templates rather than dynamic
<span class="lineno">  143 </span>-- splices.
<span class="lineno">  144 </span>runChildrenWithTemplates :: (Monad m) =&gt; [(Text, Template)] -&gt; Splice m
<span class="lineno">  145 </span><span class="decl"><span class="nottickedoff">runChildrenWithTemplates = runChildrenWithTrans return</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>------------------------------------------------------------------------------
<span class="lineno">  149 </span>-- | Like runChildrenWith but using literal text rather than dynamic splices.
<span class="lineno">  150 </span>runChildrenWithText :: (Monad m) =&gt; [(Text, Text)] -&gt; Splice m
<span class="lineno">  151 </span><span class="decl"><span class="nottickedoff">runChildrenWithText = runChildrenWithTrans textSplice</span></span>
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>------------------------------------------------------------------------------
<span class="lineno">  155 </span>-- | Maps a splice generating function over a list and concatenates the
<span class="lineno">  156 </span>-- results.
<span class="lineno">  157 </span>mapSplices :: (Monad m)
<span class="lineno">  158 </span>        =&gt; (a -&gt; Splice m)
<span class="lineno">  159 </span>        -- ^ Splice generating function
<span class="lineno">  160 </span>        -&gt; [a]
<span class="lineno">  161 </span>        -- ^ List of items to generate splices for
<span class="lineno">  162 </span>        -&gt; Splice m
<span class="lineno">  163 </span>        -- ^ The result of all splices concatenated together.
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">mapSplices f vs = liftM concat $ mapM f vs</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>------------------------------------------------------------------------------
<span class="lineno">  168 </span>-- | Convenience function for looking up a splice.
<span class="lineno">  169 </span>lookupSplice :: Monad m =&gt;
<span class="lineno">  170 </span>                Text
<span class="lineno">  171 </span>             -&gt; TemplateState m
<span class="lineno">  172 </span>             -&gt; Maybe (Splice m)
<span class="lineno">  173 </span><span class="decl"><span class="istickedoff">lookupSplice nm ts = Map.lookup nm $ _spliceMap ts</span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>------------------------------------------------------------------------------
<span class="lineno">  177 </span>-- | Converts a path into an array of the elements in reverse order.  If the
<span class="lineno">  178 </span>-- path is absolute, we need to remove the leading slash so the split doesn't
<span class="lineno">  179 </span>-- leave @\&quot;\&quot;@ as the last element of the TPath.
<span class="lineno">  180 </span>--
<span class="lineno">  181 </span>-- FIXME @\&quot;..\&quot;@ currently doesn't work in paths, the solution is non-trivial
<span class="lineno">  182 </span>splitPathWith :: Char -&gt; ByteString -&gt; TPath
<span class="lineno">  183 </span><span class="decl"><span class="istickedoff">splitPathWith s p = if BC.null p then [] else (reverse $ BC.split s path)</span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">path = if BC.head p == s then BC.tail p else p</span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>-- | Converts a path into an array of the elements in reverse order using the
<span class="lineno">  188 </span>-- path separator of the local operating system. See 'splitPathWith' for more
<span class="lineno">  189 </span>-- details.
<span class="lineno">  190 </span>splitLocalPath :: ByteString -&gt; TPath
<span class="lineno">  191 </span><span class="decl"><span class="istickedoff">splitLocalPath = splitPathWith pathSeparator</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>-- | Converts a path into an array of the elements in reverse order using a
<span class="lineno">  194 </span>-- forward slash (/) as the path separator. See 'splitPathWith' for more
<span class="lineno">  195 </span>-- details.
<span class="lineno">  196 </span>splitTemplatePath :: ByteString -&gt; TPath
<span class="lineno">  197 </span><span class="decl"><span class="istickedoff">splitTemplatePath = splitPathWith '/'</span></span>
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>------------------------------------------------------------------------------
<span class="lineno">  201 </span>-- | Does a single template lookup without cascading up.
<span class="lineno">  202 </span>singleLookup :: TemplateMap
<span class="lineno">  203 </span>             -&gt; TPath
<span class="lineno">  204 </span>             -&gt; ByteString
<span class="lineno">  205 </span>             -&gt; Maybe (DocumentFile, TPath)
<span class="lineno">  206 </span><span class="decl"><span class="istickedoff">singleLookup tm path name = fmap (\a -&gt; (a,<span class="nottickedoff">path</span>)) $ Map.lookup (name:path) tm</span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>------------------------------------------------------------------------------
<span class="lineno">  210 </span>-- | Searches for a template by looking in the full path then backing up into
<span class="lineno">  211 </span>-- each of the parent directories until the template is found.
<span class="lineno">  212 </span>traversePath :: TemplateMap
<span class="lineno">  213 </span>             -&gt; TPath
<span class="lineno">  214 </span>             -&gt; ByteString
<span class="lineno">  215 </span>             -&gt; Maybe (DocumentFile, TPath)
<span class="lineno">  216 </span><span class="decl"><span class="istickedoff">traversePath tm [] name = fmap (\a -&gt; (a,<span class="nottickedoff">[]</span>)) (Map.lookup [name] tm)</span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff">traversePath tm path name =</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">singleLookup tm path name `mplus`</span></span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">traversePath tm (tail path) name</span></span></span>
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>------------------------------------------------------------------------------
<span class="lineno">  223 </span>-- | Returns 'True' if the given template can be found in the template state.
<span class="lineno">  224 </span>hasTemplate :: Monad m =&gt;
<span class="lineno">  225 </span>               ByteString
<span class="lineno">  226 </span>            -&gt; TemplateState m
<span class="lineno">  227 </span>            -&gt; Bool
<span class="lineno">  228 </span><span class="decl"><span class="istickedoff">hasTemplate nameStr ts = isJust $ lookupTemplate nameStr ts</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>------------------------------------------------------------------------------
<span class="lineno">  232 </span>-- | Convenience function for looking up a template.
<span class="lineno">  233 </span>lookupTemplate :: Monad m =&gt;
<span class="lineno">  234 </span>                  ByteString
<span class="lineno">  235 </span>               -&gt; TemplateState m
<span class="lineno">  236 </span>               -&gt; Maybe (DocumentFile, TPath)
<span class="lineno">  237 </span><span class="decl"><span class="istickedoff">lookupTemplate nameStr ts =</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">f (_templateMap ts) path name</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="istickedoff">where (name:p) = case splitTemplatePath nameStr of</span>
<span class="lineno">  240 </span><span class="spaces">                       </span><span class="istickedoff">[] -&gt; [&quot;&quot;]</span>
<span class="lineno">  241 </span><span class="spaces">                       </span><span class="istickedoff">ps -&gt; ps</span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="istickedoff">ctx = if B.isPrefixOf &quot;/&quot; nameStr then [] else _curContext ts</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">path = p ++ ctx</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">f = if '/' `BC.elem` nameStr</span>
<span class="lineno">  245 </span><span class="spaces">                </span><span class="istickedoff">then singleLookup</span>
<span class="lineno">  246 </span><span class="spaces">                </span><span class="istickedoff">else traversePath</span></span>
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>------------------------------------------------------------------------------
<span class="lineno">  250 </span>-- | Sets the templateMap in a TemplateState.
<span class="lineno">  251 </span>setTemplates :: Monad m =&gt; TemplateMap -&gt; TemplateState m -&gt; TemplateState m
<span class="lineno">  252 </span><span class="decl"><span class="istickedoff">setTemplates m ts = ts { _templateMap = m }</span></span>
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>------------------------------------------------------------------------------
<span class="lineno">  256 </span>-- | Adds a template to the template state.
<span class="lineno">  257 </span>insertTemplate :: Monad m =&gt;
<span class="lineno">  258 </span>               TPath
<span class="lineno">  259 </span>            -&gt; DocumentFile
<span class="lineno">  260 </span>            -&gt; TemplateState m
<span class="lineno">  261 </span>            -&gt; TemplateState m
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">insertTemplate p t st =</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">setTemplates (Map.insert p t (_templateMap st)) st</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>------------------------------------------------------------------------------
<span class="lineno">  267 </span>-- | Adds an HTML format template to the template state.
<span class="lineno">  268 </span>addTemplate :: Monad m
<span class="lineno">  269 </span>            =&gt; ByteString
<span class="lineno">  270 </span>            -- ^ Path that the template will be referenced by
<span class="lineno">  271 </span>            -&gt; Template
<span class="lineno">  272 </span>            -- ^ The template's DOM nodes
<span class="lineno">  273 </span>            -&gt; Maybe FilePath
<span class="lineno">  274 </span>            -- ^ An optional path to the actual file on disk where the
<span class="lineno">  275 </span>            -- template is stored
<span class="lineno">  276 </span>            -&gt; TemplateState m
<span class="lineno">  277 </span>            -&gt; TemplateState m
<span class="lineno">  278 </span><span class="decl"><span class="istickedoff">addTemplate n t mfp st =</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">insertTemplate (splitTemplatePath n) doc st</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">doc = DocumentFile (X.HtmlDocument X.UTF8 Nothing t) <span class="nottickedoff">mfp</span></span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>------------------------------------------------------------------------------
<span class="lineno">  285 </span>-- | Adds an XML format template to the template state.
<span class="lineno">  286 </span>addXMLTemplate :: Monad m
<span class="lineno">  287 </span>               =&gt; ByteString
<span class="lineno">  288 </span>               -- ^ Path that the template will be referenced by
<span class="lineno">  289 </span>               -&gt; Template
<span class="lineno">  290 </span>               -- ^ The template's DOM nodes
<span class="lineno">  291 </span>               -&gt; Maybe FilePath
<span class="lineno">  292 </span>               -- ^ An optional path to the actual file on disk where the
<span class="lineno">  293 </span>               -- template is stored
<span class="lineno">  294 </span>               -&gt; TemplateState m
<span class="lineno">  295 </span>               -&gt; TemplateState m
<span class="lineno">  296 </span><span class="decl"><span class="nottickedoff">addXMLTemplate n t mfp st =</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="nottickedoff">insertTemplate (splitTemplatePath n) doc st</span>
<span class="lineno">  298 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  299 </span><span class="spaces">    </span><span class="nottickedoff">doc = DocumentFile (X.XmlDocument X.UTF8 Nothing t) mfp</span></span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>------------------------------------------------------------------------------
<span class="lineno">  303 </span>-- | Stops the recursive processing of splices.  Consider the following
<span class="lineno">  304 </span>-- example:
<span class="lineno">  305 </span>--
<span class="lineno">  306 </span>--   &gt; &lt;foo&gt;
<span class="lineno">  307 </span>--   &gt;   &lt;bar&gt;
<span class="lineno">  308 </span>--   &gt;     ...
<span class="lineno">  309 </span>--   &gt;   &lt;/bar&gt;
<span class="lineno">  310 </span>--   &gt; &lt;/foo&gt;
<span class="lineno">  311 </span>--
<span class="lineno">  312 </span>-- Assume that @\&quot;foo\&quot;@ is bound to a splice procedure. Running the @foo@
<span class="lineno">  313 </span>-- splice will result in a list of nodes @L@.  Normally @foo@ will recursively
<span class="lineno">  314 </span>-- scan @L@ for splices and run them.  If @foo@ calls @stopRecursion@, @L@
<span class="lineno">  315 </span>-- will be included in the output verbatim without running any splices.
<span class="lineno">  316 </span>stopRecursion :: Monad m =&gt; HeistT m ()
<span class="lineno">  317 </span><span class="decl"><span class="nottickedoff">stopRecursion = modifyTS (\st -&gt; st { _recurse = False })</span></span>
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>------------------------------------------------------------------------------
<span class="lineno">  321 </span>-- | Sets the current context
<span class="lineno">  322 </span>setContext :: Monad m =&gt; TPath -&gt; HeistT m ()
<span class="lineno">  323 </span><span class="decl"><span class="istickedoff">setContext c = modifyTS (\st -&gt; st { _curContext = <span class="nottickedoff">c</span> })</span></span>
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>------------------------------------------------------------------------------
<span class="lineno">  327 </span>-- | Gets the current context
<span class="lineno">  328 </span>getContext :: Monad m =&gt; HeistT m TPath
<span class="lineno">  329 </span><span class="decl"><span class="istickedoff">getContext = getsTS <span class="nottickedoff">_curContext</span></span></span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>------------------------------------------------------------------------------
<span class="lineno">  333 </span>-- | Gets the full path to the file holding the template currently being
<span class="lineno">  334 </span>-- processed.  Returns Nothing if the template is not associated with a file
<span class="lineno">  335 </span>-- on disk or if there is no template being processed.
<span class="lineno">  336 </span>getTemplateFilePath :: Monad m =&gt; HeistT m (Maybe FilePath)
<span class="lineno">  337 </span><span class="decl"><span class="istickedoff">getTemplateFilePath = getsTS _curTemplateFile</span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>------------------------------------------------------------------------------
<span class="lineno">  341 </span>-- | Performs splice processing on a single node.
<span class="lineno">  342 </span>runNode :: Monad m =&gt; X.Node -&gt; Splice m
<span class="lineno">  343 </span><span class="decl"><span class="istickedoff">runNode (X.Element nm at ch) = do</span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff">newAtts &lt;- mapM attSubst at</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">let n = X.Element nm newAtts ch</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- liftM (lookupSplice nm) getTS</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff">maybe (runKids newAtts) (recurseSplice n) s</span>
<span class="lineno">  348 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">runKids newAtts = do</span>
<span class="lineno">  350 </span><span class="spaces">        </span><span class="istickedoff">newKids &lt;- runNodeList ch</span>
<span class="lineno">  351 </span><span class="spaces">        </span><span class="istickedoff">return [X.Element nm newAtts newKids]</span>
<span class="lineno">  352 </span><span class="spaces"></span><span class="istickedoff">runNode n                    = return [n]</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>------------------------------------------------------------------------------
<span class="lineno">  356 </span>-- | Helper function for substituting a parsed attribute into an attribute
<span class="lineno">  357 </span>-- tuple.
<span class="lineno">  358 </span>attSubst :: (Monad m) =&gt; (t, Text) -&gt; HeistT m (t, Text)
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff">attSubst (n,v) = do</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">v' &lt;- parseAtt v</span>
<span class="lineno">  361 </span><span class="spaces">    </span><span class="istickedoff">return (n,v')</span></span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>------------------------------------------------------------------------------
<span class="lineno">  365 </span>-- | Parses an attribute for any identifier expressions and performs
<span class="lineno">  366 </span>-- appropriate substitution.
<span class="lineno">  367 </span>parseAtt :: (Monad m) =&gt; Text -&gt; HeistT m Text
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">parseAtt bs = do</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">let ast = case AP.feed (AP.parse attParser bs) &quot;&quot; of</span>
<span class="lineno">  370 </span><span class="spaces">            </span><span class="istickedoff">(AP.Fail _ _ _) -&gt; []</span>
<span class="lineno">  371 </span><span class="spaces">            </span><span class="istickedoff">(AP.Done _ res) -&gt; res</span>
<span class="lineno">  372 </span><span class="spaces">            </span><span class="istickedoff">(AP.Partial _)  -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno">  373 </span><span class="spaces">    </span><span class="istickedoff">chunks &lt;- mapM cvt ast</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="istickedoff">return $ T.concat chunks</span>
<span class="lineno">  375 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">cvt (Literal x) = return x</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">cvt (Ident x)   = getAttributeSplice x</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>------------------------------------------------------------------------------
<span class="lineno">  381 </span>-- | AST to hold attribute parsing structure.  This is necessary because
<span class="lineno">  382 </span>-- attoparsec doesn't support parsers running in another monad.
<span class="lineno">  383 </span>data AttAST = Literal Text |
<span class="lineno">  384 </span>              Ident   Text
<span class="lineno">  385 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>)
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>------------------------------------------------------------------------------
<span class="lineno">  389 </span>-- | Parser for attribute variable substitution.
<span class="lineno">  390 </span>attParser :: AP.Parser [AttAST]
<span class="lineno">  391 </span><span class="decl"><span class="istickedoff">attParser = AP.many1 (identParser &lt;|&gt; litParser)</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="istickedoff">escChar = (AP.char '\\' *&gt; AP.anyChar) &lt;|&gt;</span>
<span class="lineno">  394 </span><span class="spaces">              </span><span class="istickedoff">AP.satisfy (AP.notInClass &quot;\\$&quot;)</span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="istickedoff">litParser = Literal &lt;$&gt; (T.pack &lt;$&gt; AP.many1 escChar)</span>
<span class="lineno">  396 </span><span class="spaces">    </span><span class="istickedoff">identParser = AP.string &quot;$(&quot; *&gt;</span>
<span class="lineno">  397 </span><span class="spaces">        </span><span class="istickedoff">(Ident &lt;$&gt; AP.takeWhile (/=')')) &lt;* AP.string &quot;)&quot;</span></span>
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>------------------------------------------------------------------------------
<span class="lineno">  401 </span>-- | Gets the attribute value.  If the splice's result list contains non-text
<span class="lineno">  402 </span>-- nodes, this will translate them into text nodes with nodeText and
<span class="lineno">  403 </span>-- concatenate them together.
<span class="lineno">  404 </span>--
<span class="lineno">  405 </span>-- Originally, this only took the first node from the splices's result list,
<span class="lineno">  406 </span>-- and only if it was a text node. This caused problems when the splice's
<span class="lineno">  407 </span>-- result contained HTML entities, as they would split a text node. This was
<span class="lineno">  408 </span>-- then fixed to take the first consecutive bunch of text nodes, and return
<span class="lineno">  409 </span>-- their concatenation. This was seen as more useful than throwing an error,
<span class="lineno">  410 </span>-- and more intuitive than trying to render all the nodes as text.
<span class="lineno">  411 </span>--
<span class="lineno">  412 </span>-- However, it was decided in the end to render all the nodes as text, and
<span class="lineno">  413 </span>-- then concatenate them. If a splice returned
<span class="lineno">  414 </span>-- \&quot;some \&lt;b\&gt;text\&lt;\/b\&gt; foobar\&quot;, the user would almost certainly want
<span class="lineno">  415 </span>-- \&quot;some text foobar\&quot; to be rendered, and Heist would probably seem
<span class="lineno">  416 </span>-- annoyingly limited for not being able to do this. If the user really did
<span class="lineno">  417 </span>-- want it to render \&quot;some \&quot;, it would probably be easier for them to
<span class="lineno">  418 </span>-- accept that they were silly to pass more than that to be substituted than
<span class="lineno">  419 </span>-- it would be for the former user to accept that
<span class="lineno">  420 </span>-- \&quot;some \&lt;b\&gt;text\&lt;\/b\&gt; foobar\&quot; is being rendered as \&quot;some \&quot; because
<span class="lineno">  421 </span>-- it's \&quot;more intuitive\&quot;.
<span class="lineno">  422 </span>getAttributeSplice :: Monad m =&gt; Text -&gt; HeistT m Text
<span class="lineno">  423 </span><span class="decl"><span class="istickedoff">getAttributeSplice name = do</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- liftM (lookupSplice name) getTS</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">nodes &lt;- maybe (return []) id s</span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="istickedoff">return $ T.concat $ map X.nodeText nodes</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>------------------------------------------------------------------------------
<span class="lineno">  429 </span>-- | Performs splice processing on a list of nodes.
<span class="lineno">  430 </span>runNodeList :: Monad m =&gt; [X.Node] -&gt; Splice m
<span class="lineno">  431 </span><span class="decl"><span class="istickedoff">runNodeList = mapSplices runNode</span></span>
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>
<span class="lineno">  434 </span>------------------------------------------------------------------------------
<span class="lineno">  435 </span>-- | The maximum recursion depth.  (Used to prevent infinite loops.)
<span class="lineno">  436 </span>mAX_RECURSION_DEPTH :: Int
<span class="lineno">  437 </span><span class="decl"><span class="istickedoff">mAX_RECURSION_DEPTH = 50</span></span>
<span class="lineno">  438 </span>
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>------------------------------------------------------------------------------
<span class="lineno">  441 </span>-- | Checks the recursion flag and recurses accordingly.  Does not recurse
<span class="lineno">  442 </span>-- deeper than mAX_RECURSION_DEPTH to avoid infinite loops.
<span class="lineno">  443 </span>recurseSplice :: Monad m =&gt; X.Node -&gt; Splice m -&gt; Splice m
<span class="lineno">  444 </span><span class="decl"><span class="istickedoff">recurseSplice node splice = do</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">result &lt;- localParamNode (const node) splice</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">ts' &lt;- getTS</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">_recurse ts' &amp;&amp; _recursionDepth ts' &lt; mAX_RECURSION_DEPTH</span></span>
<span class="lineno">  448 </span><span class="spaces">        </span><span class="istickedoff">then do modRecursionDepth <span class="nottickedoff">(+1)</span></span>
<span class="lineno">  449 </span><span class="spaces">                </span><span class="istickedoff">res &lt;- runNodeList result</span>
<span class="lineno">  450 </span><span class="spaces">                </span><span class="istickedoff">restoreTS ts'</span>
<span class="lineno">  451 </span><span class="spaces">                </span><span class="istickedoff">return res</span>
<span class="lineno">  452 </span><span class="spaces">        </span><span class="istickedoff">else <span class="nottickedoff">return result</span></span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">modRecursionDepth :: Monad m =&gt; (Int -&gt; Int) -&gt; HeistT m ()</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">modRecursionDepth f =</span>
<span class="lineno">  456 </span><span class="spaces">        </span><span class="istickedoff">modifyTS (\st -&gt; st { _recursionDepth = <span class="nottickedoff">f (_recursionDepth st)</span> })</span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>------------------------------------------------------------------------------
<span class="lineno">  460 </span>-- | Looks up a template name runs a 'HeistT' computation on it.
<span class="lineno">  461 </span>lookupAndRun :: Monad m
<span class="lineno">  462 </span>             =&gt; ByteString
<span class="lineno">  463 </span>             -&gt; ((DocumentFile, TPath) -&gt; HeistT m (Maybe a))
<span class="lineno">  464 </span>             -&gt; HeistT m (Maybe a)
<span class="lineno">  465 </span><span class="decl"><span class="istickedoff">lookupAndRun name k = do</span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">ts &lt;- getTS</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">let mt = lookupTemplate name ts</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">let curPath = join $ fmap (dfFile . fst) mt</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">modifyTS (setCurTemplateFile curPath)</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">maybe (return Nothing) k mt</span></span>
<span class="lineno">  471 </span>
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>------------------------------------------------------------------------------
<span class="lineno">  474 </span>-- | Looks up a template name evaluates it by calling runNodeList.
<span class="lineno">  475 </span>evalTemplate :: Monad m
<span class="lineno">  476 </span>            =&gt; ByteString
<span class="lineno">  477 </span>            -&gt; HeistT m (Maybe Template)
<span class="lineno">  478 </span><span class="decl"><span class="nottickedoff">evalTemplate name = lookupAndRun name</span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="nottickedoff">(\(t,ctx) -&gt; localTS (\ts -&gt; ts {_curContext = ctx})</span>
<span class="lineno">  480 </span><span class="spaces">                         </span><span class="nottickedoff">(liftM Just $ runNodeList $ X.docContent $ dfDoc t))</span></span>
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>------------------------------------------------------------------------------
<span class="lineno">  484 </span>-- | Sets the document type of a 'X.Document' based on the 'HeistT'
<span class="lineno">  485 </span>-- value.
<span class="lineno">  486 </span>fixDocType :: Monad m =&gt; X.Document -&gt; HeistT m X.Document
<span class="lineno">  487 </span><span class="decl"><span class="istickedoff">fixDocType d = do</span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff">dts &lt;- getsTS _doctypes</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">return $ d { X.docType = listToMaybe dts }</span></span>
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>------------------------------------------------------------------------------
<span class="lineno">  493 </span>-- | Same as evalWithHooks, but returns the entire 'X.Document' rather than
<span class="lineno">  494 </span>-- just the nodes.  This is the right thing to do if we are starting at the
<span class="lineno">  495 </span>-- top level.
<span class="lineno">  496 </span>evalWithHooksInternal :: Monad m
<span class="lineno">  497 </span>                      =&gt; ByteString
<span class="lineno">  498 </span>                      -&gt; HeistT m (Maybe X.Document)
<span class="lineno">  499 </span><span class="decl"><span class="istickedoff">evalWithHooksInternal name = lookupAndRun name $ \(t,ctx) -&gt; do</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">addDoctype $ maybeToList $ X.docType $ dfDoc t</span>
<span class="lineno">  501 </span><span class="spaces">    </span><span class="istickedoff">ts &lt;- getTS</span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="istickedoff">nodes &lt;- lift $ _preRunHook ts $ X.docContent $ dfDoc t</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">putTS (ts {_curContext = <span class="nottickedoff">ctx</span>})</span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff">res &lt;- runNodeList nodes</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">restoreTS ts</span>
<span class="lineno">  506 </span><span class="spaces">    </span><span class="istickedoff">newNodes &lt;- lift (_postRunHook ts res)</span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff">newDoc   &lt;- fixDocType $ (dfDoc t) { X.docContent = newNodes }</span>
<span class="lineno">  508 </span><span class="spaces">    </span><span class="istickedoff">return (Just newDoc)</span></span>
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>------------------------------------------------------------------------------
<span class="lineno">  512 </span>-- | Looks up a template name evaluates it by calling runNodeList.  This also
<span class="lineno">  513 </span>-- executes pre- and post-run hooks and adds the doctype.
<span class="lineno">  514 </span>evalWithHooks :: Monad m
<span class="lineno">  515 </span>            =&gt; ByteString
<span class="lineno">  516 </span>            -&gt; HeistT m (Maybe Template)
<span class="lineno">  517 </span><span class="decl"><span class="nottickedoff">evalWithHooks name = liftM (liftM X.docContent) (evalWithHooksInternal name)</span></span>
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>------------------------------------------------------------------------------
<span class="lineno">  521 </span>-- | Binds a list of constant string splices.
<span class="lineno">  522 </span>bindStrings :: Monad m
<span class="lineno">  523 </span>            =&gt; [(Text, Text)]
<span class="lineno">  524 </span>            -&gt; TemplateState m
<span class="lineno">  525 </span>            -&gt; TemplateState m
<span class="lineno">  526 </span><span class="decl"><span class="nottickedoff">bindStrings pairs ts = foldr (uncurry bindString) ts pairs</span></span>
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>------------------------------------------------------------------------------
<span class="lineno">  530 </span>-- | Binds a single constant string splice.
<span class="lineno">  531 </span>bindString :: Monad m
<span class="lineno">  532 </span>            =&gt; Text
<span class="lineno">  533 </span>            -&gt; Text
<span class="lineno">  534 </span>            -&gt; TemplateState m
<span class="lineno">  535 </span>            -&gt; TemplateState m
<span class="lineno">  536 </span><span class="decl"><span class="nottickedoff">bindString n = bindSplice n . textSplice</span></span>
<span class="lineno">  537 </span>
<span class="lineno">  538 </span>
<span class="lineno">  539 </span>------------------------------------------------------------------------------
<span class="lineno">  540 </span>-- | Renders a template with the specified parameters.  This is the function
<span class="lineno">  541 </span>-- to use when you want to &quot;call&quot; a template and pass in parameters from
<span class="lineno">  542 </span>-- inside a splice.
<span class="lineno">  543 </span>callTemplate :: Monad m
<span class="lineno">  544 </span>             =&gt; ByteString     -- ^ The name of the template
<span class="lineno">  545 </span>             -&gt; [(Text, Text)] -- ^ Association list of
<span class="lineno">  546 </span>                               -- (name,value) parameter pairs
<span class="lineno">  547 </span>             -&gt; HeistT m (Maybe Template)
<span class="lineno">  548 </span><span class="decl"><span class="nottickedoff">callTemplate name params = do</span>
<span class="lineno">  549 </span><span class="spaces">    </span><span class="nottickedoff">modifyTS $ bindStrings params</span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="nottickedoff">evalTemplate name</span></span>
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>
<span class="lineno">  553 </span>------------------------------------------------------------------------------
<span class="lineno">  554 </span>-- Gives the MIME type for a 'X.Document'
<span class="lineno">  555 </span>mimeType :: X.Document -&gt; ByteString
<span class="lineno">  556 </span><span class="decl"><span class="nottickedoff">mimeType d = case d of</span>
<span class="lineno">  557 </span><span class="spaces">    </span><span class="nottickedoff">(X.HtmlDocument e _ _) -&gt; &quot;text/html;charset=&quot; `BC.append` enc e</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="nottickedoff">(X.XmlDocument  e _ _) -&gt; &quot;text/xml;charset=&quot;  `BC.append` enc e</span>
<span class="lineno">  559 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="nottickedoff">enc X.UTF8    = &quot;utf-8&quot;</span>
<span class="lineno">  561 </span><span class="spaces">    </span><span class="nottickedoff">-- Should not include byte order designation for UTF-16 since</span>
<span class="lineno">  562 </span><span class="spaces">    </span><span class="nottickedoff">-- rendering will include a byte order mark. (RFC 2781, Sec. 3.3)</span>
<span class="lineno">  563 </span><span class="spaces">    </span><span class="nottickedoff">enc X.UTF16BE = &quot;utf-16&quot;</span>
<span class="lineno">  564 </span><span class="spaces">    </span><span class="nottickedoff">enc X.UTF16LE = &quot;utf-16&quot;</span></span>
<span class="lineno">  565 </span>
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>------------------------------------------------------------------------------
<span class="lineno">  568 </span>-- | Renders a template from the specified TemplateState to a 'Builder'.  The
<span class="lineno">  569 </span>-- MIME type returned is based on the detected character encoding, and whether
<span class="lineno">  570 </span>-- the root template was an HTML or XML format template.  It will always be
<span class="lineno">  571 </span>-- @text/html@ or @text/xml@.  If a more specific MIME type is needed for a
<span class="lineno">  572 </span>-- particular XML application, it must be provided by the application.
<span class="lineno">  573 </span>renderTemplate :: Monad m
<span class="lineno">  574 </span>               =&gt; TemplateState m
<span class="lineno">  575 </span>               -&gt; ByteString
<span class="lineno">  576 </span>               -&gt; m (Maybe (Builder, MIMEType))
<span class="lineno">  577 </span><span class="decl"><span class="istickedoff">renderTemplate ts name = evalTemplateMonad tpl (X.TextNode &quot;&quot;) ts</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="istickedoff">where tpl = do mt &lt;- evalWithHooksInternal name</span>
<span class="lineno">  579 </span><span class="spaces">                 </span><span class="istickedoff">case mt of</span>
<span class="lineno">  580 </span><span class="spaces">                    </span><span class="istickedoff">Nothing  -&gt; return Nothing</span>
<span class="lineno">  581 </span><span class="spaces">                    </span><span class="istickedoff">Just doc -&gt; return $ Just $ (X.render doc, <span class="nottickedoff">mimeType doc</span>)</span></span>
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>
<span class="lineno">  584 </span>------------------------------------------------------------------------------
<span class="lineno">  585 </span>-- | Renders a template with the specified arguments passed to it.  This is a
<span class="lineno">  586 </span>-- convenience function for the common pattern of calling renderTemplate after
<span class="lineno">  587 </span>-- using bindString, bindStrings, or bindSplice to set up the arguments to the
<span class="lineno">  588 </span>-- template.
<span class="lineno">  589 </span>renderWithArgs :: Monad m
<span class="lineno">  590 </span>                   =&gt; [(Text, Text)]
<span class="lineno">  591 </span>                   -&gt; TemplateState m
<span class="lineno">  592 </span>                   -&gt; ByteString
<span class="lineno">  593 </span>                   -&gt; m (Maybe (Builder, MIMEType))
<span class="lineno">  594 </span><span class="decl"><span class="nottickedoff">renderWithArgs args ts = renderTemplate (bindStrings args ts)</span></span>
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>
<span class="lineno">  597 </span>------------------------------------------------------------------------------
<span class="lineno">  598 </span>-- Template loading
<span class="lineno">  599 </span>------------------------------------------------------------------------------
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>------------------------------------------------------------------------------
<span class="lineno">  603 </span>-- | Type synonym for parsers.
<span class="lineno">  604 </span>type ParserFun = String -&gt; ByteString -&gt; Either String X.Document
<span class="lineno">  605 </span>
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>------------------------------------------------------------------------------
<span class="lineno">  608 </span>-- | Reads an HTML or XML template from disk.
<span class="lineno">  609 </span>getDocWith :: ParserFun -&gt; String -&gt; IO (Either String DocumentFile)
<span class="lineno">  610 </span><span class="decl"><span class="istickedoff">getDocWith parser f = do</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">bs &lt;- catch (liftM Right $ B.readFile f)</span>
<span class="lineno">  612 </span><span class="spaces">                </span><span class="istickedoff">(\(e::SomeException) -&gt; return $ Left $ <span class="nottickedoff">show e</span>)</span>
<span class="lineno">  613 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="istickedoff">let eitherDoc = either Left (parser <span class="nottickedoff">f</span>) bs</span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="istickedoff">return $ either (\s -&gt; Left $ <span class="nottickedoff">f ++ &quot; &quot; ++ s</span>)</span>
<span class="lineno">  616 </span><span class="spaces">                    </span><span class="istickedoff">(\d -&gt; Right $ DocumentFile d (Just f)) eitherDoc</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>------------------------------------------------------------------------------
<span class="lineno">  620 </span>-- | Reads an HTML template from disk.
<span class="lineno">  621 </span>getDoc :: String -&gt; IO (Either String DocumentFile)
<span class="lineno">  622 </span><span class="decl"><span class="istickedoff">getDoc = getDocWith X.parseHTML</span></span>
<span class="lineno">  623 </span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>------------------------------------------------------------------------------
<span class="lineno">  626 </span>-- | Reads an XML template from disk.
<span class="lineno">  627 </span>getXMLDoc :: String -&gt; IO (Either String DocumentFile)
<span class="lineno">  628 </span><span class="decl"><span class="nottickedoff">getXMLDoc = getDocWith X.parseHTML</span></span>
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>
<span class="lineno">  631 </span>------------------------------------------------------------------------------
<span class="lineno">  632 </span>-- | Loads a template with the specified path and filename.  The
<span class="lineno">  633 </span>-- template is only loaded if it has a &quot;.tpl&quot; or &quot;.xtpl&quot; extension.
<span class="lineno">  634 </span>loadTemplate :: String -- ^ path of the template root
<span class="lineno">  635 </span>             -&gt; String -- ^ full file path (includes the template root)
<span class="lineno">  636 </span>             -&gt; IO [Either String (TPath, DocumentFile)] --TemplateMap
<span class="lineno">  637 </span><span class="decl"><span class="istickedoff">loadTemplate templateRoot fname</span>
<span class="lineno">  638 </span><span class="spaces">    </span><span class="istickedoff">| isHTMLTemplate = do</span>
<span class="lineno">  639 </span><span class="spaces">        </span><span class="istickedoff">c &lt;- getDoc fname</span>
<span class="lineno">  640 </span><span class="spaces">        </span><span class="istickedoff">return [fmap (\t -&gt; (splitLocalPath $ BC.pack tName, t)) c]</span>
<span class="lineno">  641 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">isXMLTemplate</span> = <span class="nottickedoff">do</span></span>
<span class="lineno">  642 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">c &lt;- getXMLDoc fname</span></span>
<span class="lineno">  643 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return [fmap (\t -&gt; (splitLocalPath $ BC.pack tName, t)) c]</span></span>
<span class="lineno">  644 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return []</span>
<span class="lineno">  645 </span><span class="spaces">  </span><span class="istickedoff">where -- tName is path relative to the template root directory</span>
<span class="lineno">  646 </span><span class="spaces">        </span><span class="istickedoff">isHTMLTemplate = &quot;.tpl&quot;  `isSuffixOf` fname</span>
<span class="lineno">  647 </span><span class="spaces">        </span><span class="istickedoff">isXMLTemplate  = &quot;.xtpl&quot; `isSuffixOf` fname</span>
<span class="lineno">  648 </span><span class="spaces">        </span><span class="istickedoff">correction = if <span class="tickonlyfalse">last templateRoot == '/'</span> then <span class="nottickedoff">0</span> else 1</span>
<span class="lineno">  649 </span><span class="spaces">        </span><span class="istickedoff">extLen     = if <span class="tickonlytrue">isHTMLTemplate</span> then 4 else <span class="nottickedoff">5</span></span>
<span class="lineno">  650 </span><span class="spaces">        </span><span class="istickedoff">tName = drop ((length templateRoot)+correction) $</span>
<span class="lineno">  651 </span><span class="spaces">                </span><span class="istickedoff">-- We're only dropping the template root, not the whole path</span>
<span class="lineno">  652 </span><span class="spaces">                </span><span class="istickedoff">take ((length fname) - extLen) fname</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>------------------------------------------------------------------------------
<span class="lineno">  656 </span>-- | Traverses the specified directory structure and builds a
<span class="lineno">  657 </span>-- TemplateState by loading all the files with a &quot;.tpl&quot; or &quot;.xtpl&quot; extension.
<span class="lineno">  658 </span>loadTemplates :: Monad m =&gt; FilePath -&gt; TemplateState m
<span class="lineno">  659 </span>              -&gt; IO (Either String (TemplateState m))
<span class="lineno">  660 </span><span class="decl"><span class="istickedoff">loadTemplates dir ts = do</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="istickedoff">d &lt;- readDirectoryWith (loadTemplate dir) dir</span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="istickedoff">let tlist = F.fold (free d)</span>
<span class="lineno">  663 </span><span class="spaces">        </span><span class="istickedoff">errs = lefts tlist</span>
<span class="lineno">  664 </span><span class="spaces">    </span><span class="istickedoff">case errs of</span>
<span class="lineno">  665 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; liftM Right $ foldM loadHook ts $ rights tlist</span>
<span class="lineno">  666 </span><span class="spaces">        </span><span class="istickedoff">_  -&gt; <span class="nottickedoff">return $ Left $ unlines errs</span></span></span>
<span class="lineno">  667 </span>
<span class="lineno">  668 </span>
<span class="lineno">  669 </span>------------------------------------------------------------------------------
<span class="lineno">  670 </span>-- | Runs a template modifying function on a DocumentFile.
<span class="lineno">  671 </span>runHook :: Monad m =&gt; (Template -&gt; m Template)
<span class="lineno">  672 </span>        -&gt; DocumentFile
<span class="lineno">  673 </span>        -&gt; m DocumentFile
<span class="lineno">  674 </span><span class="decl"><span class="istickedoff">runHook f t = do</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">n &lt;- f $ X.docContent $ dfDoc t</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="istickedoff">return $ t { dfDoc = (dfDoc t) { X.docContent = n } }</span></span>
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>
<span class="lineno">  679 </span>------------------------------------------------------------------------------
<span class="lineno">  680 </span>-- | Runs the onLoad hook on the template and returns the 'TemplateState'
<span class="lineno">  681 </span>-- with the result inserted.
<span class="lineno">  682 </span>loadHook :: Monad m =&gt; TemplateState m -&gt; (TPath, DocumentFile)
<span class="lineno">  683 </span>         -&gt; IO (TemplateState m)
<span class="lineno">  684 </span><span class="decl"><span class="istickedoff">loadHook ts (tp, t) = do</span>
<span class="lineno">  685 </span><span class="spaces">    </span><span class="istickedoff">t' &lt;- runHook (_onLoadHook ts) t</span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="istickedoff">return $ insertTemplate tp t' ts</span></span>
<span class="lineno">  687 </span>
<span class="lineno">  688 </span>
<span class="lineno">  689 </span>------------------------------------------------------------------------------
<span class="lineno">  690 </span>-- | Adds a path prefix to all the templates in the 'TemplateState'.  If you
<span class="lineno">  691 </span>-- want to add multiple levels of directories, separate them with slashes as
<span class="lineno">  692 </span>-- in &quot;foo/bar&quot;.  Using an empty string as a path prefix will leave the
<span class="lineno">  693 </span>-- 'TemplateState' unchanged.
<span class="lineno">  694 </span>addTemplatePathPrefix :: ByteString -&gt; TemplateState m -&gt; TemplateState m
<span class="lineno">  695 </span><span class="decl"><span class="nottickedoff">addTemplatePathPrefix dir ts</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="nottickedoff">| B.null dir = ts</span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise  = ts { _templateMap = Map.mapKeys f $ _templateMap ts }</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="nottickedoff">f ps = ps++splitTemplatePath dir</span></span>
<span class="lineno">  700 </span>

</pre>
</html>
