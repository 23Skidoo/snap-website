<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    2 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    3 </span>{-# LANGUAGE PackageImports #-}
<span class="lineno">    4 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>module Text.Templating.Heist.Internal where
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>------------------------------------------------------------------------------
<span class="lineno">    9 </span>import             Control.Applicative
<span class="lineno">   10 </span>import             Control.Exception (SomeException)
<span class="lineno">   11 </span>import             Control.Monad.CatchIO
<span class="lineno">   12 </span>import &quot;monads-fd&quot; Control.Monad.RWS.Strict
<span class="lineno">   13 </span>import qualified   Data.Attoparsec.Char8 as AP
<span class="lineno">   14 </span>import             Data.ByteString.Char8 (ByteString)
<span class="lineno">   15 </span>import qualified   Data.ByteString.Char8 as B
<span class="lineno">   16 </span>import qualified   Data.ByteString.Lazy as L
<span class="lineno">   17 </span>import             Data.Either
<span class="lineno">   18 </span>import qualified   Data.Foldable as F
<span class="lineno">   19 </span>import             Data.List
<span class="lineno">   20 </span>import qualified   Data.Map as Map
<span class="lineno">   21 </span>import             Data.Maybe
<span class="lineno">   22 </span>import             Prelude hiding (catch)
<span class="lineno">   23 </span>import             System.Directory.Tree hiding (name)
<span class="lineno">   24 </span>import             System.FilePath
<span class="lineno">   25 </span>import             Text.XML.Expat.Format
<span class="lineno">   26 </span>import qualified   Text.XML.Expat.Tree as X
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>------------------------------------------------------------------------------
<span class="lineno">   29 </span>import             Text.Templating.Heist.Constants
<span class="lineno">   30 </span>import             Text.Templating.Heist.Types
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>------------------------------------------------------------------------------
<span class="lineno">   34 </span>-- | Mappends a doctype to the state.
<span class="lineno">   35 </span>addDoctype :: Monad m =&gt; [ByteString] -&gt; TemplateMonad m ()
<span class="lineno">   36 </span><span class="decl"><span class="istickedoff">addDoctype dt = do</span>
<span class="lineno">   37 </span><span class="spaces">    </span><span class="istickedoff">modifyTS (\s -&gt; s { _doctypes = _doctypes s `mappend` dt })</span></span>
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>------------------------------------------------------------------------------
<span class="lineno">   41 </span>-- TemplateState functions
<span class="lineno">   42 </span>------------------------------------------------------------------------------
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>------------------------------------------------------------------------------
<span class="lineno">   46 </span>-- | Adds an on-load hook to a `TemplateState`.
<span class="lineno">   47 </span>addOnLoadHook :: (Monad m) =&gt;
<span class="lineno">   48 </span>                 (Template -&gt; IO Template)
<span class="lineno">   49 </span>              -&gt; TemplateState m
<span class="lineno">   50 </span>              -&gt; TemplateState m
<span class="lineno">   51 </span><span class="decl"><span class="nottickedoff">addOnLoadHook hook ts = ts { _onLoadHook = _onLoadHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>------------------------------------------------------------------------------
<span class="lineno">   55 </span>-- | Adds a pre-run hook to a `TemplateState`.
<span class="lineno">   56 </span>addPreRunHook :: (Monad m) =&gt;
<span class="lineno">   57 </span>                 (Template -&gt; m Template)
<span class="lineno">   58 </span>              -&gt; TemplateState m
<span class="lineno">   59 </span>              -&gt; TemplateState m
<span class="lineno">   60 </span><span class="decl"><span class="nottickedoff">addPreRunHook hook ts = ts { _preRunHook = _preRunHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>------------------------------------------------------------------------------
<span class="lineno">   64 </span>-- | Adds a post-run hook to a `TemplateState`.
<span class="lineno">   65 </span>addPostRunHook :: (Monad m) =&gt;
<span class="lineno">   66 </span>                  (Template -&gt; m Template)
<span class="lineno">   67 </span>               -&gt; TemplateState m
<span class="lineno">   68 </span>               -&gt; TemplateState m
<span class="lineno">   69 </span><span class="decl"><span class="nottickedoff">addPostRunHook hook ts = ts { _postRunHook = _postRunHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>------------------------------------------------------------------------------
<span class="lineno">   73 </span>-- | Binds a new splice declaration to a tag name within a 'TemplateState'.
<span class="lineno">   74 </span>bindSplice :: Monad m =&gt;
<span class="lineno">   75 </span>              ByteString        -- ^ tag name
<span class="lineno">   76 </span>           -&gt; Splice m          -- ^ splice action
<span class="lineno">   77 </span>           -&gt; TemplateState m   -- ^ source state
<span class="lineno">   78 </span>           -&gt; TemplateState m
<span class="lineno">   79 </span><span class="decl"><span class="istickedoff">bindSplice n v ts = ts {_spliceMap = Map.insert n v (_spliceMap ts)}</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>------------------------------------------------------------------------------
<span class="lineno">   83 </span>-- | Binds a set of new splice declarations within a 'TemplateState'.
<span class="lineno">   84 </span>bindSplices :: Monad m =&gt;
<span class="lineno">   85 </span>               [(ByteString, Splice m)] -- ^ splices to bind
<span class="lineno">   86 </span>            -&gt; TemplateState m   -- ^ start state
<span class="lineno">   87 </span>            -&gt; TemplateState m
<span class="lineno">   88 </span><span class="decl"><span class="nottickedoff">bindSplices ss ts = foldl' (flip id) ts acts </span>
<span class="lineno">   89 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="nottickedoff">acts = map (uncurry bindSplice) ss</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>------------------------------------------------------------------------------
<span class="lineno">   94 </span>-- | Convenience function for looking up a splice.
<span class="lineno">   95 </span>lookupSplice :: Monad m =&gt;
<span class="lineno">   96 </span>                ByteString
<span class="lineno">   97 </span>             -&gt; TemplateState m
<span class="lineno">   98 </span>             -&gt; Maybe (Splice m)
<span class="lineno">   99 </span><span class="decl"><span class="istickedoff">lookupSplice nm ts = Map.lookup nm $ _spliceMap ts</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>------------------------------------------------------------------------------
<span class="lineno">  103 </span>-- | Converts a path into an array of the elements in reverse order.  If the
<span class="lineno">  104 </span>-- path is absolute, we need to remove the leading slash so the split doesn't
<span class="lineno">  105 </span>-- leave @\&quot;\&quot;@ as the last element of the TPath.
<span class="lineno">  106 </span>--
<span class="lineno">  107 </span>-- FIXME @\&quot;..\&quot;@ currently doesn't work in paths, the solution is non-trivial
<span class="lineno">  108 </span>splitPathWith :: Char -&gt; ByteString -&gt; TPath
<span class="lineno">  109 </span><span class="decl"><span class="istickedoff">splitPathWith s p = if B.null p then [] else (reverse $ B.split s path)</span>
<span class="lineno">  110 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  111 </span><span class="spaces">    </span><span class="istickedoff">path = if B.head p == s then B.tail p else p</span></span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>-- | Converts a path into an array of the elements in reverse order using the
<span class="lineno">  114 </span>-- path separator of the local operating system. See 'splitPathWith' for more
<span class="lineno">  115 </span>-- details.
<span class="lineno">  116 </span>splitLocalPath :: ByteString -&gt; TPath
<span class="lineno">  117 </span><span class="decl"><span class="istickedoff">splitLocalPath = splitPathWith pathSeparator</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>-- | Converts a path into an array of the elements in reverse order using a
<span class="lineno">  120 </span>-- forward slash (/) as the path separator. See 'splitPathWith' for more
<span class="lineno">  121 </span>-- details.
<span class="lineno">  122 </span>splitTemplatePath :: ByteString -&gt; TPath
<span class="lineno">  123 </span><span class="decl"><span class="istickedoff">splitTemplatePath = splitPathWith '/'</span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>------------------------------------------------------------------------------
<span class="lineno">  127 </span>-- | Does a single template lookup without cascading up.
<span class="lineno">  128 </span>singleLookup :: TemplateMap
<span class="lineno">  129 </span>             -&gt; TPath
<span class="lineno">  130 </span>             -&gt; ByteString
<span class="lineno">  131 </span>             -&gt; Maybe (InternalTemplate, TPath)
<span class="lineno">  132 </span><span class="decl"><span class="istickedoff">singleLookup tm path name = fmap (\a -&gt; (a,<span class="nottickedoff">path</span>)) $ Map.lookup (name:path) tm</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>------------------------------------------------------------------------------
<span class="lineno">  136 </span>-- | Searches for a template by looking in the full path then backing up into each
<span class="lineno">  137 </span>-- of the parent directories until the template is found.
<span class="lineno">  138 </span>traversePath :: TemplateMap
<span class="lineno">  139 </span>             -&gt; TPath
<span class="lineno">  140 </span>             -&gt; ByteString
<span class="lineno">  141 </span>             -&gt; Maybe (InternalTemplate, TPath)
<span class="lineno">  142 </span><span class="decl"><span class="istickedoff">traversePath tm [] name = fmap (\a -&gt; (a,<span class="nottickedoff">[]</span>)) (Map.lookup [name] tm)</span>
<span class="lineno">  143 </span><span class="spaces"></span><span class="istickedoff">traversePath tm path name =</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">singleLookup tm path name `mplus`</span></span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">traversePath tm (tail path) name</span></span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>------------------------------------------------------------------------------
<span class="lineno">  149 </span>-- | Returns 'True' if the given template can be found in the template state.
<span class="lineno">  150 </span>hasTemplate :: Monad m =&gt;
<span class="lineno">  151 </span>               ByteString
<span class="lineno">  152 </span>            -&gt; TemplateState m
<span class="lineno">  153 </span>            -&gt; Bool
<span class="lineno">  154 </span><span class="decl"><span class="nottickedoff">hasTemplate nameStr ts = isJust $ lookupTemplate nameStr ts</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>------------------------------------------------------------------------------
<span class="lineno">  158 </span>-- | Convenience function for looking up a template.
<span class="lineno">  159 </span>lookupTemplate :: Monad m =&gt;
<span class="lineno">  160 </span>                  ByteString
<span class="lineno">  161 </span>               -&gt; TemplateState m
<span class="lineno">  162 </span>               -&gt; Maybe (InternalTemplate, TPath)
<span class="lineno">  163 </span><span class="decl"><span class="istickedoff">lookupTemplate nameStr ts = </span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">f (_templateMap ts) path name</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">where (name:p) = case splitTemplatePath nameStr of</span>
<span class="lineno">  166 </span><span class="spaces">                       </span><span class="istickedoff">[] -&gt; [&quot;&quot;]</span>
<span class="lineno">  167 </span><span class="spaces">                       </span><span class="istickedoff">ps -&gt; ps</span>
<span class="lineno">  168 </span><span class="spaces">        </span><span class="istickedoff">path = p ++ (_curContext ts)</span>
<span class="lineno">  169 </span><span class="spaces">        </span><span class="istickedoff">f = if '/' `B.elem` nameStr</span>
<span class="lineno">  170 </span><span class="spaces">                </span><span class="istickedoff">then singleLookup</span>
<span class="lineno">  171 </span><span class="spaces">                </span><span class="istickedoff">else traversePath</span></span>
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>------------------------------------------------------------------------------
<span class="lineno">  175 </span>-- | Sets the templateMap in a TemplateState.
<span class="lineno">  176 </span>setTemplates :: Monad m =&gt; TemplateMap -&gt; TemplateState m -&gt; TemplateState m
<span class="lineno">  177 </span><span class="decl"><span class="istickedoff">setTemplates m ts = ts { _templateMap = m }</span></span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>------------------------------------------------------------------------------
<span class="lineno">  181 </span>-- | Adds a template to the template state.
<span class="lineno">  182 </span>insertTemplate :: Monad m =&gt;
<span class="lineno">  183 </span>               TPath
<span class="lineno">  184 </span>            -&gt; InternalTemplate
<span class="lineno">  185 </span>            -&gt; TemplateState m
<span class="lineno">  186 </span>            -&gt; TemplateState m
<span class="lineno">  187 </span><span class="decl"><span class="istickedoff">insertTemplate p t st =</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">setTemplates (Map.insert p t (_templateMap st)) st</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>------------------------------------------------------------------------------
<span class="lineno">  192 </span>-- | Adds a template to the template state.
<span class="lineno">  193 </span>addTemplate :: Monad m =&gt;
<span class="lineno">  194 </span>               ByteString
<span class="lineno">  195 </span>            -&gt; Template
<span class="lineno">  196 </span>            -&gt; TemplateState m
<span class="lineno">  197 </span>            -&gt; TemplateState m
<span class="lineno">  198 </span><span class="decl"><span class="istickedoff">addTemplate n t st = insertTemplate (splitTemplatePath n)</span>
<span class="lineno">  199 </span><span class="spaces">                                    </span><span class="istickedoff">(InternalTemplate <span class="nottickedoff">Nothing</span> t) st</span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>------------------------------------------------------------------------------
<span class="lineno">  203 </span>-- | Stops the recursive processing of splices.  Consider the following
<span class="lineno">  204 </span>-- example:
<span class="lineno">  205 </span>--
<span class="lineno">  206 </span>--   &gt; &lt;foo&gt;
<span class="lineno">  207 </span>--   &gt;   &lt;bar&gt;
<span class="lineno">  208 </span>--   &gt;     ...
<span class="lineno">  209 </span>--   &gt;   &lt;/bar&gt;
<span class="lineno">  210 </span>--   &gt; &lt;/foo&gt;
<span class="lineno">  211 </span>--
<span class="lineno">  212 </span>-- Assume that @\&quot;foo\&quot;@ is bound to a splice procedure. Running the @foo@
<span class="lineno">  213 </span>-- splice will result in a list of nodes @L@.  Normally @foo@ will recursively
<span class="lineno">  214 </span>-- scan @L@ for splices and run them.  If @foo@ calls @stopRecursion@, @L@
<span class="lineno">  215 </span>-- will be included in the output verbatim without running any splices.
<span class="lineno">  216 </span>stopRecursion :: Monad m =&gt; TemplateMonad m ()
<span class="lineno">  217 </span><span class="decl"><span class="nottickedoff">stopRecursion = modifyTS (\st -&gt; st { _recurse = False })</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>------------------------------------------------------------------------------
<span class="lineno">  221 </span>-- | Sets the current context
<span class="lineno">  222 </span>setContext :: Monad m =&gt; TPath -&gt; TemplateMonad m ()
<span class="lineno">  223 </span><span class="decl"><span class="istickedoff">setContext c = modifyTS (\st -&gt; st { _curContext = <span class="nottickedoff">c</span> })</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>------------------------------------------------------------------------------
<span class="lineno">  227 </span>-- | Gets the current context
<span class="lineno">  228 </span>getContext :: Monad m =&gt; TemplateMonad m TPath
<span class="lineno">  229 </span><span class="decl"><span class="nottickedoff">getContext = getsTS _curContext</span></span>
<span class="lineno">  230 </span>  
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>------------------------------------------------------------------------------
<span class="lineno">  233 </span>-- | Performs splice processing on a single node.
<span class="lineno">  234 </span>runNode :: Monad m =&gt; Node -&gt; Splice m
<span class="lineno">  235 </span><span class="decl"><span class="istickedoff">runNode n@(X.Text _)          = return [n]</span>
<span class="lineno">  236 </span><span class="spaces"></span><span class="istickedoff">runNode n@(X.Element nm at ch) = do</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- liftM (lookupSplice nm) getTS</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">maybe runChildren (recurseSplice n) s</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">runChildren = do</span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="istickedoff">newKids &lt;- runNodeList ch</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">newAtts &lt;- mapM attSubst at</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">return [X.Element nm newAtts newKids]</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>------------------------------------------------------------------------------
<span class="lineno">  248 </span>-- | Helper function for substituting a parsed attribute into an attribute
<span class="lineno">  249 </span>-- tuple.
<span class="lineno">  250 </span>attSubst :: (Monad m) =&gt; (t, ByteString) -&gt; TemplateMonad m (t, ByteString)
<span class="lineno">  251 </span><span class="decl"><span class="istickedoff">attSubst (n,v) = do</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">v' &lt;- parseAtt v</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">return (n,v')</span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>------------------------------------------------------------------------------
<span class="lineno">  257 </span>-- | Parses an attribute for any identifier expressions and performs
<span class="lineno">  258 </span>-- appropriate substitution.
<span class="lineno">  259 </span>parseAtt :: (Monad m) =&gt; ByteString -&gt; TemplateMonad m ByteString
<span class="lineno">  260 </span><span class="decl"><span class="istickedoff">parseAtt bs = do</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">let ast = case AP.feed (AP.parse attParser bs) &quot;&quot; of</span>
<span class="lineno">  262 </span><span class="spaces">            </span><span class="istickedoff">(AP.Fail _ _ _) -&gt; []</span>
<span class="lineno">  263 </span><span class="spaces">            </span><span class="istickedoff">(AP.Done _ res) -&gt; res</span>
<span class="lineno">  264 </span><span class="spaces">            </span><span class="istickedoff">(AP.Partial _)  -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">chunks &lt;- mapM cvt ast</span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">return $ B.concat chunks</span>
<span class="lineno">  267 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">cvt (Literal x) = return x</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">cvt (Ident x) = getAttributeSplice x</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>------------------------------------------------------------------------------
<span class="lineno">  273 </span>-- | AST to hold attribute parsing structure.  This is necessary because
<span class="lineno">  274 </span>-- attoparsec doesn't support parsers running in another monad.
<span class="lineno">  275 </span>data AttAST = Literal ByteString |
<span class="lineno">  276 </span>              Ident ByteString
<span class="lineno">  277 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>)
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>------------------------------------------------------------------------------
<span class="lineno">  281 </span>-- | Parser for attribute variable substitution.
<span class="lineno">  282 </span>attParser :: AP.Parser [AttAST]
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">attParser = AP.many1 (identParser &lt;|&gt; litParser)</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">escChar = (AP.char '\\' *&gt; AP.anyChar) &lt;|&gt;</span>
<span class="lineno">  286 </span><span class="spaces">              </span><span class="istickedoff">AP.satisfy (AP.notInClass &quot;\\$&quot;)</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">litParser = Literal &lt;$&gt; (B.pack &lt;$&gt; AP.many1 escChar)</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">identParser = AP.string &quot;$(&quot; *&gt;</span>
<span class="lineno">  289 </span><span class="spaces">        </span><span class="istickedoff">(Ident &lt;$&gt; AP.takeWhile (/=')')) &lt;* AP.string &quot;)&quot;</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>------------------------------------------------------------------------------
<span class="lineno">  293 </span>-- | Get's the attribute value.  If the splice's result list contains non-text
<span class="lineno">  294 </span>-- nodes, this will translate them into text nodes with textContent and
<span class="lineno">  295 </span>-- concatenate them together.
<span class="lineno">  296 </span>--
<span class="lineno">  297 </span>-- Originally, this only took the first node from the splices's result list,
<span class="lineno">  298 </span>-- and only if it was a text node. This caused problems when the splice's
<span class="lineno">  299 </span>-- result contained HTML entities, as they would split a text node. This was
<span class="lineno">  300 </span>-- then fixed to take the first consecutive bunch of text nodes, and return
<span class="lineno">  301 </span>-- their concatenation. This was seen as more useful than throwing an error,
<span class="lineno">  302 </span>-- and more intuitive than trying to render all the nodes as text.
<span class="lineno">  303 </span>-- 
<span class="lineno">  304 </span>-- However, it was decided in the end to render all the nodes as text, and
<span class="lineno">  305 </span>-- then concatenate them. If a splice returned
<span class="lineno">  306 </span>-- \&quot;some \&lt;b\&gt;text\&lt;\/b\&gt; foobar\&quot;, the user would almost certainly want
<span class="lineno">  307 </span>-- \&quot;some text foobar\&quot; to be rendered, and Heist would probably seem
<span class="lineno">  308 </span>-- annoyingly limited for not being able to do this. If the user really did
<span class="lineno">  309 </span>-- want it to render \&quot;some \&quot;, it would probably be easier for them to
<span class="lineno">  310 </span>-- accept that they were silly to pass more than that to be substituted than
<span class="lineno">  311 </span>-- it would be for the former user to accept that
<span class="lineno">  312 </span>-- \&quot;some \&lt;b\&gt;text\&lt;\/b\&gt; foobar\&quot; is being rendered as \&quot;some \&quot; because
<span class="lineno">  313 </span>-- it's \&quot;more intuitive\&quot;.
<span class="lineno">  314 </span>getAttributeSplice :: Monad m =&gt; ByteString -&gt; TemplateMonad m ByteString
<span class="lineno">  315 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">getAttributeSplice name = do</span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- liftM (lookupSplice name) getTS</span>
<span class="lineno">  317 </span><span class="spaces">    </span><span class="istickedoff">nodes &lt;- maybe (return []) id s</span>
<span class="lineno">  318 </span><span class="spaces">    </span><span class="istickedoff">return $ B.concat $ map X.textContent nodes</span></span></span>
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>------------------------------------------------------------------------------
<span class="lineno">  321 </span>-- | Performs splice processing on a list of nodes.
<span class="lineno">  322 </span>runNodeList :: Monad m =&gt; [Node] -&gt; Splice m
<span class="lineno">  323 </span><span class="decl"><span class="istickedoff">runNodeList nodes = liftM concat $ sequence (map runNode nodes)</span></span>
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>------------------------------------------------------------------------------
<span class="lineno">  327 </span>-- | The maximum recursion depth.  (Used to prevent infinite loops.)
<span class="lineno">  328 </span>mAX_RECURSION_DEPTH :: Int
<span class="lineno">  329 </span><span class="decl"><span class="istickedoff">mAX_RECURSION_DEPTH = 50</span></span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>------------------------------------------------------------------------------
<span class="lineno">  333 </span>-- | Checks the recursion flag and recurses accordingly.  Does not recurse
<span class="lineno">  334 </span>-- deeper than mAX_RECURSION_DEPTH to avoid infinite loops.
<span class="lineno">  335 </span>recurseSplice :: Monad m =&gt; Node -&gt; Splice m -&gt; Splice m
<span class="lineno">  336 </span><span class="decl"><span class="istickedoff">recurseSplice node splice = do</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff">result &lt;- localParamNode (const node) splice</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="istickedoff">ts' &lt;- getTS</span>
<span class="lineno">  339 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">_recurse ts' &amp;&amp; _recursionDepth ts' &lt; mAX_RECURSION_DEPTH</span></span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="istickedoff">then do modRecursionDepth <span class="nottickedoff">(+1)</span></span>
<span class="lineno">  341 </span><span class="spaces">                </span><span class="istickedoff">res &lt;- runNodeList result</span>
<span class="lineno">  342 </span><span class="spaces">                </span><span class="istickedoff">restoreTS ts'</span>
<span class="lineno">  343 </span><span class="spaces">                </span><span class="istickedoff">return res</span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="istickedoff">else <span class="nottickedoff">return result</span></span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">modRecursionDepth :: Monad m =&gt; (Int -&gt; Int) -&gt; TemplateMonad m ()</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff">modRecursionDepth f =</span>
<span class="lineno">  348 </span><span class="spaces">        </span><span class="istickedoff">modifyTS (\st -&gt; st { _recursionDepth = <span class="nottickedoff">f (_recursionDepth st)</span> })</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>------------------------------------------------------------------------------
<span class="lineno">  352 </span>-- | Looks up a template name runs a TemplateMonad computation on it.
<span class="lineno">  353 </span>lookupAndRun :: Monad m
<span class="lineno">  354 </span>             =&gt; ByteString
<span class="lineno">  355 </span>             -&gt; ((InternalTemplate, TPath) -&gt; TemplateMonad m (Maybe a))
<span class="lineno">  356 </span>             -&gt; TemplateMonad m (Maybe a)
<span class="lineno">  357 </span><span class="decl"><span class="istickedoff">lookupAndRun name k = do</span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">ts &lt;- getTS</span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="istickedoff">maybe (return Nothing) k</span>
<span class="lineno">  360 </span><span class="spaces">          </span><span class="istickedoff">(lookupTemplate name ts)</span></span>
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>------------------------------------------------------------------------------
<span class="lineno">  364 </span>-- | Looks up a template name evaluates it by calling runNodeList.
<span class="lineno">  365 </span>evalTemplate :: Monad m
<span class="lineno">  366 </span>            =&gt; ByteString
<span class="lineno">  367 </span>            -&gt; TemplateMonad m (Maybe Template)
<span class="lineno">  368 </span><span class="decl"><span class="nottickedoff">evalTemplate name = lookupAndRun name</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="nottickedoff">(\(t,ctx) -&gt; do</span>
<span class="lineno">  370 </span><span class="spaces">        </span><span class="nottickedoff">ts &lt;- getTS</span>
<span class="lineno">  371 </span><span class="spaces">        </span><span class="nottickedoff">putTS (ts {_curContext = ctx})</span>
<span class="lineno">  372 </span><span class="spaces">        </span><span class="nottickedoff">res &lt;- runNodeList $ _itNodes t</span>
<span class="lineno">  373 </span><span class="spaces">        </span><span class="nottickedoff">restoreTS ts</span>
<span class="lineno">  374 </span><span class="spaces">        </span><span class="nottickedoff">return $ Just res)</span></span>
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>------------------------------------------------------------------------------
<span class="lineno">  378 </span>-- | Looks up a template name evaluates it by calling runNodeList.  This also
<span class="lineno">  379 </span>-- executes pre- and post-run hooks and adds the doctype.
<span class="lineno">  380 </span>evalWithHooks :: Monad m
<span class="lineno">  381 </span>            =&gt; ByteString
<span class="lineno">  382 </span>            -&gt; TemplateMonad m (Maybe Template)
<span class="lineno">  383 </span><span class="decl"><span class="istickedoff">evalWithHooks name = lookupAndRun name</span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="istickedoff">(\(t,ctx) -&gt; do</span>
<span class="lineno">  385 </span><span class="spaces">        </span><span class="istickedoff">addDoctype $ maybeToList $ _itDoctype t</span>
<span class="lineno">  386 </span><span class="spaces">        </span><span class="istickedoff">ts &lt;- getTS</span>
<span class="lineno">  387 </span><span class="spaces">        </span><span class="istickedoff">nodes &lt;- lift $ _preRunHook ts $ _itNodes t</span>
<span class="lineno">  388 </span><span class="spaces">        </span><span class="istickedoff">putTS (ts {_curContext = <span class="nottickedoff">ctx</span>})</span>
<span class="lineno">  389 </span><span class="spaces">        </span><span class="istickedoff">res &lt;- runNodeList nodes</span>
<span class="lineno">  390 </span><span class="spaces">        </span><span class="istickedoff">restoreTS <span class="nottickedoff">ts</span></span>
<span class="lineno">  391 </span><span class="spaces">        </span><span class="istickedoff">return . Just =&lt;&lt; lift (_postRunHook ts res))</span></span>
<span class="lineno">  392 </span>
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>------------------------------------------------------------------------------
<span class="lineno">  395 </span>-- | Binds a list of constant string splices.
<span class="lineno">  396 </span>bindStrings :: Monad m
<span class="lineno">  397 </span>            =&gt; [(ByteString, ByteString)]
<span class="lineno">  398 </span>            -&gt; TemplateState m
<span class="lineno">  399 </span>            -&gt; TemplateState m
<span class="lineno">  400 </span><span class="decl"><span class="nottickedoff">bindStrings pairs ts = foldr (uncurry bindString) ts pairs</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>------------------------------------------------------------------------------
<span class="lineno">  404 </span>-- | Binds a single constant string splice.
<span class="lineno">  405 </span>bindString :: Monad m
<span class="lineno">  406 </span>            =&gt; ByteString
<span class="lineno">  407 </span>            -&gt; ByteString
<span class="lineno">  408 </span>            -&gt; TemplateState m
<span class="lineno">  409 </span>            -&gt; TemplateState m
<span class="lineno">  410 </span><span class="decl"><span class="nottickedoff">bindString n v = bindSplice n $ return [X.Text v]</span></span>
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>------------------------------------------------------------------------------
<span class="lineno">  414 </span>-- | Renders a template with the specified parameters.  This is the function
<span class="lineno">  415 </span>-- to use when you want to &quot;call&quot; a template and pass in parameters from code.
<span class="lineno">  416 </span>callTemplate :: Monad m
<span class="lineno">  417 </span>             =&gt; ByteString                 -- ^ The name of the template
<span class="lineno">  418 </span>             -&gt; [(ByteString, ByteString)] -- ^ Association list of
<span class="lineno">  419 </span>                                           -- (name,value) parameter pairs
<span class="lineno">  420 </span>             -&gt; TemplateMonad m (Maybe Template)
<span class="lineno">  421 </span><span class="decl"><span class="nottickedoff">callTemplate name params = do</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="nottickedoff">modifyTS $ bindStrings params</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="nottickedoff">evalTemplate name</span></span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>------------------------------------------------------------------------------
<span class="lineno">  427 </span>-- | Converts a Template to an InternalTemplate.  This can only be done inside
<span class="lineno">  428 </span>-- TemplateMonad where the doctype is available.
<span class="lineno">  429 </span>toInternalTemplate :: Monad m =&gt; Template -&gt; TemplateMonad m InternalTemplate
<span class="lineno">  430 </span><span class="decl"><span class="istickedoff">toInternalTemplate t = do</span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="istickedoff">dts &lt;- getsTS _doctypes</span>
<span class="lineno">  432 </span><span class="spaces">    </span><span class="istickedoff">return $ InternalTemplate {</span>
<span class="lineno">  433 </span><span class="spaces">        </span><span class="istickedoff">_itDoctype = listToMaybe dts,</span>
<span class="lineno">  434 </span><span class="spaces">        </span><span class="istickedoff">_itNodes = t</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">}</span></span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>
<span class="lineno">  438 </span>------------------------------------------------------------------------------
<span class="lineno">  439 </span>-- | Renders an internal template by prepending the appropriate doctype.
<span class="lineno">  440 </span>renderInternal :: Monad m =&gt; InternalTemplate -&gt; TemplateMonad m ByteString
<span class="lineno">  441 </span><span class="decl"><span class="istickedoff">renderInternal (InternalTemplate dt nodes) =</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff">return $ maybe bs (flip B.append bs) dt</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">bs = formatList' nodes</span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>
<span class="lineno">  447 </span>------------------------------------------------------------------------------
<span class="lineno">  448 </span>-- | Renders a template from the specified TemplateState.
<span class="lineno">  449 </span>renderTemplate :: Monad m
<span class="lineno">  450 </span>               =&gt; TemplateState m
<span class="lineno">  451 </span>               -&gt; ByteString
<span class="lineno">  452 </span>               -&gt; m (Maybe ByteString)
<span class="lineno">  453 </span><span class="decl"><span class="istickedoff">renderTemplate ts name = do</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">evalTemplateMonad</span>
<span class="lineno">  455 </span><span class="spaces">        </span><span class="istickedoff">(do mt &lt;- evalWithHooks name</span>
<span class="lineno">  456 </span><span class="spaces">            </span><span class="istickedoff">maybe (return Nothing)</span>
<span class="lineno">  457 </span><span class="spaces">                </span><span class="istickedoff">(\t -&gt; liftM Just $ renderInternal =&lt;&lt; toInternalTemplate t)</span>
<span class="lineno">  458 </span><span class="spaces">                </span><span class="istickedoff">mt</span>
<span class="lineno">  459 </span><span class="spaces">        </span><span class="istickedoff">) <span class="nottickedoff">(X.Text &quot;&quot;)</span> ts</span></span>
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>------------------------------------------------------------------------------
<span class="lineno">  462 </span>-- Template loading
<span class="lineno">  463 </span>------------------------------------------------------------------------------
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>-- | Turns an in-memory XML/XHTML bytestring into a (doctype,'[Node]') pair.
<span class="lineno">  466 </span>parseDoc :: ByteString -&gt; IO (Either String (Maybe ByteString,[Node]))
<span class="lineno">  467 </span><span class="decl"><span class="istickedoff">parseDoc bs = do</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">let (doctype,rest) = extractDoctype bs</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">let wrap b = B.concat [&quot;&lt;snap:root&gt;\n&quot;, b, &quot;\n&lt;/snap:root&gt;&quot;]</span>
<span class="lineno">  470 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">return $</span>
<span class="lineno">  472 </span><span class="spaces">      </span><span class="istickedoff">mapRight (\n -&gt; (doctype,X.getChildren n)) $</span>
<span class="lineno">  473 </span><span class="spaces">      </span><span class="istickedoff">mapLeft <span class="nottickedoff">genErrorMsg</span> $</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">X.parse' heistExpatOptions (wrap rest)</span>
<span class="lineno">  475 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">genErrorMsg (X.XMLParseError str loc) = locMsg loc ++ &quot;: &quot; ++ translate str</span></span>
<span class="lineno">  478 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">locMsg (X.XMLParseLocation line col _ _) =</span></span>
<span class="lineno">  480 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;(line &quot; ++ show (line-1) ++ &quot;, col &quot; ++ show col ++ &quot;)&quot;</span></span>
<span class="lineno">  481 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  482 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">translate &quot;junk after document element&quot; = &quot;document must have a single root element&quot;</span></span>
<span class="lineno">  483 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">translate s = s</span></span></span>
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>-- | Reads an XML document from disk.
<span class="lineno">  487 </span>getDoc :: String -&gt; IO (Either String InternalTemplate)
<span class="lineno">  488 </span><span class="decl"><span class="istickedoff">getDoc f = do</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">bs &lt;- catch (liftM Right $ B.readFile f)</span>
<span class="lineno">  490 </span><span class="spaces">                </span><span class="istickedoff">(\(e::SomeException) -&gt; return $ Left $ <span class="nottickedoff">show e</span>)</span>
<span class="lineno">  491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  492 </span><span class="spaces">    </span><span class="istickedoff">d' &lt;- either (return . Left)</span>
<span class="lineno">  493 </span><span class="spaces">                 </span><span class="istickedoff">parseDoc</span>
<span class="lineno">  494 </span><span class="spaces">                 </span><span class="istickedoff">bs</span>
<span class="lineno">  495 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  496 </span><span class="spaces">    </span><span class="istickedoff">let d = mapLeft <span class="nottickedoff">(\s -&gt; f ++ &quot; &quot; ++ s)</span> d'</span>
<span class="lineno">  497 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  498 </span><span class="spaces">    </span><span class="istickedoff">return $ either Left</span>
<span class="lineno">  499 </span><span class="spaces">               </span><span class="istickedoff">(\(doctype, nodes) -&gt; Right $ InternalTemplate {</span>
<span class="lineno">  500 </span><span class="spaces">                    </span><span class="istickedoff">_itDoctype = doctype,</span>
<span class="lineno">  501 </span><span class="spaces">                    </span><span class="istickedoff">_itNodes = nodes</span>
<span class="lineno">  502 </span><span class="spaces">                </span><span class="istickedoff">})</span>
<span class="lineno">  503 </span><span class="spaces">               </span><span class="istickedoff">d</span></span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>
<span class="lineno">  506 </span>------------------------------------------------------------------------------
<span class="lineno">  507 </span>-- | Checks whether the bytestring has a doctype.
<span class="lineno">  508 </span>hasDoctype :: ByteString -&gt; Bool
<span class="lineno">  509 </span><span class="decl"><span class="istickedoff">hasDoctype bs = &quot;&lt;!DOCTYPE&quot; `B.isPrefixOf` bs</span></span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>------------------------------------------------------------------------------
<span class="lineno">  513 </span>-- | Converts a ByteString into a tuple containing a possible doctype
<span class="lineno">  514 </span>-- ByteString and the rest of the document.
<span class="lineno">  515 </span>extractDoctype :: ByteString -&gt; (Maybe ByteString, ByteString)
<span class="lineno">  516 </span><span class="decl"><span class="istickedoff">extractDoctype bs = </span>
<span class="lineno">  517 </span><span class="spaces">    </span><span class="istickedoff">if hasDoctype bs</span>
<span class="lineno">  518 </span><span class="spaces">        </span><span class="istickedoff">then (Just $ B.snoc (B.takeWhile p bs) '&gt;',B.tail $ B.dropWhile p bs)</span>
<span class="lineno">  519 </span><span class="spaces">        </span><span class="istickedoff">else (Nothing, bs)</span>
<span class="lineno">  520 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="istickedoff">p = (/='&gt;')</span></span>
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>------------------------------------------------------------------------------
<span class="lineno">  524 </span>mapLeft :: (a -&gt; b) -&gt; Either a c -&gt; Either b c
<span class="lineno">  525 </span><span class="decl"><span class="istickedoff">mapLeft g = either (Left . <span class="nottickedoff">g</span>) Right</span></span>
<span class="lineno">  526 </span>mapRight :: (b -&gt; c) -&gt; Either a b -&gt; Either a c
<span class="lineno">  527 </span><span class="decl"><span class="istickedoff">mapRight g = either <span class="nottickedoff">Left</span> (Right . g)</span></span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>
<span class="lineno">  530 </span>------------------------------------------------------------------------------
<span class="lineno">  531 </span>-- | Loads a template with the specified path and filename.  The
<span class="lineno">  532 </span>-- template is only loaded if it has a &quot;.tpl&quot; extension.
<span class="lineno">  533 </span>loadTemplate :: String -- ^ path of the template root
<span class="lineno">  534 </span>             -&gt; String -- ^ full file path (includes the template root)
<span class="lineno">  535 </span>             -&gt; IO [Either String (TPath, InternalTemplate)] --TemplateMap
<span class="lineno">  536 </span><span class="decl"><span class="istickedoff">loadTemplate templateRoot fname</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">| &quot;.tpl&quot; `isSuffixOf` fname = do</span>
<span class="lineno">  538 </span><span class="spaces">        </span><span class="istickedoff">c &lt;- getDoc fname</span>
<span class="lineno">  539 </span><span class="spaces">        </span><span class="istickedoff">return [fmap (\t -&gt; (splitLocalPath $ B.pack tName, t)) c]</span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return []</span>
<span class="lineno">  541 </span><span class="spaces">  </span><span class="istickedoff">where -- tName is path relative to the template root directory</span>
<span class="lineno">  542 </span><span class="spaces">        </span><span class="istickedoff">correction = if <span class="tickonlyfalse">last templateRoot == '/'</span> then <span class="nottickedoff">0</span> else 1</span>
<span class="lineno">  543 </span><span class="spaces">        </span><span class="istickedoff">tName = drop ((length templateRoot)+correction) $</span>
<span class="lineno">  544 </span><span class="spaces">                </span><span class="istickedoff">-- We're only dropping the template root, not the whole path</span>
<span class="lineno">  545 </span><span class="spaces">                </span><span class="istickedoff">take ((length fname) - 4) fname</span></span>
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>------------------------------------------------------------------------------
<span class="lineno">  549 </span>-- | Traverses the specified directory structure and builds a
<span class="lineno">  550 </span>-- TemplateState by loading all the files with a &quot;.tpl&quot; extension.
<span class="lineno">  551 </span>loadTemplates :: Monad m =&gt; FilePath -&gt; TemplateState m -&gt; IO (Either String (TemplateState m))
<span class="lineno">  552 </span><span class="decl"><span class="istickedoff">loadTemplates dir ts = do</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">d &lt;- readDirectoryWith (loadTemplate dir) dir</span>
<span class="lineno">  554 </span><span class="spaces">    </span><span class="istickedoff">let tlist = F.fold (free d)</span>
<span class="lineno">  555 </span><span class="spaces">        </span><span class="istickedoff">errs = lefts tlist</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="istickedoff">case errs of</span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; liftM Right $ foldM loadHook ts $ rights tlist</span>
<span class="lineno">  558 </span><span class="spaces">        </span><span class="istickedoff">_  -&gt; <span class="nottickedoff">return $ Left $ unlines errs</span></span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>
<span class="lineno">  561 </span>------------------------------------------------------------------------------
<span class="lineno">  562 </span>-- | Reversed list of directories.  This holds the path to the template
<span class="lineno">  563 </span>runHookInternal :: Monad m =&gt; (Template -&gt; m Template)
<span class="lineno">  564 </span>                -&gt; InternalTemplate
<span class="lineno">  565 </span>                -&gt; m InternalTemplate
<span class="lineno">  566 </span><span class="decl"><span class="istickedoff">runHookInternal f t = do</span>
<span class="lineno">  567 </span><span class="spaces">    </span><span class="istickedoff">n &lt;- f $ _itNodes t</span>
<span class="lineno">  568 </span><span class="spaces">    </span><span class="istickedoff">return $ t { _itNodes = n }</span></span>
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>
<span class="lineno">  571 </span>------------------------------------------------------------------------------
<span class="lineno">  572 </span>-- | Runs the onLoad hook on the template and returns the `TemplateState`
<span class="lineno">  573 </span>-- with the result inserted.
<span class="lineno">  574 </span>loadHook :: Monad m =&gt; TemplateState m -&gt; (TPath, InternalTemplate) -&gt; IO (TemplateState m)
<span class="lineno">  575 </span><span class="decl"><span class="istickedoff">loadHook ts (tp, t) = do</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="istickedoff">t' &lt;- runHookInternal (_onLoadHook ts) t</span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">return $ insertTemplate tp t' ts</span></span>
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>
<span class="lineno">  580 </span>------------------------------------------------------------------------------
<span class="lineno">  581 </span>-- These are here until we can get them into hexpat.
<span class="lineno">  582 </span>------------------------------------------------------------------------------
<span class="lineno">  583 </span>
<span class="lineno">  584 </span>formatList :: (X.GenericXMLString tag, X.GenericXMLString text) =&gt;
<span class="lineno">  585 </span>              [X.Node tag text]
<span class="lineno">  586 </span>           -&gt; L.ByteString
<span class="lineno">  587 </span><span class="decl"><span class="istickedoff">formatList nodes = foldl L.append L.empty $ map formatNode nodes</span></span>
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>formatList' :: (X.GenericXMLString tag, X.GenericXMLString text) =&gt;
<span class="lineno">  590 </span>               [X.Node tag text]
<span class="lineno">  591 </span>            -&gt; B.ByteString
<span class="lineno">  592 </span><span class="decl"><span class="istickedoff">formatList' = B.concat . L.toChunks . formatList</span></span>
<span class="lineno">  593 </span>

</pre>
</html>
