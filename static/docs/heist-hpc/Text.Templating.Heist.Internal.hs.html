<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    2 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    3 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>module Text.Templating.Heist.Internal where
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>------------------------------------------------------------------------------
<span class="lineno">    8 </span>import           Control.Exception (SomeException)
<span class="lineno">    9 </span>import           Control.Monad.CatchIO
<span class="lineno">   10 </span>import           Control.Monad.RWS.Strict
<span class="lineno">   11 </span>import           Data.ByteString.Char8 (ByteString)
<span class="lineno">   12 </span>import qualified Data.ByteString.Char8 as B
<span class="lineno">   13 </span>import qualified Data.ByteString.Lazy as L
<span class="lineno">   14 </span>import           Data.Either
<span class="lineno">   15 </span>import qualified Data.Foldable as F
<span class="lineno">   16 </span>import           Data.List
<span class="lineno">   17 </span>import qualified Data.Map as Map
<span class="lineno">   18 </span>import           Data.Map (Map)
<span class="lineno">   19 </span>import           Prelude hiding (catch)
<span class="lineno">   20 </span>import           System.Directory.Tree hiding (name)
<span class="lineno">   21 </span>import           Text.XML.Expat.Format
<span class="lineno">   22 </span>import qualified Text.XML.Expat.Tree as X
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>------------------------------------------------------------------------------
<span class="lineno">   25 </span>import           Text.Templating.Heist.Constants
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>------------------------------------------------------------------------------
<span class="lineno">   28 </span>-- Types
<span class="lineno">   29 </span>------------------------------------------------------------------------------
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>-- | Heist templates are XML documents. The hexpat library is polymorphic over
<span class="lineno">   32 </span>-- the type of strings, so here we define a 'Node' alias to fix the string
<span class="lineno">   33 </span>-- types of the tag names and tag bodies to 'ByteString'.
<span class="lineno">   34 </span>type Node = X.Node ByteString ByteString
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>------------------------------------------------------------------------------
<span class="lineno">   38 </span>-- | A 'Template' is a forest of XML nodes.
<span class="lineno">   39 </span>type Template = [Node]
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>------------------------------------------------------------------------------
<span class="lineno">   43 </span>-- | Reversed list of directories
<span class="lineno">   44 </span>type TPath = [ByteString]
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>------------------------------------------------------------------------------
<span class="lineno">   48 </span>type TemplateMap = Map TPath Template
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>------------------------------------------------------------------------------
<span class="lineno">   52 </span>-- | Holds all the state information needed for template processing:
<span class="lineno">   53 </span>--
<span class="lineno">   54 </span>--     * a collection of named templates. If you use the @\&lt;apply
<span class="lineno">   55 </span>--       template=\&quot;foo\&quot;\&gt;@ tag to include another template by name, @\&quot;foo\&quot;@
<span class="lineno">   56 </span>--       is looked up in here.
<span class="lineno">   57 </span>--
<span class="lineno">   58 </span>--     * the mapping from tag names to 'Splice's.
<span class="lineno">   59 </span>--
<span class="lineno">   60 </span>--     * a flag to control whether we will recurse during splice processing.
<span class="lineno">   61 </span>--
<span class="lineno">   62 </span>-- We'll illustrate the recursion flag with a small example template:
<span class="lineno">   63 </span>--
<span class="lineno">   64 </span>--   &gt; &lt;foo&gt;
<span class="lineno">   65 </span>--   &gt;   &lt;bar&gt;
<span class="lineno">   66 </span>--   &gt;     ...
<span class="lineno">   67 </span>--   &gt;   &lt;/bar&gt;
<span class="lineno">   68 </span>--   &gt; &lt;/foo&gt;
<span class="lineno">   69 </span>--
<span class="lineno">   70 </span>-- Assume that @\&quot;foo\&quot;@ is bound to a splice procedure. Running the @foo@
<span class="lineno">   71 </span>-- splice will result in a list of nodes @L@; if the recursion flag is on we
<span class="lineno">   72 </span>-- will recursively scan @L@ for splices, otherwise @L@ will be included in the
<span class="lineno">   73 </span>-- output verbatim.
<span class="lineno">   74 </span>data <span class="istickedoff">TemplateState</span> m = TemplateState {
<span class="lineno">   75 </span>    -- | A mapping of splice names to splice actions
<span class="lineno">   76 </span>      _spliceMap      :: SpliceMap m
<span class="lineno">   77 </span>    -- | A mapping of template names to templates
<span class="lineno">   78 </span>    , _templateMap    :: TemplateMap
<span class="lineno">   79 </span>    -- | A flag to control splice recursion
<span class="lineno">   80 </span>    , _recurse        :: Bool
<span class="lineno">   81 </span>    , _curContext     :: TPath
<span class="lineno">   82 </span>    , _recursionDepth :: Int
<span class="lineno">   83 </span>    , _onLoadHook     :: Template -&gt; IO Template
<span class="lineno">   84 </span>    , _preRunHook     :: Template -&gt; m Template
<span class="lineno">   85 </span>    , _postRunHook    :: Template -&gt; m Template
<span class="lineno">   86 </span>}
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>------------------------------------------------------------------------------
<span class="lineno">   90 </span>instance <span class="istickedoff">Eq (TemplateState m)</span> where
<span class="lineno">   91 </span>    <span class="decl"><span class="istickedoff">a == b = (_recurse a == _recurse b) &amp;&amp;</span>
<span class="lineno">   92 </span><span class="spaces">             </span><span class="istickedoff">(_templateMap a == _templateMap b) &amp;&amp;</span>
<span class="lineno">   93 </span><span class="spaces">             </span><span class="istickedoff">(_curContext a == _curContext b)</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>------------------------------------------------------------------------------
<span class="lineno">   97 </span>-- | 'TemplateMonad' is a monad transformer that gives you access to the 'Node'
<span class="lineno">   98 </span>--   being processed (using the 'MonadReader' instance) as well as holding the
<span class="lineno">   99 </span>--   'TemplateState' that contains splice and template mappings (accessible
<span class="lineno">  100 </span>--   using the 'MonadState' instance.
<span class="lineno">  101 </span>newtype TemplateMonad m a = TemplateMonad (RWST Node () (TemplateState m) m a)
<span class="lineno">  102 </span>  deriving ( Monad
<span class="lineno">  103 </span>           , MonadIO
<span class="lineno">  104 </span>           , MonadCatchIO
<span class="lineno">  105 </span>           , MonadReader Node
<span class="lineno">  106 </span>           , MonadState (TemplateState m) )
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>------------------------------------------------------------------------------
<span class="lineno">  110 </span>instance <span class="istickedoff">(Monad m) =&gt; Monoid (TemplateState m)</span> where
<span class="lineno">  111 </span>    <span class="decl"><span class="istickedoff">mempty = TemplateState Map.empty Map.empty True [] <span class="nottickedoff">0</span></span>
<span class="lineno">  112 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">return</span> <span class="nottickedoff">return</span> <span class="nottickedoff">return</span></span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>    <span class="decl"><span class="istickedoff">(TemplateState s1 t1 r1 _ d1 o1 b1 a1) `mappend`</span>
<span class="lineno">  115 </span><span class="spaces">        </span><span class="istickedoff">(TemplateState s2 t2 r2 c2 d2 o2 b2 a2) =</span>
<span class="lineno">  116 </span><span class="spaces">        </span><span class="istickedoff">TemplateState <span class="nottickedoff">s</span> t r c2 <span class="nottickedoff">d</span> <span class="nottickedoff">(o1 &gt;=&gt; o2)</span> <span class="nottickedoff">(b1 &gt;=&gt; b2)</span> <span class="nottickedoff">(a1 &gt;=&gt; a2)</span></span>
<span class="lineno">  117 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  118 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">s = s1 `mappend` s2</span></span>
<span class="lineno">  119 </span><span class="spaces">        </span><span class="istickedoff">t = t1 `mappend` t2</span>
<span class="lineno">  120 </span><span class="spaces">        </span><span class="istickedoff">r = r1 &amp;&amp; r2</span>
<span class="lineno">  121 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">d = max d1 d2</span></span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>------------------------------------------------------------------------------
<span class="lineno">  125 </span>instance MonadTrans TemplateMonad where
<span class="lineno">  126 </span>  <span class="decl"><span class="nottickedoff">lift = TemplateMonad . lift</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>------------------------------------------------------------------------------
<span class="lineno">  129 </span>-- | A Splice is a TemplateMonad computation that returns [Node].
<span class="lineno">  130 </span>type Splice m = TemplateMonad m Template
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>------------------------------------------------------------------------------
<span class="lineno">  134 </span>-- | SpliceMap associates a name and a Splice.
<span class="lineno">  135 </span>type SpliceMap m = Map ByteString (Splice m)
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>------------------------------------------------------------------------------
<span class="lineno">  139 </span>-- TemplateState functions
<span class="lineno">  140 </span>------------------------------------------------------------------------------
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>------------------------------------------------------------------------------
<span class="lineno">  144 </span>-- | Adds an on-load hook to a `TemplateState`.
<span class="lineno">  145 </span>addOnLoadHook :: (Monad m) =&gt;
<span class="lineno">  146 </span>                 (Template -&gt; IO Template)
<span class="lineno">  147 </span>              -&gt; TemplateState m
<span class="lineno">  148 </span>              -&gt; TemplateState m
<span class="lineno">  149 </span><span class="decl"><span class="nottickedoff">addOnLoadHook hook ts = ts { _onLoadHook = _onLoadHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>------------------------------------------------------------------------------
<span class="lineno">  153 </span>-- | Adds a pre-run hook to a `TemplateState`.
<span class="lineno">  154 </span>addPreRunHook :: (Monad m) =&gt;
<span class="lineno">  155 </span>                 (Template -&gt; m Template)
<span class="lineno">  156 </span>              -&gt; TemplateState m
<span class="lineno">  157 </span>              -&gt; TemplateState m
<span class="lineno">  158 </span><span class="decl"><span class="nottickedoff">addPreRunHook hook ts = ts { _preRunHook = _preRunHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>------------------------------------------------------------------------------
<span class="lineno">  162 </span>-- | Adds a post-run hook to a `TemplateState`.
<span class="lineno">  163 </span>addPostRunHook :: (Monad m) =&gt;
<span class="lineno">  164 </span>                  (Template -&gt; m Template)
<span class="lineno">  165 </span>               -&gt; TemplateState m
<span class="lineno">  166 </span>               -&gt; TemplateState m
<span class="lineno">  167 </span><span class="decl"><span class="nottickedoff">addPostRunHook hook ts = ts { _postRunHook = _postRunHook ts &gt;=&gt; hook }</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>------------------------------------------------------------------------------
<span class="lineno">  171 </span>-- | Bind a new splice declaration to a tag name within a 'TemplateState'.
<span class="lineno">  172 </span>bindSplice :: Monad m =&gt;
<span class="lineno">  173 </span>              ByteString        -- ^ tag name
<span class="lineno">  174 </span>           -&gt; Splice m          -- ^ splice action
<span class="lineno">  175 </span>           -&gt; TemplateState m   -- ^ source state
<span class="lineno">  176 </span>           -&gt; TemplateState m
<span class="lineno">  177 </span><span class="decl"><span class="istickedoff">bindSplice n v ts = ts {_spliceMap = Map.insert n v (_spliceMap ts)}</span></span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>------------------------------------------------------------------------------
<span class="lineno">  181 </span>-- | Convenience function for looking up a splice.
<span class="lineno">  182 </span>lookupSplice :: Monad m =&gt;
<span class="lineno">  183 </span>                ByteString
<span class="lineno">  184 </span>             -&gt; TemplateState m
<span class="lineno">  185 </span>             -&gt; Maybe (Splice m)
<span class="lineno">  186 </span><span class="decl"><span class="istickedoff">lookupSplice nm ts = Map.lookup nm $ _spliceMap ts</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>------------------------------------------------------------------------------
<span class="lineno">  190 </span>-- | Converts a path into an array of the elements in reverse order.  If the
<span class="lineno">  191 </span>-- path is absolute, we need to remove the leading slash so the split doesn't
<span class="lineno">  192 </span>-- leave @\&quot;\&quot;@ as the last element of the TPath.
<span class="lineno">  193 </span>--
<span class="lineno">  194 </span>-- FIXME @\&quot;..\&quot;@ currently doesn't work in paths, the solution is non-trivial
<span class="lineno">  195 </span>splitPaths :: ByteString -&gt; TPath
<span class="lineno">  196 </span><span class="decl"><span class="istickedoff">splitPaths p = if B.null p then [] else (reverse $ B.split '/' path)</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">path = if B.head p == '/' then B.tail p else p</span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>------------------------------------------------------------------------------
<span class="lineno">  202 </span>-- | Does a single template lookup without cascading up.
<span class="lineno">  203 </span>singleLookup :: TemplateMap
<span class="lineno">  204 </span>             -&gt; TPath
<span class="lineno">  205 </span>             -&gt; ByteString
<span class="lineno">  206 </span>             -&gt; Maybe (Template, TPath)
<span class="lineno">  207 </span><span class="decl"><span class="istickedoff">singleLookup tm path name = fmap <span class="nottickedoff">(\a -&gt; (a,path))</span> $ Map.lookup (name:path) tm</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>------------------------------------------------------------------------------
<span class="lineno">  211 </span>-- | Searches for a template by looking in the full path then backing up into each
<span class="lineno">  212 </span>-- of the parent directories until the template is found.
<span class="lineno">  213 </span>traversePath :: TemplateMap
<span class="lineno">  214 </span>             -&gt; TPath
<span class="lineno">  215 </span>             -&gt; ByteString
<span class="lineno">  216 </span>             -&gt; Maybe (Template, TPath)
<span class="lineno">  217 </span><span class="decl"><span class="istickedoff">traversePath tm [] name = fmap (\a -&gt; (a,<span class="nottickedoff">[]</span>)) (Map.lookup [name] tm)</span>
<span class="lineno">  218 </span><span class="spaces"></span><span class="istickedoff">traversePath tm path name =</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">singleLookup tm path name `mplus`</span></span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">traversePath tm (tail path) name</span></span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>------------------------------------------------------------------------------
<span class="lineno">  224 </span>-- | Convenience function for looking up a template.
<span class="lineno">  225 </span>lookupTemplate :: Monad m =&gt;
<span class="lineno">  226 </span>                  ByteString
<span class="lineno">  227 </span>               -&gt; TemplateState m
<span class="lineno">  228 </span>               -&gt; Maybe (Template, TPath)
<span class="lineno">  229 </span><span class="decl"><span class="istickedoff">lookupTemplate nameStr ts = </span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">f (_templateMap ts) path name</span>
<span class="lineno">  231 </span><span class="spaces">  </span><span class="istickedoff">where (name:p) = case splitPaths nameStr of</span>
<span class="lineno">  232 </span><span class="spaces">                       </span><span class="istickedoff">[] -&gt; [&quot;&quot;]</span>
<span class="lineno">  233 </span><span class="spaces">                       </span><span class="istickedoff">ps -&gt; ps</span>
<span class="lineno">  234 </span><span class="spaces">        </span><span class="istickedoff">path = p ++ (_curContext ts)</span>
<span class="lineno">  235 </span><span class="spaces">        </span><span class="istickedoff">f = if '/' `B.elem` nameStr</span>
<span class="lineno">  236 </span><span class="spaces">                </span><span class="istickedoff">then singleLookup</span>
<span class="lineno">  237 </span><span class="spaces">                </span><span class="istickedoff">else traversePath</span></span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>------------------------------------------------------------------------------
<span class="lineno">  241 </span>-- | Sets the templateMap in a TemplateState.
<span class="lineno">  242 </span>setTemplates :: Monad m =&gt; TemplateMap -&gt; TemplateState m -&gt; TemplateState m
<span class="lineno">  243 </span><span class="decl"><span class="istickedoff">setTemplates m ts = ts { _templateMap = m }</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>------------------------------------------------------------------------------
<span class="lineno">  247 </span>-- | Adds a template to the template state.
<span class="lineno">  248 </span>insertTemplate :: Monad m =&gt;
<span class="lineno">  249 </span>               TPath
<span class="lineno">  250 </span>            -&gt; Template
<span class="lineno">  251 </span>            -&gt; TemplateState m
<span class="lineno">  252 </span>            -&gt; TemplateState m
<span class="lineno">  253 </span><span class="decl"><span class="istickedoff">insertTemplate p t st =</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">setTemplates (Map.insert p t (_templateMap st)) st</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>------------------------------------------------------------------------------
<span class="lineno">  258 </span>-- | Adds a template to the template state.
<span class="lineno">  259 </span>addTemplate :: Monad m =&gt;
<span class="lineno">  260 </span>               ByteString
<span class="lineno">  261 </span>            -&gt; Template
<span class="lineno">  262 </span>            -&gt; TemplateState m
<span class="lineno">  263 </span>            -&gt; TemplateState m
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">addTemplate n t st = insertTemplate (splitPaths n) t st</span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>------------------------------------------------------------------------------
<span class="lineno">  268 </span>-- | Gets the node currently being processed.
<span class="lineno">  269 </span>getParamNode :: Monad m =&gt; TemplateMonad m Node
<span class="lineno">  270 </span><span class="decl"><span class="istickedoff">getParamNode = ask</span></span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>------------------------------------------------------------------------------
<span class="lineno">  274 </span>-- | Stops the recursive processing of splices.
<span class="lineno">  275 </span>stopRecursion :: Monad m =&gt; TemplateMonad m ()
<span class="lineno">  276 </span><span class="decl"><span class="nottickedoff">stopRecursion = modify (\st -&gt; st { _recurse = False })</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>------------------------------------------------------------------------------
<span class="lineno">  280 </span>-- | Sets the current context
<span class="lineno">  281 </span>setContext :: Monad m =&gt; TPath -&gt; TemplateMonad m ()
<span class="lineno">  282 </span><span class="decl"><span class="istickedoff">setContext c = modify (\st -&gt; st { _curContext = <span class="nottickedoff">c</span> })</span></span>
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>------------------------------------------------------------------------------
<span class="lineno">  286 </span>-- | Gets the current context
<span class="lineno">  287 </span>getContext :: Monad m =&gt; TemplateMonad m TPath
<span class="lineno">  288 </span><span class="decl"><span class="nottickedoff">getContext = gets _curContext</span></span>
<span class="lineno">  289 </span>  
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>------------------------------------------------------------------------------
<span class="lineno">  292 </span>-- | Performs splice processing on a list of nodes.
<span class="lineno">  293 </span>runNodeList :: Monad m =&gt; [Node] -&gt; Splice m
<span class="lineno">  294 </span><span class="decl"><span class="istickedoff">runNodeList nodes = liftM concat $ sequence (map runNode nodes)</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>------------------------------------------------------------------------------
<span class="lineno">  298 </span>-- | Performs splice processing on a single node.
<span class="lineno">  299 </span>runNode :: Monad m =&gt; Node -&gt; Splice m
<span class="lineno">  300 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">runNode n@(X.Text _)          = return [n]</span>
<span class="lineno">  301 </span><span class="spaces"></span><span class="istickedoff">runNode n@(X.Element nm _ ch) = do</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- liftM (lookupSplice nm) get</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">maybe runChildren (recurseSplice n) s</span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">runChildren = do</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">newKids &lt;- runNodeList ch</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">return [X.modifyChildren (const newKids) n]</span></span></span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>------------------------------------------------------------------------------
<span class="lineno">  312 </span>-- | The maximum recursion depth.  (Used to prevent infinite loops.)
<span class="lineno">  313 </span>mAX_RECURSION_DEPTH :: Int
<span class="lineno">  314 </span><span class="decl"><span class="istickedoff">mAX_RECURSION_DEPTH = 20</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>------------------------------------------------------------------------------
<span class="lineno">  318 </span>-- | Checks the recursion flag and recurses accordingly.  Does not recurse
<span class="lineno">  319 </span>-- deeper than mAX_RECURSION_DEPTH to avoid infinite loops.
<span class="lineno">  320 </span>recurseSplice :: Monad m =&gt; Node -&gt; Splice m -&gt; Splice m
<span class="lineno">  321 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">recurseSplice node splice = do</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff">result &lt;- local (const node) splice</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff">ts' &lt;- get</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">_recurse ts' &amp;&amp; _recursionDepth ts' &lt; mAX_RECURSION_DEPTH</span></span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="istickedoff">then do modify (\st -&gt; st { _recursionDepth = <span class="nottickedoff">_recursionDepth st + 1</span> })</span>
<span class="lineno">  326 </span><span class="spaces">                </span><span class="istickedoff">res &lt;- runNodeList result</span>
<span class="lineno">  327 </span><span class="spaces">                </span><span class="istickedoff">put ts'</span>
<span class="lineno">  328 </span><span class="spaces">                </span><span class="istickedoff">return res</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="istickedoff">else <span class="nottickedoff">return result</span></span></span></span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>------------------------------------------------------------------------------
<span class="lineno">  333 </span>-- | Runs a splice in the underlying monad.  Splices require two
<span class="lineno">  334 </span>-- parameters, the template state, and an input node.
<span class="lineno">  335 </span>runSplice :: Monad m =&gt;
<span class="lineno">  336 </span>             TemplateState m -- ^ The initial template state
<span class="lineno">  337 </span>          -&gt; Node            -- ^ The splice's input node
<span class="lineno">  338 </span>          -&gt; Splice m        -- ^ The splice
<span class="lineno">  339 </span>          -&gt; m [Node]
<span class="lineno">  340 </span><span class="decl"><span class="istickedoff">runSplice ts node (TemplateMonad splice) = do</span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff">(result,_,_) &lt;- runRWST splice <span class="nottickedoff">node</span> ts</span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="istickedoff">return result</span></span>
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>------------------------------------------------------------------------------
<span class="lineno">  346 </span>-- | Runs a template in the underlying monad.  Similar to runSplice
<span class="lineno">  347 </span>-- except that templates don't require a Node as a parameter.
<span class="lineno">  348 </span>runRawTemplate :: Monad m =&gt; TemplateState m -&gt; Template -&gt; m [Node]
<span class="lineno">  349 </span><span class="decl"><span class="istickedoff">runRawTemplate ts template =</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">_preRunHook ts template &gt;&gt;=</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">runSplice ts <span class="nottickedoff">(X.Text &quot;&quot;)</span> . runNodeList &gt;&gt;=</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">_postRunHook ts</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>------------------------------------------------------------------------------
<span class="lineno">  356 </span>-- | Looks up a template name in the supplied 'TemplateState' and runs
<span class="lineno">  357 </span>-- it in the underlying monad.
<span class="lineno">  358 </span>runTemplate :: Monad m
<span class="lineno">  359 </span>            =&gt; TemplateState m
<span class="lineno">  360 </span>            -&gt; ByteString
<span class="lineno">  361 </span>            -&gt; m (Maybe [Node])
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff">runTemplate ts name =</span>
<span class="lineno">  363 </span><span class="spaces">    </span><span class="istickedoff">maybe (return Nothing)</span>
<span class="lineno">  364 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">(\(t,ctx) -&gt;</span></span>
<span class="lineno">  365 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">return . Just =&lt;&lt;</span></span>
<span class="lineno">  366 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">runRawTemplate (ts {_curContext = ctx}) t)</span></span>
<span class="lineno">  367 </span><span class="spaces">          </span><span class="istickedoff">(lookupTemplate name ts)</span></span>
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>------------------------------------------------------------------------------
<span class="lineno">  371 </span>-- | Looks up a template name evaluates it.  Same as runTemplate except it
<span class="lineno">  372 </span>-- runs in TemplateMonad instead of m.
<span class="lineno">  373 </span>evalTemplate :: Monad m
<span class="lineno">  374 </span>            =&gt; ByteString
<span class="lineno">  375 </span>            -&gt; TemplateMonad m (Maybe [Node])
<span class="lineno">  376 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff">evalTemplate name = do</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="nottickedoff">ts &lt;- get</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="nottickedoff">lift $ runTemplate ts name</span></span></span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>------------------------------------------------------------------------------
<span class="lineno">  382 </span>-- | Binds a list of constant string splices
<span class="lineno">  383 </span>bindStrings :: Monad m
<span class="lineno">  384 </span>            =&gt; [(ByteString, ByteString)]
<span class="lineno">  385 </span>            -&gt; TemplateState m
<span class="lineno">  386 </span>            -&gt; TemplateState m
<span class="lineno">  387 </span><span class="decl"><span class="nottickedoff">bindStrings pairs ts = foldr add ts pairs</span>
<span class="lineno">  388 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="nottickedoff">add (n,v) = bindSplice n (return [X.Text v])</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>------------------------------------------------------------------------------
<span class="lineno">  393 </span>-- | Renders a template with the specified parameters.  This is the function
<span class="lineno">  394 </span>-- to use when you want to &quot;call&quot; a template and pass in parameters from code.
<span class="lineno">  395 </span>callTemplate :: Monad m
<span class="lineno">  396 </span>             =&gt; ByteString                 -- ^ The name of the template
<span class="lineno">  397 </span>             -&gt; [(ByteString, ByteString)] -- ^ Association list of
<span class="lineno">  398 </span>                                           -- (name,value) parameter pairs
<span class="lineno">  399 </span>             -&gt; TemplateMonad m (Maybe Template)
<span class="lineno">  400 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff">callTemplate name params = do</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="nottickedoff">modify $ bindStrings params</span>
<span class="lineno">  402 </span><span class="spaces">    </span><span class="nottickedoff">evalTemplate name</span></span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>------------------------------------------------------------------------------
<span class="lineno">  406 </span>-- | Renders a template from the specified TemplateState.
<span class="lineno">  407 </span>renderTemplate :: Monad m
<span class="lineno">  408 </span>               =&gt; TemplateState m
<span class="lineno">  409 </span>               -&gt; ByteString
<span class="lineno">  410 </span>               -&gt; m (Maybe ByteString)
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">renderTemplate ts name = do</span>
<span class="lineno">  412 </span><span class="spaces">    </span><span class="istickedoff">ns &lt;- runTemplate ts name</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="istickedoff">return $ <span class="nottickedoff">(Just . formatList')</span> =&lt;&lt; ns</span></span>
<span class="lineno">  414 </span>
<span class="lineno">  415 </span>
<span class="lineno">  416 </span>------------------------------------------------------------------------------
<span class="lineno">  417 </span>heistExpatOptions :: X.ParserOptions ByteString ByteString
<span class="lineno">  418 </span><span class="decl"><span class="istickedoff">heistExpatOptions =</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="istickedoff">X.defaultParserOptions {</span>
<span class="lineno">  420 </span><span class="spaces">           </span><span class="istickedoff">X.parserEncoding = Just X.UTF8</span>
<span class="lineno">  421 </span><span class="spaces">         </span><span class="istickedoff">, X.entityDecoder  = Just <span class="nottickedoff">(\k -&gt; Map.lookup k htmlEntityLookupTable)</span></span>
<span class="lineno">  422 </span><span class="spaces">         </span><span class="istickedoff">}</span></span>
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>------------------------------------------------------------------------------
<span class="lineno">  425 </span>-- Template loading
<span class="lineno">  426 </span>------------------------------------------------------------------------------
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>-- | Reads an XML document from disk.
<span class="lineno">  429 </span>getDoc :: String -&gt; IO (Either String Template)
<span class="lineno">  430 </span><span class="decl"><span class="istickedoff">getDoc f = do</span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="istickedoff">bs &lt;- catch (liftM Right $ B.readFile f)</span>
<span class="lineno">  432 </span><span class="spaces">                </span><span class="istickedoff">(\(e::SomeException) -&gt; return $ Left $ <span class="nottickedoff">show e</span>)</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">let wrap b = &quot;&lt;snap:root&gt;\n&quot; `B.append` b `B.append` &quot;\n&lt;/snap:root&gt;&quot;</span>
<span class="lineno">  434 </span><span class="spaces">    </span><span class="istickedoff">return $ (mapRight <span class="nottickedoff">X.getChildren</span> .</span>
<span class="lineno">  435 </span><span class="spaces">              </span><span class="istickedoff">mapLeft <span class="nottickedoff">genErrorMsg</span> .</span>
<span class="lineno">  436 </span><span class="spaces">              </span><span class="istickedoff">X.parse' heistExpatOptions . wrap) =&lt;&lt; bs</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">genErrorMsg (X.XMLParseError str loc) = f ++ &quot; &quot; ++ locMsg loc ++ &quot;: &quot; ++ translate str</span></span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">locMsg (X.XMLParseLocation line col _ _) =</span></span>
<span class="lineno">  440 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;(line &quot; ++ show (line-1) ++ &quot;, col &quot; ++ show col ++ &quot;)&quot;</span></span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">translate &quot;junk after document element&quot; = &quot;document must have a single root element&quot;</span></span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">translate s = s</span></span></span>
<span class="lineno">  443 </span>
<span class="lineno">  444 </span>------------------------------------------------------------------------------
<span class="lineno">  445 </span>mapLeft :: (a -&gt; b) -&gt; Either a c -&gt; Either b c
<span class="lineno">  446 </span><span class="decl"><span class="istickedoff">mapLeft g = either <span class="nottickedoff">(Left . g)</span> Right</span></span>
<span class="lineno">  447 </span>mapRight :: (b -&gt; c) -&gt; Either a b -&gt; Either a c
<span class="lineno">  448 </span><span class="decl"><span class="istickedoff">mapRight g = either <span class="nottickedoff">Left</span> (Right . <span class="nottickedoff">g</span>)</span></span>
<span class="lineno">  449 </span>
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>------------------------------------------------------------------------------
<span class="lineno">  452 </span>-- | Loads a template with the specified path and filename.  The
<span class="lineno">  453 </span>-- template is only loaded if it has a &quot;.tpl&quot; extension.
<span class="lineno">  454 </span>loadTemplate :: String -- ^ path of the template root
<span class="lineno">  455 </span>             -&gt; String -- ^ full file path (includes the template root)
<span class="lineno">  456 </span>             -&gt; IO [Either String (TPath, Template)] --TemplateMap
<span class="lineno">  457 </span><span class="decl"><span class="istickedoff">loadTemplate templateRoot fname</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">| &quot;.tpl&quot; `isSuffixOf` fname = do</span>
<span class="lineno">  459 </span><span class="spaces">        </span><span class="istickedoff">c &lt;- getDoc fname</span>
<span class="lineno">  460 </span><span class="spaces">        </span><span class="istickedoff">return [fmap (\t -&gt; (splitPaths $ B.pack tName, <span class="nottickedoff">t</span>)) c]</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return []</span>
<span class="lineno">  462 </span><span class="spaces">  </span><span class="istickedoff">where -- tName is path relative to the template root directory</span>
<span class="lineno">  463 </span><span class="spaces">        </span><span class="istickedoff">tName = drop ((length templateRoot)+1) $</span>
<span class="lineno">  464 </span><span class="spaces">                </span><span class="istickedoff">-- We're only dropping the template root, not the whole path</span>
<span class="lineno">  465 </span><span class="spaces">                </span><span class="istickedoff">take ((length fname) - 4) fname</span></span>
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>
<span class="lineno">  468 </span>------------------------------------------------------------------------------
<span class="lineno">  469 </span>-- | Traverses the specified directory structure and builds a
<span class="lineno">  470 </span>-- TemplateState by loading all the files with a &quot;.tpl&quot; extension.
<span class="lineno">  471 </span>loadTemplates :: Monad m =&gt; FilePath -&gt; TemplateState m -&gt; IO (Either String (TemplateState m))
<span class="lineno">  472 </span><span class="decl"><span class="istickedoff">loadTemplates dir ts = do</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">d &lt;- readDirectoryWith (loadTemplate dir) dir</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">let tlist = F.fold (free d)</span>
<span class="lineno">  475 </span><span class="spaces">        </span><span class="istickedoff">errs = lefts tlist</span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="istickedoff">case errs of</span>
<span class="lineno">  477 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; liftM Right $ foldM loadHook ts $ rights tlist</span>
<span class="lineno">  478 </span><span class="spaces">        </span><span class="istickedoff">_  -&gt; <span class="nottickedoff">return $ Left $ unlines errs</span></span></span>
<span class="lineno">  479 </span>
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>------------------------------------------------------------------------------
<span class="lineno">  482 </span>-- | Runs the onLoad hook on the template and returns the `TemplateState`
<span class="lineno">  483 </span>-- with the result inserted.
<span class="lineno">  484 </span>loadHook :: Monad m =&gt; TemplateState m -&gt; (TPath, Template) -&gt; IO (TemplateState m)
<span class="lineno">  485 </span><span class="decl"><span class="istickedoff">loadHook ts (tp, t) = do</span>
<span class="lineno">  486 </span><span class="spaces">    </span><span class="istickedoff">t' &lt;- _onLoadHook ts <span class="nottickedoff">t</span></span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">return $ insertTemplate tp <span class="nottickedoff">t'</span> ts</span></span>
<span class="lineno">  488 </span>
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>------------------------------------------------------------------------------
<span class="lineno">  491 </span>-- These are here until we can get them into hexpat.
<span class="lineno">  492 </span>------------------------------------------------------------------------------
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>formatList :: (X.GenericXMLString tag, X.GenericXMLString text) =&gt;
<span class="lineno">  495 </span>              [X.Node tag text]
<span class="lineno">  496 </span>           -&gt; L.ByteString
<span class="lineno">  497 </span><span class="decl"><span class="nottickedoff">formatList nodes = foldl L.append L.empty $ map formatNode nodes</span></span>
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>formatList' :: (X.GenericXMLString tag, X.GenericXMLString text) =&gt;
<span class="lineno">  500 </span>               [X.Node tag text]
<span class="lineno">  501 </span>            -&gt; B.ByteString
<span class="lineno">  502 </span><span class="decl"><span class="nottickedoff">formatList' = B.concat . L.toChunks . formatList</span></span>
<span class="lineno">  503 </span>

</pre>
</html>
