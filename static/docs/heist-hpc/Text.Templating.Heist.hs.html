<html><style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings, GeneralizedNewtypeDeriving #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>{-|
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>  This module contains the core definitions for the Heist template system.
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>  FIXME: this intro could be a lot better
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>  The Heist template system is based on XML\/xhtml; templates are parsed in as
<span class="lineno">   10 </span>  XML trees, and we define substitutions (or \&quot;splices\&quot;) on certain tag names
<span class="lineno">   11 </span>  that take 'Node' values in and substitute them with replacement text.
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>  In Heist nomenclature a \&quot;splice\&quot; is a program that, given a 'Node' from a
<span class="lineno">   14 </span>  template's XML tree, transforms it and gives you a result to be \&quot;spliced\&quot;
<span class="lineno">   15 </span>  back into the document. Each tag name in a template XML document is looked up
<span class="lineno">   16 </span>  in a \&quot;splice table\&quot;, held within a 'TemplateState', and if there's a match
<span class="lineno">   17 </span>  the tag and its contents are passed to the 'Splice' for processing.
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>  In the following example, we'll define a substitution for @\&lt;foo/\&gt;@ nodes that
<span class="lineno">   20 </span>  causes the node to be replaced by the text \&quot;Testing 1-2-3\&quot;:
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>  &gt;
<span class="lineno">   23 </span>  &gt; import Text.XML.Expat.Tree
<span class="lineno">   24 </span>  &gt;
<span class="lineno">   25 </span>  &gt; fooSplice :: Monad m =&gt; Splice m
<span class="lineno">   26 </span>  &gt; fooSplice = return $ Text &quot;Testing 1-2-3&quot;
<span class="lineno">   27 </span>  &gt;
<span class="lineno">   28 </span>  &gt; go :: Monad m =&gt; m [Node]
<span class="lineno">   29 </span>  &gt; go = runTemplate st template
<span class="lineno">   30 </span>  &gt;   where
<span class="lineno">   31 </span>  &gt;     st = bindSplice &quot;foo&quot; fooSplice emptyTemplateState 
<span class="lineno">   32 </span>  &gt;     template = Element &quot;root&quot; [] [Element &quot;foo&quot; [] []]
<span class="lineno">   33 </span>  &gt;
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>  Running \&quot;go\&quot; will result in the tree
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>  &gt; Element &quot;root&quot; [] [Text &quot;Testing 1-2-3&quot;]
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>  'Splice' is a type synonym:
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>  &gt;
<span class="lineno">   42 </span>  &gt; type Splice m = TemplateMonad m [Node]
<span class="lineno">   43 </span>  &gt;
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>  where 'TemplateMonad' is a monad transformer that gives you access to the
<span class="lineno">   46 </span>  'Node' being processed (it's a \&quot;Reader\&quot; monad) as well as holding the
<span class="lineno">   47 </span>  'TemplateState' that contains splice and template mappings.
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>  TODO:
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>  &gt; * describe template loading and mapping
<span class="lineno">   52 </span>  &gt;
<span class="lineno">   53 </span>  &gt; * template contexts and subtrees
<span class="lineno">   54 </span>  &gt;
<span class="lineno">   55 </span>  &gt; * describe recursion / substitution process
<span class="lineno">   56 </span>-}
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>module Text.Templating.Heist
<span class="lineno">   59 </span>  (
<span class="lineno">   60 </span>    -- * Types
<span class="lineno">   61 </span>    Node
<span class="lineno">   62 </span>  , Splice
<span class="lineno">   63 </span>  , Template
<span class="lineno">   64 </span>  , TemplateMonad
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>  -- ** FIXME: don't export state fields
<span class="lineno">   67 </span>  , TemplateState(..)
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>    -- * Functions and declarations on TemplateState values
<span class="lineno">   70 </span>  , addTemplate
<span class="lineno">   71 </span>  , emptyTemplateState
<span class="lineno">   72 </span>  , bindSplice
<span class="lineno">   73 </span>  , lookupSplice
<span class="lineno">   74 </span>  , lookupTemplate
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>    -- * TemplateMonad functions
<span class="lineno">   77 </span>  , stopRecursion
<span class="lineno">   78 </span>  , getParamNode
<span class="lineno">   79 </span>  , runNodeList
<span class="lineno">   80 </span>  , getContext
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>    -- * Functions for running splices and templates
<span class="lineno">   83 </span>  , runSplice
<span class="lineno">   84 </span>  , runTemplate
<span class="lineno">   85 </span>  , runBareTemplate
<span class="lineno">   86 </span>  , getDoc
<span class="lineno">   87 </span>  , loadTemplates
<span class="lineno">   88 </span>  , renderTemplate
<span class="lineno">   89 </span>  , renderTemplate'
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>  , heistExpatOptions
<span class="lineno">   92 </span>  , module Text.Templating.Heist.Constants
<span class="lineno">   93 </span>  ) where
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>------------------------------------------------------------------------------
<span class="lineno">   96 </span>import           Control.Monad.RWS.Strict
<span class="lineno">   97 </span>import           Data.ByteString.Char8 (ByteString)
<span class="lineno">   98 </span>import qualified Data.ByteString.Char8 as B
<span class="lineno">   99 </span>import qualified Data.ByteString.Lazy as L
<span class="lineno">  100 </span>import           Data.Either
<span class="lineno">  101 </span>import qualified Data.Foldable as F
<span class="lineno">  102 </span>import           Data.List
<span class="lineno">  103 </span>import qualified Data.Map as Map
<span class="lineno">  104 </span>import           Data.Map (Map)
<span class="lineno">  105 </span>import           System.Directory.Tree hiding (name)
<span class="lineno">  106 </span>import           Text.XML.Expat.Format
<span class="lineno">  107 </span>import qualified Text.XML.Expat.Tree as X
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>------------------------------------------------------------------------------
<span class="lineno">  110 </span>import           Text.Templating.Heist.Constants
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>------------------------------------------------------------------------------
<span class="lineno">  113 </span>-- Types
<span class="lineno">  114 </span>------------------------------------------------------------------------------
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>-- | Heist templates are XML documents. The hexpat library is polymorphic over
<span class="lineno">  117 </span>-- the type of strings, so here we define a 'Node' alias to fix the string
<span class="lineno">  118 </span>-- types of the tag names and tag bodies to 'ByteString'.
<span class="lineno">  119 </span>type Node = X.Node ByteString ByteString
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>------------------------------------------------------------------------------
<span class="lineno">  123 </span>-- | A 'Template' is a forest of XML nodes.
<span class="lineno">  124 </span>type Template = [Node]
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>------------------------------------------------------------------------------
<span class="lineno">  128 </span>-- | Reversed list of directories
<span class="lineno">  129 </span>type TPath = [ByteString]
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>------------------------------------------------------------------------------
<span class="lineno">  133 </span>type TemplateMap = Map TPath Template
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>------------------------------------------------------------------------------
<span class="lineno">  137 </span>-- | Holds all the state information needed for template processing:
<span class="lineno">  138 </span>--
<span class="lineno">  139 </span>--     * a collection of named templates. If you use the @\&lt;apply
<span class="lineno">  140 </span>--       template=\&quot;foo\&quot;\&gt;@ tag to include another template by name, @\&quot;foo\&quot;@
<span class="lineno">  141 </span>--       is looked up in here.
<span class="lineno">  142 </span>--
<span class="lineno">  143 </span>--     * the mapping from tag names to 'Splice's.
<span class="lineno">  144 </span>--
<span class="lineno">  145 </span>--     * a flag to control whether we will recurse during splice processing.
<span class="lineno">  146 </span>--
<span class="lineno">  147 </span>-- We'll illustrate the recursion flag with a small example template:
<span class="lineno">  148 </span>--
<span class="lineno">  149 </span>--   &gt; &lt;foo&gt;
<span class="lineno">  150 </span>--   &gt;   &lt;bar&gt;
<span class="lineno">  151 </span>--   &gt;     ...
<span class="lineno">  152 </span>--   &gt;   &lt;/bar&gt;
<span class="lineno">  153 </span>--   &gt; &lt;/foo&gt;
<span class="lineno">  154 </span>--
<span class="lineno">  155 </span>-- Assume that @\&quot;foo\&quot;@ is bound to a splice procedure. Running the @foo@
<span class="lineno">  156 </span>-- splice will result in a list of nodes @L@; if the recursion flag is on we
<span class="lineno">  157 </span>-- will recursively scan @L@ for splices, otherwise @L@ will be included in the
<span class="lineno">  158 </span>-- output verbatim.
<span class="lineno">  159 </span>data <span class="istickedoff">TemplateState</span> m = TemplateState {
<span class="lineno">  160 </span>    -- | A mapping of splice names to splice actions
<span class="lineno">  161 </span>      _spliceMap   :: SpliceMap m
<span class="lineno">  162 </span>    -- | A mapping of template names to templates
<span class="lineno">  163 </span>    , _templateMap :: TemplateMap
<span class="lineno">  164 </span>    -- | A flag to control splice recursion
<span class="lineno">  165 </span>    , _recurse     :: Bool
<span class="lineno">  166 </span>    , _curContext  :: TPath
<span class="lineno">  167 </span>}
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>------------------------------------------------------------------------------
<span class="lineno">  171 </span>instance <span class="istickedoff">Eq (TemplateState m)</span> where
<span class="lineno">  172 </span>    <span class="decl"><span class="istickedoff">a == b = (_recurse a == _recurse b) &amp;&amp;</span>
<span class="lineno">  173 </span><span class="spaces">             </span><span class="istickedoff">(_templateMap a == _templateMap b) &amp;&amp;</span>
<span class="lineno">  174 </span><span class="spaces">             </span><span class="istickedoff">(_curContext a == _curContext b)</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>------------------------------------------------------------------------------
<span class="lineno">  178 </span>-- | 'TemplateMonad' is a monad transformer that gives you access to the 'Node'
<span class="lineno">  179 </span>--   being processed (using the 'MonadReader' instance) as well as holding the
<span class="lineno">  180 </span>--   'TemplateState' that contains splice and template mappings (accessible
<span class="lineno">  181 </span>--   using the 'MonadState' instance.
<span class="lineno">  182 </span>newtype TemplateMonad m a = TemplateMonad (RWST Node () (TemplateState m) m a)
<span class="lineno">  183 </span>  deriving (Monad, MonadIO, MonadReader Node, MonadState (TemplateState m))
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>------------------------------------------------------------------------------
<span class="lineno">  187 </span>-- | A Splice is a TemplateMonad computation that returns [Node].
<span class="lineno">  188 </span>type Splice m = TemplateMonad m [Node]
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>------------------------------------------------------------------------------
<span class="lineno">  192 </span>-- | SpliceMap associates a name and a Splice.
<span class="lineno">  193 </span>type SpliceMap m = Map ByteString (Splice m)
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>------------------------------------------------------------------------------
<span class="lineno">  197 </span>instance <span class="istickedoff">Monoid (TemplateState m)</span> where
<span class="lineno">  198 </span>    <span class="decl"><span class="istickedoff">mempty = TemplateState Map.empty Map.empty True []</span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>    <span class="decl"><span class="istickedoff">(TemplateState s1 t1 r1 _) `mappend` (TemplateState s2 t2 r2 c2) =</span>
<span class="lineno">  201 </span><span class="spaces">        </span><span class="istickedoff">TemplateState <span class="nottickedoff">s</span> t r c2</span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  203 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">s = s1 `mappend` s2</span></span>
<span class="lineno">  204 </span><span class="spaces">        </span><span class="istickedoff">t = t1 `mappend` t2</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="istickedoff">r = r1 &amp;&amp; r2</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>------------------------------------------------------------------------------
<span class="lineno">  208 </span>-- TemplateState functions
<span class="lineno">  209 </span>------------------------------------------------------------------------------
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | An empty template state, with Heist's default splices (@\&lt;bind\&gt;@ and
<span class="lineno">  212 </span>-- @\&lt;apply\&gt;@) mapped.
<span class="lineno">  213 </span>emptyTemplateState :: Monad m =&gt; TemplateState m
<span class="lineno">  214 </span><span class="decl"><span class="istickedoff">emptyTemplateState = TemplateState defaultSpliceMap Map.empty True []</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>------------------------------------------------------------------------------
<span class="lineno">  218 </span>-- | Bind a new splice declaration to a tag name within a 'TemplateState'.
<span class="lineno">  219 </span>bindSplice :: Monad m =&gt;
<span class="lineno">  220 </span>              ByteString        -- ^ tag name
<span class="lineno">  221 </span>           -&gt; Splice m          -- ^ splice action
<span class="lineno">  222 </span>           -&gt; TemplateState m   -- ^ source state
<span class="lineno">  223 </span>           -&gt; TemplateState m
<span class="lineno">  224 </span><span class="decl"><span class="istickedoff">bindSplice n v ts = ts {_spliceMap = Map.insert n v (_spliceMap ts)}</span></span>
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>------------------------------------------------------------------------------
<span class="lineno">  228 </span>-- | Convenience function for looking up a splice.
<span class="lineno">  229 </span>lookupSplice :: Monad m =&gt;
<span class="lineno">  230 </span>                ByteString
<span class="lineno">  231 </span>             -&gt; TemplateState m
<span class="lineno">  232 </span>             -&gt; Maybe (Splice m)
<span class="lineno">  233 </span><span class="decl"><span class="istickedoff">lookupSplice nm ts = Map.lookup nm $ _spliceMap ts</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>------------------------------------------------------------------------------
<span class="lineno">  237 </span>-- | Converts a path into an array of the elements in reverse order.
<span class="lineno">  238 </span>splitPaths :: ByteString -&gt; TPath
<span class="lineno">  239 </span><span class="decl"><span class="istickedoff">splitPaths = reverse . B.split '/'</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>------------------------------------------------------------------------------
<span class="lineno">  243 </span>-- | Does a single template lookup without cascading up.
<span class="lineno">  244 </span>singleLookup :: TemplateMap
<span class="lineno">  245 </span>             -&gt; TPath
<span class="lineno">  246 </span>             -&gt; ByteString
<span class="lineno">  247 </span>             -&gt; Maybe (Template, TPath)
<span class="lineno">  248 </span><span class="decl"><span class="istickedoff">singleLookup tm path name = fmap <span class="nottickedoff">(\a -&gt; (a,path))</span> $ Map.lookup (name:path) tm</span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>------------------------------------------------------------------------------
<span class="lineno">  252 </span>-- | Searches for a template by looking in the full path then backing up into each
<span class="lineno">  253 </span>-- of the parent directories until the template is found.
<span class="lineno">  254 </span>traversePath :: TemplateMap
<span class="lineno">  255 </span>             -&gt; TPath
<span class="lineno">  256 </span>             -&gt; ByteString
<span class="lineno">  257 </span>             -&gt; Maybe (Template, TPath)
<span class="lineno">  258 </span><span class="decl"><span class="istickedoff">traversePath tm [] name = fmap (\a -&gt; (a,<span class="nottickedoff">[]</span>)) (Map.lookup [name] tm)</span>
<span class="lineno">  259 </span><span class="spaces"></span><span class="istickedoff">traversePath tm path name =</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">singleLookup tm path name `mplus`</span></span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">traversePath tm (tail path) name</span></span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>------------------------------------------------------------------------------
<span class="lineno">  265 </span>-- | Convenience function for looking up a template.
<span class="lineno">  266 </span>lookupTemplate :: Monad m =&gt;
<span class="lineno">  267 </span>                  ByteString
<span class="lineno">  268 </span>               -&gt; TemplateState m
<span class="lineno">  269 </span>               -&gt; Maybe (Template, TPath)
<span class="lineno">  270 </span><span class="decl"><span class="istickedoff">lookupTemplate nameStr ts = </span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff">f (_templateMap ts) path name</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="istickedoff">where (name:p) = case splitPaths nameStr of</span>
<span class="lineno">  273 </span><span class="spaces">                       </span><span class="istickedoff">[] -&gt; [&quot;&quot;]</span>
<span class="lineno">  274 </span><span class="spaces">                       </span><span class="istickedoff">ps -&gt; ps</span>
<span class="lineno">  275 </span><span class="spaces">        </span><span class="istickedoff">path = p ++ (_curContext ts)</span>
<span class="lineno">  276 </span><span class="spaces">        </span><span class="istickedoff">f = if '/' `B.elem` nameStr</span>
<span class="lineno">  277 </span><span class="spaces">                </span><span class="istickedoff">then singleLookup</span>
<span class="lineno">  278 </span><span class="spaces">                </span><span class="istickedoff">else traversePath</span></span>
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>------------------------------------------------------------------------------
<span class="lineno">  282 </span>-- | Adds a template to the template state.
<span class="lineno">  283 </span>addTemplate :: Monad m =&gt;
<span class="lineno">  284 </span>               ByteString
<span class="lineno">  285 </span>            -&gt; Template
<span class="lineno">  286 </span>            -&gt; TemplateState m
<span class="lineno">  287 </span>            -&gt; TemplateState m
<span class="lineno">  288 </span><span class="decl"><span class="istickedoff">addTemplate n t st =</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">st {_templateMap = Map.insert (splitPaths n) t (_templateMap st)}</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>------------------------------------------------------------------------------
<span class="lineno">  293 </span>-- | Gets the node currently being processed.
<span class="lineno">  294 </span>getParamNode :: Monad m =&gt; TemplateMonad m Node
<span class="lineno">  295 </span><span class="decl"><span class="istickedoff">getParamNode = ask</span></span>
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>------------------------------------------------------------------------------
<span class="lineno">  299 </span>-- | Stops the recursive processing of splices.
<span class="lineno">  300 </span>stopRecursion :: Monad m =&gt; TemplateMonad m ()
<span class="lineno">  301 </span><span class="decl"><span class="nottickedoff">stopRecursion = modify (\st -&gt; st { _recurse = False })</span></span>
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>------------------------------------------------------------------------------
<span class="lineno">  305 </span>-- | Sets the current context
<span class="lineno">  306 </span>setContext :: Monad m =&gt; TPath -&gt; TemplateMonad m ()
<span class="lineno">  307 </span><span class="decl"><span class="istickedoff">setContext c = modify (\st -&gt; st { _curContext = <span class="nottickedoff">c</span> })</span></span>
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>------------------------------------------------------------------------------
<span class="lineno">  311 </span>-- | Gets the current context
<span class="lineno">  312 </span>getContext :: Monad m =&gt; TemplateMonad m TPath
<span class="lineno">  313 </span><span class="decl"><span class="nottickedoff">getContext = gets _curContext</span></span>
<span class="lineno">  314 </span>  
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>------------------------------------------------------------------------------
<span class="lineno">  317 </span>-- | Performs splice processing on a list of nodes.
<span class="lineno">  318 </span>runNodeList :: Monad m =&gt; [Node] -&gt; Splice m
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">runNodeList nodes = liftM concat $ sequence (map runNode nodes)</span></span>
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>------------------------------------------------------------------------------
<span class="lineno">  323 </span>-- | Performs splice processing on a single node.
<span class="lineno">  324 </span>runNode :: Monad m =&gt; Node -&gt; Splice m
<span class="lineno">  325 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">runNode n@(X.Text _)          = return [n]</span>
<span class="lineno">  326 </span><span class="spaces"></span><span class="istickedoff">runNode n@(X.Element nm _ ch) = do</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- liftM (lookupSplice nm) get</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">maybe runChildren (recurseSplice n) s</span>
<span class="lineno">  329 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">runChildren = do</span>
<span class="lineno">  332 </span><span class="spaces">        </span><span class="istickedoff">newKids &lt;- runNodeList ch</span>
<span class="lineno">  333 </span><span class="spaces">        </span><span class="istickedoff">return [X.modifyChildren (const newKids) n]</span></span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>------------------------------------------------------------------------------
<span class="lineno">  337 </span>-- | Checks the recursion flag and recurses accordingly.
<span class="lineno">  338 </span>recurseSplice :: Monad m =&gt; Node -&gt; Splice m -&gt; Splice m
<span class="lineno">  339 </span><span class="decl"><span class="istickedoff">recurseSplice node splice = do</span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">result &lt;- local (const node) splice</span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff">ts' &lt;- get</span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">_recurse ts'</span></span>
<span class="lineno">  343 </span><span class="spaces">        </span><span class="istickedoff">then runNodeList result</span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="istickedoff">else <span class="nottickedoff">return result</span></span></span>
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>------------------------------------------------------------------------------
<span class="lineno">  348 </span>-- | Runs a splice in the underlying monad.  Splices require two
<span class="lineno">  349 </span>-- parameters, the template state, and an input node.
<span class="lineno">  350 </span>runSplice :: Monad m =&gt;
<span class="lineno">  351 </span>             TemplateState m -- ^ The initial template state
<span class="lineno">  352 </span>          -&gt; Node            -- ^ The splice's input node
<span class="lineno">  353 </span>          -&gt; Splice m        -- ^ The splice
<span class="lineno">  354 </span>          -&gt; m [Node]
<span class="lineno">  355 </span><span class="decl"><span class="istickedoff">runSplice ts node (TemplateMonad splice) = do</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">(result,_,_) &lt;- runRWST splice <span class="nottickedoff">node</span> ts</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">return result</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>------------------------------------------------------------------------------
<span class="lineno">  361 </span>-- | Runs a template in the underlying monad.  Similar to runSplice
<span class="lineno">  362 </span>-- except that templates don't require a Node as a parameter.
<span class="lineno">  363 </span>runTemplate :: Monad m =&gt; TemplateState m -&gt; Template -&gt; m [Node]
<span class="lineno">  364 </span><span class="decl"><span class="istickedoff">runTemplate ts template = runSplice ts <span class="nottickedoff">(X.Text &quot;&quot;)</span> (runNodeList template)</span></span>
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>------------------------------------------------------------------------------
<span class="lineno">  368 </span>-- | Looks up a template name in the supplied 'TemplateState' and runs
<span class="lineno">  369 </span>-- it in the underlying monad.
<span class="lineno">  370 </span>runTemplateByName :: Monad m =&gt;
<span class="lineno">  371 </span>                     TemplateState m
<span class="lineno">  372 </span>                  -&gt; ByteString
<span class="lineno">  373 </span>                  -&gt; m (Maybe [Node])
<span class="lineno">  374 </span><span class="decl"><span class="istickedoff">runTemplateByName ts name = do</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="istickedoff">let mt = lookupTemplate name ts</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">maybe (return Nothing)</span>
<span class="lineno">  377 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">(\(t,ctx) -&gt;</span></span>
<span class="lineno">  378 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">return . Just =&lt;&lt;</span></span>
<span class="lineno">  379 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">runTemplate (ts {_curContext = ctx}) t)</span></span>
<span class="lineno">  380 </span><span class="spaces">          </span><span class="istickedoff">mt</span></span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>------------------------------------------------------------------------------
<span class="lineno">  384 </span>-- | Runs a template with an empty TemplateState.
<span class="lineno">  385 </span>runBareTemplate :: Monad m =&gt; Template -&gt; m [Node]
<span class="lineno">  386 </span><span class="decl"><span class="istickedoff">runBareTemplate = runTemplate emptyTemplateState</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>------------------------------------------------------------------------------
<span class="lineno">  389 </span>-- Heist built-in splices implementing core template functionality.
<span class="lineno">  390 </span>------------------------------------------------------------------------------
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>-- The bind splice
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>-- | Default name for the bind splice.
<span class="lineno">  395 </span>bindTag :: ByteString
<span class="lineno">  396 </span><span class="decl"><span class="istickedoff">bindTag = &quot;bind&quot;</span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>------------------------------------------------------------------------------
<span class="lineno">  400 </span>-- | Default attribute name for the bind tag.
<span class="lineno">  401 </span>bindAttr :: ByteString
<span class="lineno">  402 </span><span class="decl"><span class="istickedoff">bindAttr = &quot;tag&quot;</span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>------------------------------------------------------------------------------
<span class="lineno">  406 </span>-- | Implementation of the bind splice.
<span class="lineno">  407 </span>bindImpl :: Monad m =&gt; Splice m
<span class="lineno">  408 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">bindImpl = do</span>
<span class="lineno">  409 </span><span class="spaces">    </span><span class="istickedoff">node &lt;- getParamNode</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="istickedoff">maybe <span class="nottickedoff">(return ())</span></span>
<span class="lineno">  411 </span><span class="spaces">          </span><span class="istickedoff">(add node)</span>
<span class="lineno">  412 </span><span class="spaces">          </span><span class="istickedoff">(X.getAttribute node bindAttr)</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="istickedoff">return []</span>
<span class="lineno">  414 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">add node nm = modify $ bindSplice nm (return $ X.getChildren node)</span></span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>
<span class="lineno">  419 </span>------------------------------------------------------------------------------
<span class="lineno">  420 </span>-- The apply splice
<span class="lineno">  421 </span>------------------------------------------------------------------------------
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>------------------------------------------------------------------------------
<span class="lineno">  425 </span>-- | Default name for the apply splice.
<span class="lineno">  426 </span>applyTag :: ByteString
<span class="lineno">  427 </span><span class="decl"><span class="istickedoff">applyTag = &quot;apply&quot;</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>------------------------------------------------------------------------------
<span class="lineno">  431 </span>-- | Default attribute name for the apply tag.
<span class="lineno">  432 </span>applyAttr :: ByteString
<span class="lineno">  433 </span><span class="decl"><span class="istickedoff">applyAttr = &quot;template&quot;</span></span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>
<span class="lineno">  436 </span>------------------------------------------------------------------------------
<span class="lineno">  437 </span>-- | Implementation of the apply splice.
<span class="lineno">  438 </span>applyImpl :: Monad m =&gt; Splice m
<span class="lineno">  439 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">applyImpl = do</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">node &lt;- getParamNode</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">case X.getAttribute node applyAttr of</span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff">Nothing   -&gt; <span class="nottickedoff">return []</span> -- TODO: error handling</span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff">Just attr -&gt; do </span>
<span class="lineno">  444 </span><span class="spaces">            </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  445 </span><span class="spaces">            </span><span class="istickedoff">put $ st { _spliceMap = defaultSpliceMap }</span>
<span class="lineno">  446 </span><span class="spaces">            </span><span class="istickedoff">processedChildren &lt;- runNodeList $ X.getChildren node</span>
<span class="lineno">  447 </span><span class="spaces">            </span><span class="istickedoff">modify (bindSplice &quot;content&quot; $ <span class="nottickedoff">return processedChildren</span>)</span>
<span class="lineno">  448 </span><span class="spaces">            </span><span class="istickedoff">maybe <span class="nottickedoff">(return [])</span> -- TODO: error handling</span>
<span class="lineno">  449 </span><span class="spaces">                  </span><span class="istickedoff">(\(t,ctx) -&gt; do setContext <span class="nottickedoff">ctx</span></span>
<span class="lineno">  450 </span><span class="spaces">                                  </span><span class="istickedoff">result &lt;- runNodeList t</span>
<span class="lineno">  451 </span><span class="spaces">                                  </span><span class="istickedoff">put st</span>
<span class="lineno">  452 </span><span class="spaces">                                  </span><span class="istickedoff">return result)</span>
<span class="lineno">  453 </span><span class="spaces">                  </span><span class="istickedoff">(lookupTemplate attr (st {_curContext = nextCtx attr st}))</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="istickedoff">where nextCtx name st</span>
<span class="lineno">  455 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlyfalse">B.isPrefixOf &quot;/&quot; name</span> = <span class="nottickedoff">[]</span></span>
<span class="lineno">  456 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>             = _curContext st</span></span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>------------------------------------------------------------------------------
<span class="lineno">  460 </span>-- | Default name for the ignore splice.
<span class="lineno">  461 </span>ignoreTag :: ByteString
<span class="lineno">  462 </span><span class="decl"><span class="istickedoff">ignoreTag = &quot;ignore&quot;</span></span>
<span class="lineno">  463 </span>
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>------------------------------------------------------------------------------
<span class="lineno">  466 </span>-- | The ignore tag and everything it surrounds disappears in the
<span class="lineno">  467 </span>-- rendered output.
<span class="lineno">  468 </span>ignoreImpl :: Monad m =&gt; Splice m
<span class="lineno">  469 </span><span class="decl"><span class="nottickedoff">ignoreImpl = return []</span></span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>
<span class="lineno">  472 </span>------------------------------------------------------------------------------
<span class="lineno">  473 </span>-- | The default set of built-in splices.
<span class="lineno">  474 </span>defaultSpliceMap :: Monad m =&gt; SpliceMap m
<span class="lineno">  475 </span><span class="decl"><span class="istickedoff">defaultSpliceMap = Map.fromList</span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="istickedoff">[(applyTag, applyImpl)</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="istickedoff">,(bindTag, bindImpl)</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="istickedoff">,(ignoreTag, <span class="nottickedoff">ignoreImpl</span>)</span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>------------------------------------------------------------------------------
<span class="lineno">  483 </span>heistExpatOptions :: X.ParserOptions ByteString ByteString
<span class="lineno">  484 </span><span class="decl"><span class="istickedoff">heistExpatOptions =</span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="istickedoff">X.defaultParserOptions {</span>
<span class="lineno">  486 </span><span class="spaces">           </span><span class="istickedoff">X.parserEncoding = Just X.UTF8</span>
<span class="lineno">  487 </span><span class="spaces">         </span><span class="istickedoff">, X.entityDecoder  = Just <span class="nottickedoff">(\k -&gt; Map.lookup k htmlEntityLookupTable)</span></span>
<span class="lineno">  488 </span><span class="spaces">         </span><span class="istickedoff">}</span></span>
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>------------------------------------------------------------------------------
<span class="lineno">  491 </span>-- Template loading
<span class="lineno">  492 </span>------------------------------------------------------------------------------
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>-- | Reads an XML document from disk.
<span class="lineno">  495 </span>getDoc :: String -&gt; IO (Either String Template)
<span class="lineno">  496 </span><span class="decl"><span class="istickedoff">getDoc f = do</span>
<span class="lineno">  497 </span><span class="spaces">    </span><span class="istickedoff">bs &lt;- catch (liftM Right $ B.readFile f) (\e -&gt; return $ Left $ <span class="nottickedoff">show e</span>)</span>
<span class="lineno">  498 </span><span class="spaces">    </span><span class="istickedoff">let wrap b = &quot;&lt;snap:root&gt;\n&quot; `B.append` b `B.append` &quot;\n&lt;/snap:root&gt;&quot;</span>
<span class="lineno">  499 </span><span class="spaces">    </span><span class="istickedoff">return $ (mapRight <span class="nottickedoff">X.getChildren</span> .</span>
<span class="lineno">  500 </span><span class="spaces">              </span><span class="istickedoff">mapLeft <span class="nottickedoff">genErrorMsg</span> .</span>
<span class="lineno">  501 </span><span class="spaces">              </span><span class="istickedoff">X.parse' heistExpatOptions . wrap) =&lt;&lt; bs</span>
<span class="lineno">  502 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">genErrorMsg (X.XMLParseError str loc) = f ++ &quot; &quot; ++ locMsg loc ++ &quot;: &quot; ++ translate str</span></span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">locMsg (X.XMLParseLocation line col _ _) =</span></span>
<span class="lineno">  505 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;(line &quot; ++ show (line-1) ++ &quot;, col &quot; ++ show col ++ &quot;)&quot;</span></span>
<span class="lineno">  506 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">translate &quot;junk after document element&quot; = &quot;document must have a single root element&quot;</span></span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">translate s = s</span></span></span>
<span class="lineno">  508 </span>
<span class="lineno">  509 </span>------------------------------------------------------------------------------
<span class="lineno">  510 </span>mapLeft :: (a -&gt; b) -&gt; Either a c -&gt; Either b c
<span class="lineno">  511 </span><span class="decl"><span class="istickedoff">mapLeft g = either <span class="nottickedoff">(Left . g)</span> Right</span></span>
<span class="lineno">  512 </span>mapRight :: (b -&gt; c) -&gt; Either a b -&gt; Either a c
<span class="lineno">  513 </span><span class="decl"><span class="istickedoff">mapRight g = either <span class="nottickedoff">Left</span> (Right . <span class="nottickedoff">g</span>)</span></span>
<span class="lineno">  514 </span>
<span class="lineno">  515 </span>
<span class="lineno">  516 </span>------------------------------------------------------------------------------
<span class="lineno">  517 </span>-- | Loads a template with the specified path and filename.  The
<span class="lineno">  518 </span>-- template is only loaded if it has a &quot;.tpl&quot; extension.
<span class="lineno">  519 </span>loadTemplate :: String -&gt; String -&gt; IO [Either String (TPath, Template)] --TemplateMap
<span class="lineno">  520 </span><span class="decl"><span class="istickedoff">loadTemplate path fname</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="istickedoff">| &quot;.tpl&quot; `isSuffixOf` fname = do</span>
<span class="lineno">  522 </span><span class="spaces">        </span><span class="istickedoff">c &lt;- getDoc fname</span>
<span class="lineno">  523 </span><span class="spaces">        </span><span class="istickedoff">return [fmap (\t -&gt; (splitPaths $ B.pack tName, <span class="nottickedoff">t</span>)) c]</span>
<span class="lineno">  524 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return []</span>
<span class="lineno">  525 </span><span class="spaces">  </span><span class="istickedoff">where tName = drop ((length path)+1) $</span>
<span class="lineno">  526 </span><span class="spaces">                </span><span class="istickedoff">take ((length fname) - 4) fname</span></span>
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>------------------------------------------------------------------------------
<span class="lineno">  530 </span>-- | Traverses the specified directory structure and builds a
<span class="lineno">  531 </span>-- TemplateState by loading all the files with a &quot;.tpl&quot; extension.
<span class="lineno">  532 </span>loadTemplates :: Monad m =&gt; FilePath -&gt; IO (Either String (TemplateState m))
<span class="lineno">  533 </span><span class="decl"><span class="istickedoff">loadTemplates dir = do</span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff">d &lt;- readDirectoryWith (loadTemplate dir) dir</span>
<span class="lineno">  535 </span><span class="spaces">    </span><span class="istickedoff">let tlist = F.fold (free d)</span>
<span class="lineno">  536 </span><span class="spaces">        </span><span class="istickedoff">errs = lefts tlist</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">return $ case errs of</span>
<span class="lineno">  538 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; Right $ emptyTemplateState { _templateMap = Map.fromList $ rights tlist }</span>
<span class="lineno">  539 </span><span class="spaces">        </span><span class="istickedoff">_  -&gt; <span class="nottickedoff">Left $ unlines errs</span></span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>
<span class="lineno">  542 </span>------------------------------------------------------------------------------
<span class="lineno">  543 </span>-- | Renders a template from the specified TemplateState.
<span class="lineno">  544 </span>renderTemplate :: Monad m =&gt; TemplateState m -&gt; ByteString -&gt; m (Maybe ByteString)
<span class="lineno">  545 </span><span class="decl"><span class="istickedoff">renderTemplate ts name = do</span>
<span class="lineno">  546 </span><span class="spaces">    </span><span class="istickedoff">ns &lt;- runTemplateByName ts name</span>
<span class="lineno">  547 </span><span class="spaces">    </span><span class="istickedoff">return $ <span class="nottickedoff">(Just . formatList')</span> =&lt;&lt; ns</span></span>
<span class="lineno">  548 </span>
<span class="lineno">  549 </span>
<span class="lineno">  550 </span>------------------------------------------------------------------------------
<span class="lineno">  551 </span>-- | Reloads the templates from disk and renders the specified
<span class="lineno">  552 </span>-- template.
<span class="lineno">  553 </span>renderTemplate' :: FilePath -&gt; ByteString -&gt; IO (Maybe ByteString)
<span class="lineno">  554 </span><span class="decl"><span class="nottickedoff">renderTemplate' baseDir name = do</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="nottickedoff">etm &lt;- loadTemplates baseDir</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="nottickedoff">let ts = either (const emptyTemplateState) id etm</span>
<span class="lineno">  557 </span><span class="spaces">    </span><span class="nottickedoff">ns &lt;- runTemplateByName ts name</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="nottickedoff">return $ (Just . formatList') =&lt;&lt; ns</span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>------------------------------------------------------------------------------
<span class="lineno">  561 </span>-- These are here until we can get them into hexpat.
<span class="lineno">  562 </span>------------------------------------------------------------------------------
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>formatList :: (X.GenericXMLString tag, X.GenericXMLString text) =&gt;
<span class="lineno">  565 </span>              [X.Node tag text]
<span class="lineno">  566 </span>           -&gt; L.ByteString
<span class="lineno">  567 </span><span class="decl"><span class="nottickedoff">formatList nodes = foldl L.append L.empty $ map formatNode nodes</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>formatList' :: (X.GenericXMLString tag, X.GenericXMLString text) =&gt;
<span class="lineno">  570 </span>               [X.Node tag text]
<span class="lineno">  571 </span>            -&gt; B.ByteString
<span class="lineno">  572 </span><span class="decl"><span class="nottickedoff">formatList' = B.concat . L.toChunks . formatList</span></span>
<span class="lineno">  573 </span>

</pre>
</html>
